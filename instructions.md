# Обновленные инструкции по проекту Neuro-Link Assistant

## 1. Обзор проекта

**Neuro-Link Assistant** - это платформа для оркестрации различных моделей искусственного интеллекта и автоматизации задач. Система объединяет доступ к разным типам моделей AI (API, локальные, браузерные) и обеспечивает пошаговое выполнение задач.

### 1.1. Структура пользовательского интерфейса

Приложение организовано вокруг следующих ключевых разделов:

- **Главная/Дашборд** (`/`) - центральный пункт управления с формой ввода задач и мониторингом
- **Центр задач** (`/tasks`) - управление активными и историческими задачами
- **Центр управления моделями** (`/ai_models`) - настройка и управление различными моделями AI
- **Оркестратор моделей** (`/orchestrator`) - настройка маршрутизации и стратегий оптимизации
- **Шаблоны и рабочие процессы** (`/workflows`) - управление готовыми процессами
- **Настройки** (`/settings`) - общие настройки системы
- **Центр аналитики** (`/analytics`) - статистика и анализ выполнения задач

## 2. Методология разработки

### 2.1. Принципы TDD (Test-Driven Development)

Проект разрабатывается с использованием методологии TDD:

1. **Сначала тесты**: Перед написанием кода создаются тесты, определяющие ожидаемое поведение
2. **Красный-Зеленый-Рефакторинг**:
   - **Красный**: Создать тест, который не проходит
   - **Зеленый**: Написать минимальный код для прохождения теста
   - **Рефакторинг**: Улучшить код, сохраняя его функциональность
3. **Изолированное тестирование**: Каждый компонент тестируется независимо с использованием моков и стабов
4. **Полное покрытие**: Стремление к максимальному покрытию кода тестами

### 2.2. Состояние тестирования

#### 2.2.1. Реализованные тесты

✅ **Модульные тесты ядра системы**:
- tests/unit/core/test_component_registry.py
- tests/unit/core/test_error_handler.py
- tests/unit/core/test_plugin_manager.py
- tests/unit/core/test_system_initializer.py

✅ **Модульные тесты функциональных модулей**:
- tests/unit/core/vision/ (все файлы тестов)
- tests/unit/core/web/ (все файлы тестов)
- tests/unit/core/windows/ (все файлы тестов)
- tests/unit/core/llm/ (все файлы тестов из раздела LLM-интеграции)
- tests/unit/ui/ (тесты пользовательского интерфейса)
- tests/unit/core/windows_interaction/ (тесты взаимодействия с Windows)
- tests/unit/core/llm_integration/ (дополнительные тесты для интеграции LLM)
- tests/unit/core/architecture/ (тесты архитектуры системы)

#### 2.2.2. Отсутствующие тесты

❌ **Интеграционные тесты** (integration tests)
❌ **Системные тесты** (system tests)
❌ **Приемочные тесты** (acceptance tests)
❌ **Тесты системы принятия решений** (tests/unit/core/decision/)
❌ **Тесты установки программ** (tests/unit/core/installation/)

## 3. План полного рефакторинга

### 3.1. Уровень 1: Общая архитектура

- [ ] **Определение новой архитектуры и принципов дизайна**
  - [x] Определить новую структуру каталогов
  - [ ] Установить архитектурные принципы и паттерны
  - [ ] Определить интерфейсы взаимодействия между компонентами
  - [ ] Установить конвенции именования и кодирования

- [ ] **Настройка инфраструктуры тестирования**
  - [ ] Настроить модульные тесты для каждого компонента
  - [ ] Настроить интеграционные тесты для проверки взаимодействий
  - [ ] Настроить автоматизированное тестирование (CI)
  - [ ] Стандартизировать подход к мокированию и заглушкам

### 3.2. Уровень 2: Ядро системы

- [ ] **Базовые компоненты**
  - [ ] Реестр компонентов (component_registry.py)
  - [ ] Обработчик ошибок (error_handler.py)
  - [ ] Инициализатор системы (system_initializer.py)
  - [ ] Менеджер плагинов (plugin_manager.py)

- [ ] **Абстракции**
  - [ ] Абстрактные классы для всех подсистем
  - [ ] Интерфейсы для платформенно-зависимых компонентов
  - [ ] Фабрики для создания конкретных реализаций

### 3.3. Уровень 3: Подсистемы

#### 3.3.1. Подсистема ввода (высший приоритет)

- [ ] **Базовые классы и интерфейсы**
  - [ ] Создание абстрактного класса `KeyboardControllerBase`
  - [ ] Создание абстрактного класса `MouseControllerBase`
  - [ ] Создание класса `InputController`
  - [ ] Проверка через тесты интерфейсов

- [ ] **Фабрика и реестр**
  - [ ] Реализация `InputRegistry` для регистрации контроллеров
  - [ ] Реализация фабричных методов в `factory.py`
  - [ ] Создание тестов для фабрики и реестра

- [ ] **Реализация для Windows**
  - [ ] Реализация `WindowsKeyboard`
  - [ ] Реализация `WindowsMouse`
  - [ ] Проверка соответствия базовым интерфейсам

- [ ] **Тесты**
  - [ ] Тесты для базовых классов и интерфейсов
  - [ ] Тесты для фабрики и реестра
  - [ ] Тесты для конкретных реализаций
  - [ ] Интеграционные тесты подсистемы

#### 3.3.2. Подсистема файловой системы

- [ ] **Базовые классы и интерфейсы**
  - [ ] Создание абстрактного класса `FileSystemBase`
  - [ ] Создание интерфейса для операций с файлами
  - [ ] Определение контрактов для файловых операций

- [ ] **Фабрика и реестр**
  - [ ] Реализация `FileSystemRegistry`
  - [ ] Реализация фабричных методов для создания компонентов
  - [ ] Тестирование регистрации и создания компонентов

- [ ] **Реализация для Windows**
  - [ ] Реализация `WindowsFileSystem`
  - [ ] Реализация специфичных для Windows операций
  - [ ] Интеграция с базовыми интерфейсами

- [ ] **Тесты**
  - [ ] Модульные тесты для базовых классов
  - [ ] Модульные тесты для специфичных реализаций
  - [ ] Интеграционные тесты для проверки операций

#### 3.3.3. Подсистема компьютерного зрения

- [ ] **Абстракции и базовые классы**
  - [ ] Определение интерфейсов распознавания объектов
  - [ ] Создание базовых классов для захвата экрана
  - [ ] Определение стандартного API для локализации элементов

- [ ] **Конкретные реализации**
  - [ ] Реализация захвата экрана для Windows
  - [ ] Реализация распознавания текста и элементов
  - [ ] Реализация сравнения изображений

- [ ] **Тесты**
  - [ ] Тесты для захвата экрана
  - [ ] Тесты для распознавания элементов
  - [ ] Тесты для сравнения изображений

#### 3.3.4. Подсистема базы данных

- [ ] **Абстракции и интерфейсы**
  - [ ] Определение репозиториев для сущностей
  - [ ] Определение интерфейсов транзакций
  - [ ] Создание фабрик для компонентов БД

- [ ] **Реализации**
  - [ ] Реализация конкретных репозиториев
  - [ ] Реализация управления транзакциями
  - [ ] Миграция существующей схемы

- [ ] **Тесты**
  - [ ] Тесты для репозиториев
  - [ ] Тесты для транзакций
  - [ ] Тесты для миграций

#### 3.3.5. Подсистема LLM

- [ ] **Абстракции и интерфейсы**
  - [ ] Определение интерфейсов для работы с API моделей
  - [ ] Стандартизация обработки промптов
  - [ ] Унификация парсинга ответов

- [ ] **Реализации**
  - [ ] Реализация клиентов для различных API
  - [ ] Реализация обработчиков промптов
  - [ ] Реализация парсеров ответов

- [ ] **Тесты**
  - [ ] Тесты для API клиентов
  - [ ] Тесты для обработчиков промптов
  - [ ] Тесты для парсеров ответов

#### 3.3.6. Подсистема взаимодействия с веб

- [ ] **Абстракции и интерфейсы**
  - [ ] Определение интерфейсов для браузеров
  - [ ] Создание абстракций для веб-элементов
  - [ ] Стандартизация операций с веб-страницами

- [ ] **Реализации**
  - [ ] Реализация контроллера браузера
  - [ ] Реализация поиска и взаимодействия с элементами
  - [ ] Интеграция с подсистемой ввода

- [ ] **Тесты**
  - [ ] Тесты для контроллера браузера
  - [ ] Тесты для поиска элементов
  - [ ] Интеграционные тесты веб-взаимодействия

### 3.4. Уровень 4: Интеграция и системные компоненты

#### 3.4.1. Система плагинов

- [ ] **Абстракции и интерфейсы**
  - [ ] Определение интерфейсов плагинов
  - [ ] Создание менеджера плагинов
  - [ ] Разработка механизма регистрации и обнаружения

- [ ] **Реализации**
  - [ ] Реализация загрузки плагинов
  - [ ] Реализация жизненного цикла плагинов
  - [ ] Интеграция с реестром компонентов

- [ ] **Тесты**
  - [ ] Тесты для загрузки плагинов
  - [ ] Тесты для жизненного цикла
  - [ ] Интеграционные тесты системы плагинов

#### 3.4.2. API-интерфейсы

- [ ] **Абстракции и контракты**
  - [ ] Определение контрактов API
  - [ ] Стандартизация форматов запросов и ответов
  - [ ] Разработка обработчиков ошибок

- [ ] **Реализации**
  - [ ] Реализация маршрутов API
  - [ ] Интеграция с подсистемами
  - [ ] Документирование API

- [ ] **Тесты**
  - [ ] Тесты для маршрутов API
  - [ ] Тесты обработки ошибок
  - [ ] Интеграционные тесты API

### 3.5. Уровень 5: Финальная оптимизация

- [ ] **Оптимизация производительности**
  - [ ] Профилирование и оптимизация критичных компонентов
  - [ ] Анализ и устранение узких мест
  - [ ] Тесты производительности

- [ ] **Улучшение документации**
  - [ ] Документирование архитектуры
  - [ ] Создание руководств разработчика
  - [ ] Документирование API и интерфейсов

## 4. Устранение дублирования

### 4.1. Выявленное дублирование

1. **Файловая система**:
   - core/window и core/windows
   - core/platform/windows и core/windows
   - core/filesystem/file_manager.py и core/windows/file_system.py

2. **Контроллеры ввода**:
   - core/input и core/common/input
   - core/platform/windows/input и устаревшие контроллеры

3. **LLM модуль**:
   - core/llm/api_client.py и core/llm/api_connector.py

### 4.2. План реорганизации

1. **Файловая система**:
   - [ ] Создать абстрактный класс в core/common/filesystem/base.py
   - [ ] Перенести реализации в core/platform/<os>/filesystem
   - [ ] Обновить тесты для использования новой архитектуры
   - [ ] Удалить устаревшие файлы после миграции

2. **Контроллеры ввода**:
   - [ ] Создать полный набор абстракций в core/common/input
   - [ ] Переместить реализации в core/platform/<os>/input
   - [ ] Обновить тесты для использования новых компонентов
   - [ ] Удалить устаревшие компоненты после миграции

3. **LLM модуль**:
   - [ ] Создать единый интерфейс для работы с LLM
   - [ ] Реализовать стандартизированные клиенты API
   - [ ] Обновить обработчики и парсеры
   - [ ] Удалить дублирующийся код

## 5. Структура каталогов после рефакторинга

```
core/
│
├── common/                       # Общие компоненты и базовые классы
│   ├── error_handler.py
│   ├── filesystem/
│   ├── input/
│   ├── process/
│   ├── registry/
│   ├── system/
│   └── window/
│
├── component_registry.py         # Реестр компонентов системы
├── plugin_manager.py             # Менеджер плагинов
├── system_initializer.py         # Инициализатор системы
│
├── db/                           # Подсистема базы данных
│
├── platform/                     # Платформенно-зависимый код
│   ├── windows/                  # Реализации для Windows
│   │   ├── filesystem/
│   │   ├── input/
│   │   ├── process/
│   │   ├── system/
│   │   └── window/
│   └── ...                       # Другие платформы в будущем
│
├── llm/                          # Подсистема языковых моделей
├── utils/                        # Утилиты
├── vision/                       # Подсистема компьютерного зрения
└── web/                          # Подсистема работы с веб
```

## 6. Методика контроля прогресса

### 6.1. Тестовые проверки

- **Модульные тесты**:
  - Создание тестов перед началом реализации (TDD)
  - Проверка каждого компонента независимо
  - Использование моков для изоляции зависимостей

- **Интеграционные тесты**:
  - Проверка взаимодействия между компонентами
  - Тестирование подсистем в целом
  - Проверка интеграции между слоями

- **Системные тесты**:
  - Проверка полной функциональности системы
  - Тестирование взаимодействия всех подсистем
  - Проверка соответствия требованиям

### 6.2. Документирование прогресса

- **Регулярные обновления**:
  - Обновление плана рефакторинга с пометками о выполнении
  - Документирование проблем и их решений
  - Фиксация изменений в системе контроля версий

- **Отчеты о покрытии**:
  - Измерение тестового покрытия
  - Анализ сложности кода
  - Проверка соблюдения стандартов

### 6.3. Процесс рефакторинга

1. **Для каждого компонента**:
   - Создать тесты для определения интерфейса
   - Реализовать базовый интерфейс
   - Создать конкретные реализации
   - Проверить компонент тестами
   - Интегрировать с другими компонентами

2. **При обнаружении проблем**:
   - Зафиксировать проблему в системе отслеживания
   - Создать тест, воспроизводящий проблему
   - Исправить проблему
   - Проверить исправление тестом
   - Обновить документацию

## 7. Приоритеты развития

1. **Первоочередные задачи**:
   - Рефакторинг подсистемы ввода
   - Устранение дублирования файловых систем
   - Стандартизация обработки ошибок

2. **Второй приоритет**:
   - Рефакторинг компьютерного зрения
   - Рефакторинг управления окнами
   - Рефакторинг взаимодействия с веб

3. **Третий приоритет**:
   - Рефакторинг базы данных
   - Рефакторинг LLM компонентов
   - Рефакторинг системы плагинов

## 8. Технические детали

### 8.1. Стандарты кодирования

- **Форматирование**: Следовать PEP 8
- **Типизация**: Использовать подсказки типов (type hints)
- **Документирование**: Документировать все публичные методы и классы
- **Стиль выбросов исключений**: Определить и следовать стандарту
- **Обработка ошибок**: Использовать единый подход

### 8.2. Соглашения об именовании

- **Классы**: CamelCase (например, FileManager)
- **Методы и функции**: snake_case (например, read_file)
- **Константы**: UPPER_SNAKE_CASE (например, DEFAULT_TIMEOUT)
- **Приватные члены**: Префикс с подчеркиванием (например, _private_method)
- **Интерфейсы**: Префикс I или суффикс Base/Interface (например, IFileSystem или FileSystemBase)

### 8.3. Подключение к БД

```
1. Подключение к БД через pgAdmin
- Откройте в браузере http://localhost:5050
- Войдите с учетными данными из docker-compose.yml
- Добавьте новый сервер:
  - Имя: NeuroLink DB
  - Хост: postgres
  - Порт: 5432
  - База данных: neurolink_db
  - Пользователь: neurolink
  - Пароль: secure_password
```

Данный план будет обновляться по мере прогресса рефакторинга для отражения текущего состояния и внесения корректировок на основе полученного опыта. Все изменения должны строго соответствовать принципам TDD и проходить полное тестирование перед внедрением.
