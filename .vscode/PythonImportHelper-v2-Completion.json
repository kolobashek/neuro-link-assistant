[
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "pythoncom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pythoncom",
        "description": "pythoncom",
        "detail": "pythoncom",
        "documentation": {}
    },
    {
        "label": "win32api",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32api",
        "description": "win32api",
        "detail": "win32api",
        "documentation": {}
    },
    {
        "label": "win32con",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32con",
        "description": "win32con",
        "detail": "win32con",
        "documentation": {}
    },
    {
        "label": "win32file",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32file",
        "description": "win32file",
        "detail": "win32file",
        "documentation": {}
    },
    {
        "label": "wmi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wmi",
        "description": "wmi",
        "detail": "wmi",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "cgi",
        "description": "cgi",
        "isExtraImport": true,
        "detail": "cgi",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "cgi",
        "description": "cgi",
        "isExtraImport": true,
        "detail": "cgi",
        "documentation": {}
    },
    {
        "label": "make_server",
        "importPath": "wsgiref.simple_server",
        "description": "wsgiref.simple_server",
        "isExtraImport": true,
        "detail": "wsgiref.simple_server",
        "documentation": {}
    },
    {
        "label": "make_server",
        "importPath": "wsgiref.simple_server",
        "description": "wsgiref.simple_server",
        "isExtraImport": true,
        "detail": "wsgiref.simple_server",
        "documentation": {}
    },
    {
        "label": "request_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "application_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "shift_path_info",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "request_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "application_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "shift_path_info",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "pyautogui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyautogui",
        "description": "pyautogui",
        "detail": "pyautogui",
        "documentation": {}
    },
    {
        "label": "win32gui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32gui",
        "description": "win32gui",
        "detail": "win32gui",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "runtime_checkable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "importPath": "core.common.filesystem.base",
        "description": "core.common.filesystem.base",
        "isExtraImport": true,
        "detail": "core.common.filesystem.base",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "importPath": "core.common.filesystem.base",
        "description": "core.common.filesystem.base",
        "isExtraImport": true,
        "detail": "core.common.filesystem.base",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "importPath": "core.common.filesystem.base",
        "description": "core.common.filesystem.base",
        "isExtraImport": true,
        "detail": "core.common.filesystem.base",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "importPath": "core.common.filesystem.base",
        "description": "core.common.filesystem.base",
        "isExtraImport": true,
        "detail": "core.common.filesystem.base",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "importPath": "core.common.filesystem.base",
        "description": "core.common.filesystem.base",
        "isExtraImport": true,
        "detail": "core.common.filesystem.base",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "importPath": "core.common.filesystem.base",
        "description": "core.common.filesystem.base",
        "isExtraImport": true,
        "detail": "core.common.filesystem.base",
        "documentation": {}
    },
    {
        "label": "get_file_system_implementation",
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "isExtraImport": true,
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "is_file_system_registered",
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "isExtraImport": true,
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "register_file_system",
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "isExtraImport": true,
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "get_file_system_implementation",
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "isExtraImport": true,
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "get_registered_file_systems",
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "isExtraImport": true,
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "is_file_system_registered",
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "isExtraImport": true,
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "register_file_system",
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "isExtraImport": true,
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "AbstractKeyboard",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractMouse",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "InputController",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractKeyboard",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractMouse",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractKeyboard",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractMouse",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractKeyboard",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractMouse",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "InputController",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractKeyboard",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractMouse",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractKeyboard",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractMouse",
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "isExtraImport": true,
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "InputRegistry",
        "importPath": "core.common.input.registry",
        "description": "core.common.input.registry",
        "isExtraImport": true,
        "detail": "core.common.input.registry",
        "documentation": {}
    },
    {
        "label": "InputRegistry",
        "importPath": "core.common.input.registry",
        "description": "core.common.input.registry",
        "isExtraImport": true,
        "detail": "core.common.input.registry",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_llm_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "ErrorHandler",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "ErrorHandler",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "ErrorHandler",
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "isExtraImport": true,
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "AbstractProcessManager",
        "importPath": "core.common.process.base",
        "description": "core.common.process.base",
        "isExtraImport": true,
        "detail": "core.common.process.base",
        "documentation": {}
    },
    {
        "label": "AbstractProcessManager",
        "importPath": "core.common.process.base",
        "description": "core.common.process.base",
        "isExtraImport": true,
        "detail": "core.common.process.base",
        "documentation": {}
    },
    {
        "label": "AbstractRegistryManager",
        "importPath": "core.common.registry.base",
        "description": "core.common.registry.base",
        "isExtraImport": true,
        "detail": "core.common.registry.base",
        "documentation": {}
    },
    {
        "label": "AbstractRegistryManager",
        "importPath": "core.common.registry.base",
        "description": "core.common.registry.base",
        "isExtraImport": true,
        "detail": "core.common.registry.base",
        "documentation": {}
    },
    {
        "label": "AbstractSystemInfo",
        "importPath": "core.common.system.base",
        "description": "core.common.system.base",
        "isExtraImport": true,
        "detail": "core.common.system.base",
        "documentation": {}
    },
    {
        "label": "AbstractSystemInfo",
        "importPath": "core.common.system.base",
        "description": "core.common.system.base",
        "isExtraImport": true,
        "detail": "core.common.system.base",
        "documentation": {}
    },
    {
        "label": "AbstractWindowManager",
        "importPath": "core.common.window.base",
        "description": "core.common.window.base",
        "isExtraImport": true,
        "detail": "core.common.window.base",
        "documentation": {}
    },
    {
        "label": "AbstractWindowManager",
        "importPath": "core.common.window.base",
        "description": "core.common.window.base",
        "isExtraImport": true,
        "detail": "core.common.window.base",
        "documentation": {}
    },
    {
        "label": "AbstractWindowManager",
        "importPath": "core.common.window.base",
        "description": "core.common.window.base",
        "isExtraImport": true,
        "detail": "core.common.window.base",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "sqlalchemy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "desc",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "or_",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "desc",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "and_",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "asc",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "desc",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "or_",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "JSON",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "DateTime",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "inspect",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "inspect",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "engine_from_config",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "pool",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "inspect",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "inspect",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "DeclarativeBase",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Workflow",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "WorkflowStep",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "AIModel",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Workflow",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "AIModel",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "AIModel",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Workflow",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "AIModel",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "core.db.models",
        "description": "core.db.models",
        "isExtraImport": true,
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "func",
        "importPath": "sqlalchemy.sql",
        "description": "sqlalchemy.sql",
        "isExtraImport": true,
        "detail": "sqlalchemy.sql",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "isExtraImport": true,
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "isExtraImport": true,
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "isExtraImport": true,
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "isExtraImport": true,
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "requests.exceptions",
        "description": "requests.exceptions",
        "isExtraImport": true,
        "detail": "requests.exceptions",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "importPath": "core.common.file_system",
        "description": "core.common.file_system",
        "isExtraImport": true,
        "detail": "core.common.file_system",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "importPath": "core.common.file_system",
        "description": "core.common.file_system",
        "isExtraImport": true,
        "detail": "core.common.file_system",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "wintypes",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "win32clipboard",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32clipboard",
        "description": "win32clipboard",
        "detail": "win32clipboard",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "pygetwindow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygetwindow",
        "description": "pygetwindow",
        "detail": "pygetwindow",
        "documentation": {}
    },
    {
        "label": "win32process",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32process",
        "description": "win32process",
        "detail": "win32process",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "jwt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jwt",
        "description": "jwt",
        "detail": "jwt",
        "documentation": {}
    },
    {
        "label": "secrets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "secrets",
        "description": "secrets",
        "detail": "secrets",
        "documentation": {}
    },
    {
        "label": "UserRepository",
        "importPath": "core.db.repository.user_repository",
        "description": "core.db.repository.user_repository",
        "isExtraImport": true,
        "detail": "core.db.repository.user_repository",
        "documentation": {}
    },
    {
        "label": "UserRepository",
        "importPath": "core.db.repository.user_repository",
        "description": "core.db.repository.user_repository",
        "isExtraImport": true,
        "detail": "core.db.repository.user_repository",
        "documentation": {}
    },
    {
        "label": "UserRepository",
        "importPath": "core.db.repository.user_repository",
        "description": "core.db.repository.user_repository",
        "isExtraImport": true,
        "detail": "core.db.repository.user_repository",
        "documentation": {}
    },
    {
        "label": "UserRepository",
        "importPath": "core.db.repository.user_repository",
        "description": "core.db.repository.user_repository",
        "isExtraImport": true,
        "detail": "core.db.repository.user_repository",
        "documentation": {}
    },
    {
        "label": "create_access_token",
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "isExtraImport": true,
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "verify_token",
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "isExtraImport": true,
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "create_access_token",
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "isExtraImport": true,
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "decode_token",
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "isExtraImport": true,
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "verify_token",
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "isExtraImport": true,
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "importPath": "core.security.password",
        "description": "core.security.password",
        "isExtraImport": true,
        "detail": "core.security.password",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "importPath": "core.security.password",
        "description": "core.security.password",
        "isExtraImport": true,
        "detail": "core.security.password",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "importPath": "core.security.password",
        "description": "core.security.password",
        "isExtraImport": true,
        "detail": "core.security.password",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "importPath": "core.security.password",
        "description": "core.security.password",
        "isExtraImport": true,
        "detail": "core.security.password",
        "documentation": {}
    },
    {
        "label": "AuthService",
        "importPath": "core.services.auth_service",
        "description": "core.services.auth_service",
        "isExtraImport": true,
        "detail": "core.services.auth_service",
        "documentation": {}
    },
    {
        "label": "AuthService",
        "importPath": "core.services.auth_service",
        "description": "core.services.auth_service",
        "isExtraImport": true,
        "detail": "core.services.auth_service",
        "documentation": {}
    },
    {
        "label": "AuthService",
        "importPath": "core.services.auth_service",
        "description": "core.services.auth_service",
        "isExtraImport": true,
        "detail": "core.services.auth_service",
        "documentation": {}
    },
    {
        "label": "AuthService",
        "importPath": "core.services.auth_service",
        "description": "core.services.auth_service",
        "isExtraImport": true,
        "detail": "core.services.auth_service",
        "documentation": {}
    },
    {
        "label": "TaskResult",
        "importPath": "core.task.result",
        "description": "core.task.result",
        "isExtraImport": true,
        "detail": "core.task.result",
        "documentation": {}
    },
    {
        "label": "TaskResult",
        "importPath": "core.task.result",
        "description": "core.task.result",
        "isExtraImport": true,
        "detail": "core.task.result",
        "documentation": {}
    },
    {
        "label": "TaskResult",
        "importPath": "core.task.result",
        "description": "core.task.result",
        "isExtraImport": true,
        "detail": "core.task.result",
        "documentation": {}
    },
    {
        "label": "TaskResult",
        "importPath": "core.task.result",
        "description": "core.task.result",
        "isExtraImport": true,
        "detail": "core.task.result",
        "documentation": {}
    },
    {
        "label": "TaskResult",
        "importPath": "core.task.result",
        "description": "core.task.result",
        "isExtraImport": true,
        "detail": "core.task.result",
        "documentation": {}
    },
    {
        "label": "TaskResult",
        "importPath": "core.task.result",
        "description": "core.task.result",
        "isExtraImport": true,
        "detail": "core.task.result",
        "documentation": {}
    },
    {
        "label": "TaskResult",
        "importPath": "core.task.result",
        "description": "core.task.result",
        "isExtraImport": true,
        "detail": "core.task.result",
        "documentation": {}
    },
    {
        "label": "AuthOperationsMixin",
        "importPath": "core.task.auth_operations",
        "description": "core.task.auth_operations",
        "isExtraImport": true,
        "detail": "core.task.auth_operations",
        "documentation": {}
    },
    {
        "label": "FileOperationsMixin",
        "importPath": "core.task.file_operations",
        "description": "core.task.file_operations",
        "isExtraImport": true,
        "detail": "core.task.file_operations",
        "documentation": {}
    },
    {
        "label": "ModelOrchestrationOperationsMixin",
        "importPath": "core.task.model_orchestration_operations",
        "description": "core.task.model_orchestration_operations",
        "isExtraImport": true,
        "detail": "core.task.model_orchestration_operations",
        "documentation": {}
    },
    {
        "label": "VisionOperationsMixin",
        "importPath": "core.task.vision_operations",
        "description": "core.task.vision_operations",
        "isExtraImport": true,
        "detail": "core.task.vision_operations",
        "documentation": {}
    },
    {
        "label": "WebOperationsMixin",
        "importPath": "core.task.web_operations",
        "description": "core.task.web_operations",
        "isExtraImport": true,
        "detail": "core.task.web_operations",
        "documentation": {}
    },
    {
        "label": "WindowsOperationsMixin",
        "importPath": "core.task.windows_operations",
        "description": "core.task.windows_operations",
        "isExtraImport": true,
        "detail": "core.task.windows_operations",
        "documentation": {}
    },
    {
        "label": "TaskResult",
        "importPath": "core.task.base",
        "description": "core.task.base",
        "isExtraImport": true,
        "detail": "core.task.base",
        "documentation": {}
    },
    {
        "label": "ElementRecognition",
        "importPath": "core.vision.element_recognition",
        "description": "core.vision.element_recognition",
        "isExtraImport": true,
        "detail": "core.vision.element_recognition",
        "documentation": {}
    },
    {
        "label": "ElementRecognition",
        "importPath": "core.vision.element_recognition",
        "description": "core.vision.element_recognition",
        "isExtraImport": true,
        "detail": "core.vision.element_recognition",
        "documentation": {}
    },
    {
        "label": "ScreenCapture",
        "importPath": "core.vision.screen_capture",
        "description": "core.vision.screen_capture",
        "isExtraImport": true,
        "detail": "core.vision.screen_capture",
        "documentation": {}
    },
    {
        "label": "ScreenCapture",
        "importPath": "core.vision.screen_capture",
        "description": "core.vision.screen_capture",
        "isExtraImport": true,
        "detail": "core.vision.screen_capture",
        "documentation": {}
    },
    {
        "label": "ScreenCapture",
        "importPath": "core.vision.screen_capture",
        "description": "core.vision.screen_capture",
        "isExtraImport": true,
        "detail": "core.vision.screen_capture",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pytesseract",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytesseract",
        "description": "pytesseract",
        "detail": "pytesseract",
        "documentation": {}
    },
    {
        "label": "ImageComparison",
        "importPath": "core.vision.image_comparison",
        "description": "core.vision.image_comparison",
        "isExtraImport": true,
        "detail": "core.vision.image_comparison",
        "documentation": {}
    },
    {
        "label": "ImageComparison",
        "importPath": "core.vision.image_comparison",
        "description": "core.vision.image_comparison",
        "isExtraImport": true,
        "detail": "core.vision.image_comparison",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "selenium.webdriver.chrome.options",
        "description": "selenium.webdriver.chrome.options",
        "isExtraImport": true,
        "detail": "selenium.webdriver.chrome.options",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "selenium.webdriver.chrome.options",
        "description": "selenium.webdriver.chrome.options",
        "isExtraImport": true,
        "detail": "selenium.webdriver.chrome.options",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "selenium.webdriver.chrome.options",
        "description": "selenium.webdriver.chrome.options",
        "isExtraImport": true,
        "detail": "selenium.webdriver.chrome.options",
        "documentation": {}
    },
    {
        "label": "Service",
        "importPath": "selenium.webdriver.chrome.service",
        "description": "selenium.webdriver.chrome.service",
        "isExtraImport": true,
        "detail": "selenium.webdriver.chrome.service",
        "documentation": {}
    },
    {
        "label": "Service",
        "importPath": "selenium.webdriver.chrome.service",
        "description": "selenium.webdriver.chrome.service",
        "isExtraImport": true,
        "detail": "selenium.webdriver.chrome.service",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "selenium.webdriver.edge.options",
        "description": "selenium.webdriver.edge.options",
        "isExtraImport": true,
        "detail": "selenium.webdriver.edge.options",
        "documentation": {}
    },
    {
        "label": "Service",
        "importPath": "selenium.webdriver.edge.service",
        "description": "selenium.webdriver.edge.service",
        "isExtraImport": true,
        "detail": "selenium.webdriver.edge.service",
        "documentation": {}
    },
    {
        "label": "Options",
        "importPath": "selenium.webdriver.firefox.options",
        "description": "selenium.webdriver.firefox.options",
        "isExtraImport": true,
        "detail": "selenium.webdriver.firefox.options",
        "documentation": {}
    },
    {
        "label": "Service",
        "importPath": "selenium.webdriver.firefox.service",
        "description": "selenium.webdriver.firefox.service",
        "isExtraImport": true,
        "detail": "selenium.webdriver.firefox.service",
        "documentation": {}
    },
    {
        "label": "ChromeDriverManager",
        "importPath": "webdriver_manager.chrome",
        "description": "webdriver_manager.chrome",
        "isExtraImport": true,
        "detail": "webdriver_manager.chrome",
        "documentation": {}
    },
    {
        "label": "ChromeDriverManager",
        "importPath": "webdriver_manager.chrome",
        "description": "webdriver_manager.chrome",
        "isExtraImport": true,
        "detail": "webdriver_manager.chrome",
        "documentation": {}
    },
    {
        "label": "GeckoDriverManager",
        "importPath": "webdriver_manager.firefox",
        "description": "webdriver_manager.firefox",
        "isExtraImport": true,
        "detail": "webdriver_manager.firefox",
        "documentation": {}
    },
    {
        "label": "EdgeChromiumDriverManager",
        "importPath": "webdriver_manager.microsoft",
        "description": "webdriver_manager.microsoft",
        "isExtraImport": true,
        "detail": "webdriver_manager.microsoft",
        "documentation": {}
    },
    {
        "label": "NoSuchElementException",
        "importPath": "selenium.common.exceptions",
        "description": "selenium.common.exceptions",
        "isExtraImport": true,
        "detail": "selenium.common.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutException",
        "importPath": "selenium.common.exceptions",
        "description": "selenium.common.exceptions",
        "isExtraImport": true,
        "detail": "selenium.common.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutException",
        "importPath": "selenium.common.exceptions",
        "description": "selenium.common.exceptions",
        "isExtraImport": true,
        "detail": "selenium.common.exceptions",
        "documentation": {}
    },
    {
        "label": "NoSuchElementException",
        "importPath": "selenium.common.exceptions",
        "description": "selenium.common.exceptions",
        "isExtraImport": true,
        "detail": "selenium.common.exceptions",
        "documentation": {}
    },
    {
        "label": "TimeoutException",
        "importPath": "selenium.common.exceptions",
        "description": "selenium.common.exceptions",
        "isExtraImport": true,
        "detail": "selenium.common.exceptions",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "op",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "fileConfig",
        "importPath": "logging.config",
        "description": "logging.config",
        "isExtraImport": true,
        "detail": "logging.config",
        "documentation": {}
    },
    {
        "label": "abspath",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "dirname",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "g",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "make_response",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "CommandExecution",
        "importPath": "models.command_models",
        "description": "models.command_models",
        "isExtraImport": true,
        "detail": "models.command_models",
        "documentation": {}
    },
    {
        "label": "CommandStep",
        "importPath": "models.command_models",
        "description": "models.command_models",
        "isExtraImport": true,
        "detail": "models.command_models",
        "documentation": {}
    },
    {
        "label": "CommandExecution",
        "importPath": "models.command_models",
        "description": "models.command_models",
        "isExtraImport": true,
        "detail": "models.command_models",
        "documentation": {}
    },
    {
        "label": "CommandStep",
        "importPath": "models.command_models",
        "description": "models.command_models",
        "isExtraImport": true,
        "detail": "models.command_models",
        "documentation": {}
    },
    {
        "label": "update_models_from_huggingface",
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "isExtraImport": true,
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "check_ai_model_availability",
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "isExtraImport": true,
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "get_ai_models",
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "isExtraImport": true,
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "search_models",
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "isExtraImport": true,
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "select_ai_model",
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "isExtraImport": true,
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "get_ai_response",
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "isExtraImport": true,
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "check_ai_model_availability",
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "isExtraImport": true,
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "get_ai_models",
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "isExtraImport": true,
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "execute_command_with_error_handling",
        "importPath": "services.command_service",
        "description": "services.command_service",
        "isExtraImport": true,
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "execute_command_with_steps",
        "importPath": "services.command_service",
        "description": "services.command_service",
        "isExtraImport": true,
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "execute_python_code",
        "importPath": "services.command_service",
        "description": "services.command_service",
        "isExtraImport": true,
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "process_command",
        "importPath": "services.command_service",
        "description": "services.command_service",
        "isExtraImport": true,
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "log_execution_summary",
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "isExtraImport": true,
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "log_execution_summary",
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "isExtraImport": true,
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "isExtraImport": true,
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "isExtraImport": true,
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "AppManager",
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "isExtraImport": true,
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "AppMode",
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "isExtraImport": true,
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "PortManager",
        "importPath": "scripts.network.port_manager",
        "description": "scripts.network.port_manager",
        "isExtraImport": true,
        "detail": "scripts.network.port_manager",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "HfApi",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "HfApi",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "HfFolder",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "Repository",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "HuggingFaceService",
        "importPath": "services.huggingface_service",
        "description": "services.huggingface_service",
        "isExtraImport": true,
        "detail": "services.huggingface_service",
        "documentation": {}
    },
    {
        "label": "HuggingFaceService",
        "importPath": "services.huggingface_service",
        "description": "services.huggingface_service",
        "isExtraImport": true,
        "detail": "services.huggingface_service",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "pyperclip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyperclip",
        "description": "pyperclip",
        "detail": "pyperclip",
        "documentation": {}
    },
    {
        "label": "Keys",
        "importPath": "selenium.webdriver.common.keys",
        "description": "selenium.webdriver.common.keys",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.keys",
        "documentation": {}
    },
    {
        "label": "Keys",
        "importPath": "selenium.webdriver.common.keys",
        "description": "selenium.webdriver.common.keys",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.keys",
        "documentation": {}
    },
    {
        "label": "Keys",
        "importPath": "selenium.webdriver.common.keys",
        "description": "selenium.webdriver.common.keys",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.keys",
        "documentation": {}
    },
    {
        "label": "speak_text",
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "isExtraImport": true,
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "COMMAND_ALIASES",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "COMMANDS",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "get_command_function",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "add_interrupt_checks",
        "importPath": "utils.helpers",
        "description": "utils.helpers",
        "isExtraImport": true,
        "detail": "utils.helpers",
        "documentation": {}
    },
    {
        "label": "extract_code_from_response",
        "importPath": "utils.helpers",
        "description": "utils.helpers",
        "isExtraImport": true,
        "detail": "utils.helpers",
        "documentation": {}
    },
    {
        "label": "extract_math_expression",
        "importPath": "utils.helpers",
        "description": "utils.helpers",
        "isExtraImport": true,
        "detail": "utils.helpers",
        "documentation": {}
    },
    {
        "label": "RepositoryNotFoundError",
        "importPath": "huggingface_hub.errors",
        "description": "huggingface_hub.errors",
        "isExtraImport": true,
        "detail": "huggingface_hub.errors",
        "documentation": {}
    },
    {
        "label": "RevisionNotFoundError",
        "importPath": "huggingface_hub.errors",
        "description": "huggingface_hub.errors",
        "isExtraImport": true,
        "detail": "huggingface_hub.errors",
        "documentation": {}
    },
    {
        "label": "AutoConfig",
        "importPath": "transformers.models.auto.configuration_auto",
        "description": "transformers.models.auto.configuration_auto",
        "isExtraImport": true,
        "detail": "transformers.models.auto.configuration_auto",
        "documentation": {}
    },
    {
        "label": "AutoModelForCausalLM",
        "importPath": "transformers.models.auto.modeling_auto",
        "description": "transformers.models.auto.modeling_auto",
        "isExtraImport": true,
        "detail": "transformers.models.auto.modeling_auto",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers.models.auto.tokenization_auto",
        "description": "transformers.models.auto.tokenization_auto",
        "isExtraImport": true,
        "detail": "transformers.models.auto.tokenization_auto",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "PropertyMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "PropertyMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "restart_db",
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "isExtraImport": true,
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "run_command",
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "isExtraImport": true,
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "show_db_logs",
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "isExtraImport": true,
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "start_db",
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "isExtraImport": true,
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "stop_db",
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "isExtraImport": true,
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "ComponentRegistry",
        "importPath": "core.component_registry",
        "description": "core.component_registry",
        "isExtraImport": true,
        "detail": "core.component_registry",
        "documentation": {}
    },
    {
        "label": "ComponentRegistry",
        "importPath": "core.component_registry",
        "description": "core.component_registry",
        "isExtraImport": true,
        "detail": "core.component_registry",
        "documentation": {}
    },
    {
        "label": "PluginManager",
        "importPath": "core.plugin_manager",
        "description": "core.plugin_manager",
        "isExtraImport": true,
        "detail": "core.plugin_manager",
        "documentation": {}
    },
    {
        "label": "PluginManager",
        "importPath": "core.plugin_manager",
        "description": "core.plugin_manager",
        "isExtraImport": true,
        "detail": "core.plugin_manager",
        "documentation": {}
    },
    {
        "label": "PluginManager",
        "importPath": "core.plugin_manager",
        "description": "core.plugin_manager",
        "isExtraImport": true,
        "detail": "core.plugin_manager",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "isExtraImport": true,
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "AIModelService",
        "importPath": "core.services.ai_model_service",
        "description": "core.services.ai_model_service",
        "isExtraImport": true,
        "detail": "core.services.ai_model_service",
        "documentation": {}
    },
    {
        "label": "TaskService",
        "importPath": "core.services.task_service",
        "description": "core.services.task_service",
        "isExtraImport": true,
        "detail": "core.services.task_service",
        "documentation": {}
    },
    {
        "label": "UserService",
        "importPath": "core.services.user_service",
        "description": "core.services.user_service",
        "isExtraImport": true,
        "detail": "core.services.user_service",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "get_file_system",
        "importPath": "core.common.filesystem",
        "description": "core.common.filesystem",
        "isExtraImport": true,
        "detail": "core.common.filesystem",
        "documentation": {}
    },
    {
        "label": "get_file_system",
        "importPath": "core.common.filesystem",
        "description": "core.common.filesystem",
        "isExtraImport": true,
        "detail": "core.common.filesystem",
        "documentation": {}
    },
    {
        "label": "create_file_system",
        "importPath": "core.common.filesystem.factory",
        "description": "core.common.filesystem.factory",
        "isExtraImport": true,
        "detail": "core.common.filesystem.factory",
        "documentation": {}
    },
    {
        "label": "register_file_system_implementation",
        "importPath": "core.common.filesystem.factory",
        "description": "core.common.filesystem.factory",
        "isExtraImport": true,
        "detail": "core.common.filesystem.factory",
        "documentation": {}
    },
    {
        "label": "get_mouse",
        "importPath": "core.common.input.factory",
        "description": "core.common.input.factory",
        "isExtraImport": true,
        "detail": "core.common.input.factory",
        "documentation": {}
    },
    {
        "label": "ResponseParser",
        "importPath": "core.llm.response_parser",
        "description": "core.llm.response_parser",
        "isExtraImport": true,
        "detail": "core.llm.response_parser",
        "documentation": {}
    },
    {
        "label": "Win32FileSystem",
        "importPath": "core.platform.windows.filesystem",
        "description": "core.platform.windows.filesystem",
        "isExtraImport": true,
        "detail": "core.platform.windows.filesystem",
        "documentation": {}
    },
    {
        "label": "BaseFileSystemTest",
        "importPath": "tests.unit.core.common.filesystem.test_base_filesystem",
        "description": "tests.unit.core.common.filesystem.test_base_filesystem",
        "isExtraImport": true,
        "detail": "tests.unit.core.common.filesystem.test_base_filesystem",
        "documentation": {}
    },
    {
        "label": "WindowsKeyboard",
        "importPath": "core.platform.windows.input.keyboard",
        "description": "core.platform.windows.input.keyboard",
        "isExtraImport": true,
        "detail": "core.platform.windows.input.keyboard",
        "documentation": {}
    },
    {
        "label": "WindowsMouse",
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "isExtraImport": true,
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "Win32RegistryManager",
        "importPath": "core.platform.windows.registry.win32_registry_manager",
        "description": "core.platform.windows.registry.win32_registry_manager",
        "isExtraImport": true,
        "detail": "core.platform.windows.registry.win32_registry_manager",
        "documentation": {}
    },
    {
        "label": "Win32WindowManager",
        "importPath": "core.platform.windows.window.win32_window_manager",
        "description": "core.platform.windows.window.win32_window_manager",
        "isExtraImport": true,
        "detail": "core.platform.windows.window.win32_window_manager",
        "documentation": {}
    },
    {
        "label": "Win32WindowManager",
        "importPath": "core.platform.windows.window.win32_window_manager",
        "description": "core.platform.windows.window.win32_window_manager",
        "isExtraImport": true,
        "detail": "core.platform.windows.window.win32_window_manager",
        "documentation": {}
    },
    {
        "label": "ElementLocalization",
        "importPath": "core.vision.element_localization",
        "description": "core.vision.element_localization",
        "isExtraImport": true,
        "detail": "core.vision.element_localization",
        "documentation": {}
    },
    {
        "label": "ScreenChanges",
        "importPath": "core.vision.screen_changes",
        "description": "core.vision.screen_changes",
        "isExtraImport": true,
        "detail": "core.vision.screen_changes",
        "documentation": {}
    },
    {
        "label": "psycopg2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psycopg2",
        "description": "psycopg2",
        "detail": "psycopg2",
        "documentation": {}
    },
    {
        "label": "ISOLATION_LEVEL_AUTOCOMMIT",
        "importPath": "psycopg2.extensions",
        "description": "psycopg2.extensions",
        "isExtraImport": true,
        "detail": "psycopg2.extensions",
        "documentation": {}
    },
    {
        "label": "ISOLATION_LEVEL_AUTOCOMMIT",
        "importPath": "psycopg2.extensions",
        "description": "psycopg2.extensions",
        "isExtraImport": true,
        "detail": "psycopg2.extensions",
        "documentation": {}
    },
    {
        "label": "create_user",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_ai_model",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_task",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_user",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_ai_model_by_id",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_ai_models",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_tasks_by_user",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_user_by_id",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_user_by_username",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "update_task_status",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_task",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_user",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_tasks_with_pagination",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_ai_model",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_task",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_user",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_ai_model",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_task",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_user",
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "isExtraImport": true,
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "IntegrityError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "IntegrityError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "DataError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "IntegrityError",
        "importPath": "sqlalchemy.exc",
        "description": "sqlalchemy.exc",
        "isExtraImport": true,
        "detail": "sqlalchemy.exc",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlunparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "alembic.config",
        "description": "alembic.config",
        "isExtraImport": true,
        "detail": "alembic.config",
        "documentation": {}
    },
    {
        "label": "MigrationContext",
        "importPath": "alembic.runtime.migration",
        "description": "alembic.runtime.migration",
        "isExtraImport": true,
        "detail": "alembic.runtime.migration",
        "documentation": {}
    },
    {
        "label": "ScriptDirectory",
        "importPath": "alembic.script",
        "description": "alembic.script",
        "isExtraImport": true,
        "detail": "alembic.script",
        "documentation": {}
    },
    {
        "label": "TaskRepository",
        "importPath": "core.db.repository.task_repository",
        "description": "core.db.repository.task_repository",
        "isExtraImport": true,
        "detail": "core.db.repository.task_repository",
        "documentation": {}
    },
    {
        "label": "TaskRepository",
        "importPath": "core.db.repository.task_repository",
        "description": "core.db.repository.task_repository",
        "isExtraImport": true,
        "detail": "core.db.repository.task_repository",
        "documentation": {}
    },
    {
        "label": "WorkflowRepository",
        "importPath": "core.db.repository.workflow_repository",
        "description": "core.db.repository.workflow_repository",
        "isExtraImport": true,
        "detail": "core.db.repository.workflow_repository",
        "documentation": {}
    },
    {
        "label": "PermissionService",
        "importPath": "core.services.permission_service",
        "description": "core.services.permission_service",
        "isExtraImport": true,
        "detail": "core.services.permission_service",
        "documentation": {}
    },
    {
        "label": "TransactionManager",
        "importPath": "core.db.transaction",
        "description": "core.db.transaction",
        "isExtraImport": true,
        "detail": "core.db.transaction",
        "documentation": {}
    },
    {
        "label": "transaction",
        "importPath": "core.db.transaction",
        "description": "core.db.transaction",
        "isExtraImport": true,
        "detail": "core.db.transaction",
        "documentation": {}
    },
    {
        "label": "ElementFinder",
        "importPath": "core.web.element_finder",
        "description": "core.web.element_finder",
        "isExtraImport": true,
        "detail": "core.web.element_finder",
        "documentation": {}
    },
    {
        "label": "RotatingFileHandler",
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "isExtraImport": true,
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "api_bp",
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "isExtraImport": true,
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "main_bp",
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "isExtraImport": true,
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len('Scripts') - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = 'neuro-link-assistant-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '..\\\\Lib\\\\site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "base = bin_dir[: -len('Scripts') - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = 'neuro-link-assistant-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '..\\\\Lib\\\\site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = 'neuro-link-assistant-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '..\\\\Lib\\\\site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = 'neuro-link-assistant-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '..\\\\Lib\\\\site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = 'neuro-link-assistant-py3.13' or os.path.basename(base)\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in '..\\\\Lib\\\\site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in '..\\\\Lib\\\\site-packages'.split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if '' else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "TestBasicConnections",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:\n            warnings.warn(\"Skipping test_remote_connection\")",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestThreadedConnection",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestThreadedConnection(unittest.TestCase):\n    def test_initialised_thread(self):\n        \"\"\"A WMI connection in a thread which has been initialised for COM\n        should succeed.\n        \"\"\"\n        def f(q):\n            pythoncom.CoInitialize()\n            try:\n                try:\n                    wmi.WMI()",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMoniker",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestMoniker(unittest.TestCase):\n    def test_moniker(self):\n        \"\"\"Look at all possible options for moniker construction and pass\n        them through to a WMI connector\n        \"\"\"\n        for computer in COMPUTERS:\n            if computer in (None, \".\"):\n                local_authorities = [None]\n            else:\n                local_authorities = AUTHORITIES",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestFunctions",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestFunctions(unittest.TestCase):\n    times = [\n       ((2000, 1, 1), \"20000101******.******+***\"),\n       ((2000, 1, 1, 10, 0, 0), \"20000101100000.******+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100), \"20000101100000.000100+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100, \"GMT\"), \"20000101100000.000100+GMT\")\n    ]\n    def test_signed_to_unsigned(self):\n        tests = [\n           (0, 0),",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWMI",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestWMI(unittest.TestCase):\n    def setUp(self):\n        self.connection = wmi.WMI(namespace=\"root/cimv2\", find_classes=False)\n        self.logical_disks = set(self.connection.Win32_LogicalDisk())\nclass TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestNamespace",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):\n        self.assert_(set([\"Win32_LogicalDisk\", \"Win32_MappedLogicalDisk\"]) <= set(self.connection.subclasses_of(\"CIM_LogicalDevice\", \"Win32_.*Disk\")))\n    def test_instances(self):\n        self.assertEquals(self.logical_disks, set(self.connection.instances(\"Win32_LogicalDisk\")))\n    def test_new(self):",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestClass",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestClass(TestWMI):\n    def test_class_from_namespace(self):\n        self.assert_(self.connection.Win32_ComputerSystem._namespace is self.connection)\n    def test_class_without_namespace(self):\n        wmi_class = wmi.GetObject(\"winmgmts:Win32_ComputerSystem\")\n        self.assert_(wmi._wmi_class(None, wmi_class)._namespace)\n    def test_query(self):\n        self.assertEquals(\n            set(self.connection.Win32_ComputerSystem.query()),\n            set(self.connection.query(\"SELECT * FROM Win32_ComputerSystem\"))",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWatcher",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestWatcher(TestWMI):\n    def new_letter(self):\n        return \\\n            set(\"%s:\" % chr(i) for i in range(ord('A'), 1 + ord('Z'))).\\\n            difference(d.DeviceID for d in self.connection.Win32_LogicalDisk()).\\\n            pop()\n    @staticmethod\n    def create(new_letter):\n        #~ print(\"about to create drive with letter\", new_letter)\n        here = os.path.dirname(os.path.abspath(__file__))",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMethods",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestMethods(TestWMI):\n    def test_exists(self):\n        \"Check that a well-known method is available by attribute\"\n        self.assert_(self.connection.Win32_Process.Create)\n    def test_params(self):\n        \"Check that the names and arrayness of params are picked up when not arrays\"\n        self.assertEquals(\n            [(n, False) for n in [\"CommandLine\", \"CurrentDirectory\", \"ProcessStartupInformation\"]],\n            self.connection.Win32_Process.Create.in_parameter_names\n        )",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestProperties",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestProperties(TestWMI):\n    def test_access(self):\n        \"Check that all properties are available as attributes\"\n        for d in self.logical_disks:\n            break\n        for p in d.ole_object.Properties_:\n            self.assertEqual(p.Value, getattr(d, p.Name))\n    def test_attribute_passthrough(self):\n        \"Check that unknown attributes are passed through to the underlying object\"\n        for d in self.logical_disks:",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstances",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestInstances(TestWMI):\n    def test_hashable(self):\n        \"Ensure instances are hashable so can be used in a set/dict\"\n        self.assert_(dict.fromkeys(self.logical_disks))\n    def test_equalable(self):\n        \"Ensure instances compare equal\"\n        self.assertEqual(self.logical_disks, self.logical_disks)\n    def test_not_equal_to_anything_else(self):\n        \"Ensure WMI instances are not equal to non-WMI instances\"\n        for d in self.logical_disks:",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstanceCreation",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestInstanceCreation(TestWMI):\n    def test_create_instance(self):\n        self.assert_(isinstance(self.connection.Win32_ProcessStartup.new(ShowWindow=2), wmi._wmi_object))\nclass TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestAssociations",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #\n        for q in self.connection.Win32_DiskQuota():\n            for p in q.properties:\n                try:",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "ini",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "ini = ConfigParser.SafeConfigParser()\nini.read([\"wmitest.master.ini\", \"wmitest.ini\"])\nsettings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "settings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "excludes",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "excludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "COMPUTERS",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "COMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "IMPERSONATION_LEVELS",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "IMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHENTICATION_LEVELS",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "AUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHORITIES",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "AUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "PRIVILEGES",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "PRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "NAMESPACES",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "NAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "link",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "start_doc",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"\n    <html>\n    <head>\n    <title>%(title)s</title>\n    <style>\n    body {font-family : Verdana, sans-serif; font-size : 84%%; margin : 3em;}\n    table.items {padding-left : 30px;}\n    li, td {font-family : \"Courier New\", monospace;}",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "finish_doc",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def finish_doc():\n    doc.append(\"\"\"\n    </body>\n    </html>\n    \"\"\" % locals())\ndef doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_table",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")\n        for n_col in range(n_cols):\n            item = items[n_cols * n_col + n_row]\n            if callback:\n                item = callback(item)\n            doc.append(\"<td><li>%s</li></td>\" % item)",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_breadcrumbs",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def doc_breadcrumbs(computer, namespace, wmi_class=None):\n    doc.append('<p class=\"breadcrumbs\">')\n    doc.append('%s &rarr; %s' % (link(computer, computer), link(namespace, computer, namespace)))\n    if wmi_class:\n        doc.append(' &rarr; %s' % (link(wmi_class, computer, namespace, wmi_class)))\n    doc.append('</p>')\ndef doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_wmi_class",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())\n    klass = getattr(wmi_connection, wmi_class)\n    def property_callback(property_name):\n        property = klass.wmi_property(property_name)\n        mapping = property.qualifiers.get(\"MappingStrings\")\n        if mapping is None:\n            return property_name",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_namespace",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def doc_namespace(computer, namespace, wmi_connection):\n    start_doc(\"WMI: Namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace)\n    namespaces = namespace.split(\"\\\\\")\n    namespace_links = []\n    for i, n in enumerate(namespaces):\n        namespace_links.append(link(n, computer, \"\\\\\".join(namespaces[:i+1])))\n    doc.append(\"<h2>%s</h2>\" % \"\\\\\".join(namespace_links))\n    doc.append(\"<hr>\")\n    subnamespaces = sorted(wmi_connection.__NAMESPACE())",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_namespace",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def handle_namespace(environ, computer, namespace):\n    if not namespace:\n        wmi_connection = wmi.WMI(computer, namespace=\"root/cimv2\")\n        for setting in wmi_connection.Win32_WMISetting():\n            namespace=setting.ASPScriptDefaultNamespace\n            break\n    wmi_connection = wmi.WMI(computer, namespace=namespace, find_classes=True)\n    wmi_class = shift_path_info(environ)\n    if wmi_class:\n        doc_wmi_class(computer, namespace, wmi_class, wmi_connection)",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_computer",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def handle_computer(environ, computer):\n    handle_namespace(environ, computer, shift_path_info(environ))\ndef app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)\n        return(unicode(d).encode(\"utf8\") + unicode(\"\\n\").encode(\"utf8\") for d in doc)\n    else:",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "run_browser",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:\n        print(\"Shutting down gracefully...\")",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc",
        "kind": 5,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "doc = []\ndef link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "PORT = 8010\ndef run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "open_calculator",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_calculator():\n    \"\"\"Открыть калькулятор\"\"\"\n    os.system(\"calc\")\n    return \"Калькулятор открыт\"\ndef calculate_expression(expression):\n    \"\"\"\n    Вычисляет выражение с помощью калькулятора Windows\n    Args:\n        expression: Математическое выражение для вычисления\n    Returns:",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "calculate_expression",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def calculate_expression(expression):\n    \"\"\"\n    Вычисляет выражение с помощью калькулятора Windows\n    Args:\n        expression: Математическое выражение для вычисления\n    Returns:\n        Строка с результатом вычисления\n    \"\"\"\n    # Открываем калькулятор\n    os.system(\"calc\")",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_notepad",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_notepad():\n    \"\"\"Открыть блокнот\"\"\"\n    os.system(\"notepad\")\n    return \"Блокнот открыт\"\ndef open_explorer(path=None):\n    \"\"\"Открыть проводник\"\"\"\n    if path:\n        os.system(f'explorer \"{path}\"')\n    else:\n        os.system(\"explorer\")",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_explorer",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_explorer(path=None):\n    \"\"\"Открыть проводник\"\"\"\n    if path:\n        os.system(f'explorer \"{path}\"')\n    else:\n        os.system(\"explorer\")\n    return \"Проводник открыт\"\ndef open_control_panel():\n    \"\"\"Открыть панель управления\"\"\"\n    os.system(\"control\")",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_control_panel",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_control_panel():\n    \"\"\"Открыть панель управления\"\"\"\n    os.system(\"control\")\n    return \"Панель управления открыта\"\ndef open_settings():\n    \"\"\"Открыть настройки Windows\"\"\"\n    os.system(\"start ms-settings:\")\n    return \"Настройки Windows открыты\"\ndef open_task_manager():\n    \"\"\"Открыть диспетчер задач\"\"\"",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_settings",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_settings():\n    \"\"\"Открыть настройки Windows\"\"\"\n    os.system(\"start ms-settings:\")\n    return \"Настройки Windows открыты\"\ndef open_task_manager():\n    \"\"\"Открыть диспетчер задач\"\"\"\n    os.system(\"taskmgr\")\n    return \"Диспетчер задач открыт\"\ndef open_command_prompt(admin=False):\n    \"\"\"Открыть командную строку\"\"\"",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_task_manager",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_task_manager():\n    \"\"\"Открыть диспетчер задач\"\"\"\n    os.system(\"taskmgr\")\n    return \"Диспетчер задач открыт\"\ndef open_command_prompt(admin=False):\n    \"\"\"Открыть командную строку\"\"\"\n    if admin:\n        os.system(\"powershell Start-Process cmd -Verb RunAs\")\n    else:\n        os.system(\"start cmd\")",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_command_prompt",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_command_prompt(admin=False):\n    \"\"\"Открыть командную строку\"\"\"\n    if admin:\n        os.system(\"powershell Start-Process cmd -Verb RunAs\")\n    else:\n        os.system(\"start cmd\")\n    return \"Командная строка открыта\"\ndef open_powershell(admin=False):\n    \"\"\"Открыть PowerShell\"\"\"\n    if admin:",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_powershell",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_powershell(admin=False):\n    \"\"\"Открыть PowerShell\"\"\"\n    if admin:\n        os.system(\"powershell Start-Process powershell -Verb RunAs\")\n    else:\n        os.system(\"start powershell\")\n    return \"PowerShell открыт\"\n# Функции калькулятора\ndef convert_units(value, from_unit, to_unit):\n    \"\"\"Конвертировать величину из одних единиц в другие\"\"\"",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "convert_units",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def convert_units(value, from_unit, to_unit):\n    \"\"\"Конвертировать величину из одних единиц в другие\"\"\"\n    # Реализация конвертации единиц (упрощенно)\n    return f\"Конвертация {value} из {from_unit} в {to_unit}\"\ndef calculate_date_difference(date1, date2):\n    \"\"\"Вычислить разницу между двумя датами\"\"\"\n    # Реализация расчета разницы дат\n    return f\"Разница между {date1} и {date2}\"\n# Сторонние приложения\ndef open_word(file_path=None):",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "calculate_date_difference",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def calculate_date_difference(date1, date2):\n    \"\"\"Вычислить разницу между двумя датами\"\"\"\n    # Реализация расчета разницы дат\n    return f\"Разница между {date1} и {date2}\"\n# Сторонние приложения\ndef open_word(file_path=None):\n    \"\"\"Открыть Microsoft Word\"\"\"\n    if file_path:\n        os.system(f'start winword.exe \"{file_path}\"')\n    else:",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_word",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_word(file_path=None):\n    \"\"\"Открыть Microsoft Word\"\"\"\n    if file_path:\n        os.system(f'start winword.exe \"{file_path}\"')\n    else:\n        os.system(\"start winword.exe\")\n    return \"Microsoft Word открыт\"\ndef open_excel(file_path=None):\n    \"\"\"Открыть Microsoft Excel\"\"\"\n    if file_path:",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_excel",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_excel(file_path=None):\n    \"\"\"Открыть Microsoft Excel\"\"\"\n    if file_path:\n        os.system(f'start excel.exe \"{file_path}\"')\n    else:\n        os.system(\"start excel.exe\")\n    return \"Microsoft Excel открыт\"\ndef open_vlc(file_path=None):\n    \"\"\"Открыть VLC Media Player\"\"\"\n    if file_path:",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_vlc",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_vlc(file_path=None):\n    \"\"\"Открыть VLC Media Player\"\"\"\n    if file_path:\n        os.system(f'start vlc.exe \"{file_path}\"')\n    else:\n        os.system(\"start vlc.exe\")\n    return \"VLC Media Player открыт\"\ndef open_custom_application(path, args=None):\n    \"\"\"Открыть произвольное приложение по пути\"\"\"\n    if args:",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "open_custom_application",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def open_custom_application(path, args=None):\n    \"\"\"Открыть произвольное приложение по пути\"\"\"\n    if args:\n        os.system(f'start \"\" \"{path}\" {args}')\n    else:\n        os.system(f'start \"\" \"{path}\"')\n    return f\"Приложение {path} открыто\"\ndef get_commands():\n    \"\"\"\n    Возвращает словарь команд модуля",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "get_commands",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def get_commands():\n    \"\"\"\n    Возвращает словарь команд модуля\n    Returns:\n        dict: Словарь с соответствием названий команд функциям\n    \"\"\"\n    return {\n        \"открыть калькулятор\": open_calculator,\n        \"вычислить\": calculate_expression,\n        \"открыть блокнот\": open_notepad,",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "get_aliases",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def get_aliases():\n    \"\"\"\n    Возвращает словарь псевдонимов команд модуля\n    Returns:\n        dict: Словарь с соответствием псевдонимов оригинальным командам\n    \"\"\"\n    return {\n        \"калькулятор\": \"открыть калькулятор\",\n        \"блокнот\": \"открыть блокнот\",\n        \"проводник\": \"открыть проводник\",",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "get_intents",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def get_intents():\n    \"\"\"\n    Возвращает словарь намерений команд модуля\n    Returns:\n        dict: Словарь с группировкой команд по намерениям\n    \"\"\"\n    return {\n        \"приложения\": [\n            \"открыть калькулятор\",\n            \"открыть блокнот\",",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "get_categories",
        "kind": 2,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "def get_categories():\n    \"\"\"\n    Возвращает словарь категорий команд модуля\n    Returns:\n        dict: Словарь с группировкой намерений по категориям\n    \"\"\"\n    return {\"Приложения\": [\"приложения\", \"расчеты\"]}",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.app_commands",
        "description": "commands.app_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\ndef open_calculator():\n    \"\"\"Открыть калькулятор\"\"\"\n    os.system(\"calc\")\n    return \"Калькулятор открыт\"\ndef calculate_expression(expression):\n    \"\"\"\n    Вычисляет выражение с помощью калькулятора Windows\n    Args:\n        expression: Математическое выражение для вычисления",
        "detail": "commands.app_commands",
        "documentation": {}
    },
    {
        "label": "send_email",
        "kind": 2,
        "importPath": "commands.assistant_commands",
        "description": "commands.assistant_commands",
        "peekOfCode": "def send_email(to, subject, body, attachments=None):\n    \"\"\"Отправить электронное письмо\"\"\"\ndef check_email():\n    \"\"\"Проверить электронную почту\"\"\"\ndef open_email_client():\n    \"\"\"Открыть почтовый клиент\"\"\"\n# Мессенджеры\ndef open_messenger(messenger_name):\n    \"\"\"Открыть мессенджер (WhatsApp, Telegram, и т.д.)\"\"\"\n    pyautogui.press(\"win\")",
        "detail": "commands.assistant_commands",
        "documentation": {}
    },
    {
        "label": "check_email",
        "kind": 2,
        "importPath": "commands.assistant_commands",
        "description": "commands.assistant_commands",
        "peekOfCode": "def check_email():\n    \"\"\"Проверить электронную почту\"\"\"\ndef open_email_client():\n    \"\"\"Открыть почтовый клиент\"\"\"\n# Мессенджеры\ndef open_messenger(messenger_name):\n    \"\"\"Открыть мессенджер (WhatsApp, Telegram, и т.д.)\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(messenger_name)\n    pyautogui.press(\"enter\")",
        "detail": "commands.assistant_commands",
        "documentation": {}
    },
    {
        "label": "open_email_client",
        "kind": 2,
        "importPath": "commands.assistant_commands",
        "description": "commands.assistant_commands",
        "peekOfCode": "def open_email_client():\n    \"\"\"Открыть почтовый клиент\"\"\"\n# Мессенджеры\ndef open_messenger(messenger_name):\n    \"\"\"Открыть мессенджер (WhatsApp, Telegram, и т.д.)\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(messenger_name)\n    pyautogui.press(\"enter\")\ndef send_message(messenger, recipient, message):\n    \"\"\"Отправить сообщение через мессенджер\"\"\"",
        "detail": "commands.assistant_commands",
        "documentation": {}
    },
    {
        "label": "open_messenger",
        "kind": 2,
        "importPath": "commands.assistant_commands",
        "description": "commands.assistant_commands",
        "peekOfCode": "def open_messenger(messenger_name):\n    \"\"\"Открыть мессенджер (WhatsApp, Telegram, и т.д.)\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(messenger_name)\n    pyautogui.press(\"enter\")\ndef send_message(messenger, recipient, message):\n    \"\"\"Отправить сообщение через мессенджер\"\"\"\ndef make_voice_call(messenger, recipient):\n    \"\"\"Сделать голосовой вызов\"\"\"\ndef make_video_call(messenger, recipient):",
        "detail": "commands.assistant_commands",
        "documentation": {}
    },
    {
        "label": "send_message",
        "kind": 2,
        "importPath": "commands.assistant_commands",
        "description": "commands.assistant_commands",
        "peekOfCode": "def send_message(messenger, recipient, message):\n    \"\"\"Отправить сообщение через мессенджер\"\"\"\ndef make_voice_call(messenger, recipient):\n    \"\"\"Сделать голосовой вызов\"\"\"\ndef make_video_call(messenger, recipient):\n    \"\"\"Сделать видеозвонок\"\"\"",
        "detail": "commands.assistant_commands",
        "documentation": {}
    },
    {
        "label": "make_voice_call",
        "kind": 2,
        "importPath": "commands.assistant_commands",
        "description": "commands.assistant_commands",
        "peekOfCode": "def make_voice_call(messenger, recipient):\n    \"\"\"Сделать голосовой вызов\"\"\"\ndef make_video_call(messenger, recipient):\n    \"\"\"Сделать видеозвонок\"\"\"",
        "detail": "commands.assistant_commands",
        "documentation": {}
    },
    {
        "label": "make_video_call",
        "kind": 2,
        "importPath": "commands.assistant_commands",
        "description": "commands.assistant_commands",
        "peekOfCode": "def make_video_call(messenger, recipient):\n    \"\"\"Сделать видеозвонок\"\"\"",
        "detail": "commands.assistant_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.assistant_commands",
        "description": "commands.assistant_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n# Электронная почта\ndef send_email(to, subject, body, attachments=None):\n    \"\"\"Отправить электронное письмо\"\"\"\ndef check_email():\n    \"\"\"Проверить электронную почту\"\"\"\ndef open_email_client():\n    \"\"\"Открыть почтовый клиент\"\"\"\n# Мессенджеры\ndef open_messenger(messenger_name):",
        "detail": "commands.assistant_commands",
        "documentation": {}
    },
    {
        "label": "send_email",
        "kind": 2,
        "importPath": "commands.communication_commands",
        "description": "commands.communication_commands",
        "peekOfCode": "def send_email(to, subject, body, attachments=None):\n    \"\"\"Отправить электронное письмо\"\"\"\ndef check_email():\n    \"\"\"Проверить электронную почту\"\"\"\ndef open_email_client():\n    \"\"\"Открыть почтовый клиент\"\"\"\n# Мессенджеры\ndef open_messenger(messenger_name):\n    \"\"\"Открыть мессенджер (WhatsApp, Telegram, и т.д.)\"\"\"\n    pyautogui.press(\"win\")",
        "detail": "commands.communication_commands",
        "documentation": {}
    },
    {
        "label": "check_email",
        "kind": 2,
        "importPath": "commands.communication_commands",
        "description": "commands.communication_commands",
        "peekOfCode": "def check_email():\n    \"\"\"Проверить электронную почту\"\"\"\ndef open_email_client():\n    \"\"\"Открыть почтовый клиент\"\"\"\n# Мессенджеры\ndef open_messenger(messenger_name):\n    \"\"\"Открыть мессенджер (WhatsApp, Telegram, и т.д.)\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(messenger_name)\n    pyautogui.press(\"enter\")",
        "detail": "commands.communication_commands",
        "documentation": {}
    },
    {
        "label": "open_email_client",
        "kind": 2,
        "importPath": "commands.communication_commands",
        "description": "commands.communication_commands",
        "peekOfCode": "def open_email_client():\n    \"\"\"Открыть почтовый клиент\"\"\"\n# Мессенджеры\ndef open_messenger(messenger_name):\n    \"\"\"Открыть мессенджер (WhatsApp, Telegram, и т.д.)\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(messenger_name)\n    pyautogui.press(\"enter\")\ndef send_message(messenger, recipient, message):\n    \"\"\"Отправить сообщение через мессенджер\"\"\"",
        "detail": "commands.communication_commands",
        "documentation": {}
    },
    {
        "label": "open_messenger",
        "kind": 2,
        "importPath": "commands.communication_commands",
        "description": "commands.communication_commands",
        "peekOfCode": "def open_messenger(messenger_name):\n    \"\"\"Открыть мессенджер (WhatsApp, Telegram, и т.д.)\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(messenger_name)\n    pyautogui.press(\"enter\")\ndef send_message(messenger, recipient, message):\n    \"\"\"Отправить сообщение через мессенджер\"\"\"\ndef make_voice_call(messenger, recipient):\n    \"\"\"Сделать голосовой вызов\"\"\"\ndef make_video_call(messenger, recipient):",
        "detail": "commands.communication_commands",
        "documentation": {}
    },
    {
        "label": "send_message",
        "kind": 2,
        "importPath": "commands.communication_commands",
        "description": "commands.communication_commands",
        "peekOfCode": "def send_message(messenger, recipient, message):\n    \"\"\"Отправить сообщение через мессенджер\"\"\"\ndef make_voice_call(messenger, recipient):\n    \"\"\"Сделать голосовой вызов\"\"\"\ndef make_video_call(messenger, recipient):\n    \"\"\"Сделать видеозвонок\"\"\"",
        "detail": "commands.communication_commands",
        "documentation": {}
    },
    {
        "label": "make_voice_call",
        "kind": 2,
        "importPath": "commands.communication_commands",
        "description": "commands.communication_commands",
        "peekOfCode": "def make_voice_call(messenger, recipient):\n    \"\"\"Сделать голосовой вызов\"\"\"\ndef make_video_call(messenger, recipient):\n    \"\"\"Сделать видеозвонок\"\"\"",
        "detail": "commands.communication_commands",
        "documentation": {}
    },
    {
        "label": "make_video_call",
        "kind": 2,
        "importPath": "commands.communication_commands",
        "description": "commands.communication_commands",
        "peekOfCode": "def make_video_call(messenger, recipient):\n    \"\"\"Сделать видеозвонок\"\"\"",
        "detail": "commands.communication_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.communication_commands",
        "description": "commands.communication_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n# Электронная почта\ndef send_email(to, subject, body, attachments=None):\n    \"\"\"Отправить электронное письмо\"\"\"\ndef check_email():\n    \"\"\"Проверить электронную почту\"\"\"\ndef open_email_client():\n    \"\"\"Открыть почтовый клиент\"\"\"\n# Мессенджеры\ndef open_messenger(messenger_name):",
        "detail": "commands.communication_commands",
        "documentation": {}
    },
    {
        "label": "open_vscode",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def open_vscode(path=None):\n    \"\"\"Открыть Visual Studio Code\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(\"code\")\n    pyautogui.press(\"enter\")\ndef open_pycharm(path=None):\n    \"\"\"Открыть PyCharm\"\"\"\ndef open_github_desktop():\n    \"\"\"Открыть GitHub Desktop\"\"\"\ndef open_terminal():",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "open_pycharm",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def open_pycharm(path=None):\n    \"\"\"Открыть PyCharm\"\"\"\ndef open_github_desktop():\n    \"\"\"Открыть GitHub Desktop\"\"\"\ndef open_terminal():\n    \"\"\"Открыть терминал\"\"\"\n# Git и контроль версий\ndef git_clone(repo_url, path=None):\n    \"\"\"Клонировать Git-репозиторий\"\"\"\ndef git_pull():",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "open_github_desktop",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def open_github_desktop():\n    \"\"\"Открыть GitHub Desktop\"\"\"\ndef open_terminal():\n    \"\"\"Открыть терминал\"\"\"\n# Git и контроль версий\ndef git_clone(repo_url, path=None):\n    \"\"\"Клонировать Git-репозиторий\"\"\"\ndef git_pull():\n    \"\"\"Выполнить git pull в текущем репозитории\"\"\"\ndef git_commit(message):",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "open_terminal",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def open_terminal():\n    \"\"\"Открыть терминал\"\"\"\n# Git и контроль версий\ndef git_clone(repo_url, path=None):\n    \"\"\"Клонировать Git-репозиторий\"\"\"\ndef git_pull():\n    \"\"\"Выполнить git pull в текущем репозитории\"\"\"\ndef git_commit(message):\n    \"\"\"Сделать коммит с указанным сообщением\"\"\"\ndef git_push():",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "git_clone",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def git_clone(repo_url, path=None):\n    \"\"\"Клонировать Git-репозиторий\"\"\"\ndef git_pull():\n    \"\"\"Выполнить git pull в текущем репозитории\"\"\"\ndef git_commit(message):\n    \"\"\"Сделать коммит с указанным сообщением\"\"\"\ndef git_push():\n    \"\"\"Отправить изменения на удаленный репозиторий\"\"\"\n# Тестирование и отладка\ndef run_tests(path=None):",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "git_pull",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def git_pull():\n    \"\"\"Выполнить git pull в текущем репозитории\"\"\"\ndef git_commit(message):\n    \"\"\"Сделать коммит с указанным сообщением\"\"\"\ndef git_push():\n    \"\"\"Отправить изменения на удаленный репозиторий\"\"\"\n# Тестирование и отладка\ndef run_tests(path=None):\n    \"\"\"Запустить тесты\"\"\"\ndef run_script(path):",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "git_commit",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def git_commit(message):\n    \"\"\"Сделать коммит с указанным сообщением\"\"\"\ndef git_push():\n    \"\"\"Отправить изменения на удаленный репозиторий\"\"\"\n# Тестирование и отладка\ndef run_tests(path=None):\n    \"\"\"Запустить тесты\"\"\"\ndef run_script(path):\n    \"\"\"Выполнить скрипт\"\"\"\ndef debug_script(path):",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "git_push",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def git_push():\n    \"\"\"Отправить изменения на удаленный репозиторий\"\"\"\n# Тестирование и отладка\ndef run_tests(path=None):\n    \"\"\"Запустить тесты\"\"\"\ndef run_script(path):\n    \"\"\"Выполнить скрипт\"\"\"\ndef debug_script(path):\n    \"\"\"Запустить скрипт в режиме отладки\"\"\"\ndef check_code_quality(path):",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "run_tests",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def run_tests(path=None):\n    \"\"\"Запустить тесты\"\"\"\ndef run_script(path):\n    \"\"\"Выполнить скрипт\"\"\"\ndef debug_script(path):\n    \"\"\"Запустить скрипт в режиме отладки\"\"\"\ndef check_code_quality(path):\n    \"\"\"Проверить качество кода\"\"\"",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "run_script",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def run_script(path):\n    \"\"\"Выполнить скрипт\"\"\"\ndef debug_script(path):\n    \"\"\"Запустить скрипт в режиме отладки\"\"\"\ndef check_code_quality(path):\n    \"\"\"Проверить качество кода\"\"\"",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "debug_script",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def debug_script(path):\n    \"\"\"Запустить скрипт в режиме отладки\"\"\"\ndef check_code_quality(path):\n    \"\"\"Проверить качество кода\"\"\"",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "check_code_quality",
        "kind": 2,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "def check_code_quality(path):\n    \"\"\"Проверить качество кода\"\"\"",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.developer_commands",
        "description": "commands.developer_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n# IDE и инструменты\ndef open_vscode(path=None):\n    \"\"\"Открыть Visual Studio Code\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(\"code\")\n    pyautogui.press(\"enter\")\ndef open_pycharm(path=None):\n    \"\"\"Открыть PyCharm\"\"\"\ndef open_github_desktop():",
        "detail": "commands.developer_commands",
        "documentation": {}
    },
    {
        "label": "create_file",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def create_file(path, content=\"\"):\n    \"\"\"Создать файл с указанным содержимым\"\"\"\n    with open(path, \"w\") as file:\n        file.write(content)\ndef read_file(path):\n    \"\"\"Прочитать содержимое файла\"\"\"\n    with open(path, \"r\") as file:\n        return file.read()\ndef write_file(path, content, append=False):\n    \"\"\"Записать содержимое в файл\"\"\"",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "read_file",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def read_file(path):\n    \"\"\"Прочитать содержимое файла\"\"\"\n    with open(path, \"r\") as file:\n        return file.read()\ndef write_file(path, content, append=False):\n    \"\"\"Записать содержимое в файл\"\"\"\ndef delete_file(path):\n    \"\"\"Удалить файл\"\"\"\n    os.remove(path)\ndef copy_file(source, destination):",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "write_file",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def write_file(path, content, append=False):\n    \"\"\"Записать содержимое в файл\"\"\"\ndef delete_file(path):\n    \"\"\"Удалить файл\"\"\"\n    os.remove(path)\ndef copy_file(source, destination):\n    \"\"\"Скопировать файл\"\"\"\ndef move_file(source, destination):\n    \"\"\"Переместить файл\"\"\"\ndef rename_file(path, new_name):",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "delete_file",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def delete_file(path):\n    \"\"\"Удалить файл\"\"\"\n    os.remove(path)\ndef copy_file(source, destination):\n    \"\"\"Скопировать файл\"\"\"\ndef move_file(source, destination):\n    \"\"\"Переместить файл\"\"\"\ndef rename_file(path, new_name):\n    \"\"\"Переименовать файл\"\"\"\n# Работа с папками",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "copy_file",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def copy_file(source, destination):\n    \"\"\"Скопировать файл\"\"\"\ndef move_file(source, destination):\n    \"\"\"Переместить файл\"\"\"\ndef rename_file(path, new_name):\n    \"\"\"Переименовать файл\"\"\"\n# Работа с папками\ndef create_directory(path):\n    \"\"\"Создать папку\"\"\"\n    os.mkdir(path)",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "move_file",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def move_file(source, destination):\n    \"\"\"Переместить файл\"\"\"\ndef rename_file(path, new_name):\n    \"\"\"Переименовать файл\"\"\"\n# Работа с папками\ndef create_directory(path):\n    \"\"\"Создать папку\"\"\"\n    os.mkdir(path)\ndef delete_directory(path, recursive=False):\n    \"\"\"Удалить папку\"\"\"",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "rename_file",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def rename_file(path, new_name):\n    \"\"\"Переименовать файл\"\"\"\n# Работа с папками\ndef create_directory(path):\n    \"\"\"Создать папку\"\"\"\n    os.mkdir(path)\ndef delete_directory(path, recursive=False):\n    \"\"\"Удалить папку\"\"\"\ndef list_directory(path):\n    \"\"\"Показать содержимое папки\"\"\"",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "create_directory",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def create_directory(path):\n    \"\"\"Создать папку\"\"\"\n    os.mkdir(path)\ndef delete_directory(path, recursive=False):\n    \"\"\"Удалить папку\"\"\"\ndef list_directory(path):\n    \"\"\"Показать содержимое папки\"\"\"\ndef search_files(directory, pattern):\n    \"\"\"Поиск файлов, соответствующих шаблону\"\"\"\ndef get_file_info(path):",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "delete_directory",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def delete_directory(path, recursive=False):\n    \"\"\"Удалить папку\"\"\"\ndef list_directory(path):\n    \"\"\"Показать содержимое папки\"\"\"\ndef search_files(directory, pattern):\n    \"\"\"Поиск файлов, соответствующих шаблону\"\"\"\ndef get_file_info(path):\n    \"\"\"Получить информацию о файле\"\"\"\n    return os.stat(path)",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "list_directory",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def list_directory(path):\n    \"\"\"Показать содержимое папки\"\"\"\ndef search_files(directory, pattern):\n    \"\"\"Поиск файлов, соответствующих шаблону\"\"\"\ndef get_file_info(path):\n    \"\"\"Получить информацию о файле\"\"\"\n    return os.stat(path)",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "search_files",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def search_files(directory, pattern):\n    \"\"\"Поиск файлов, соответствующих шаблону\"\"\"\ndef get_file_info(path):\n    \"\"\"Получить информацию о файле\"\"\"\n    return os.stat(path)",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "get_file_info",
        "kind": 2,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "def get_file_info(path):\n    \"\"\"Получить информацию о файле\"\"\"\n    return os.stat(path)",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.file_commands",
        "description": "commands.file_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n# Основные операции с файлами\ndef create_file(path, content=\"\"):\n    \"\"\"Создать файл с указанным содержимым\"\"\"\n    with open(path, \"w\") as file:\n        file.write(content)\ndef read_file(path):\n    \"\"\"Прочитать содержимое файла\"\"\"\n    with open(path, \"r\") as file:\n        return file.read()",
        "detail": "commands.file_commands",
        "documentation": {}
    },
    {
        "label": "media_pause",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_pause():\n    \"\"\"Пауза/воспроизведение медиа\"\"\"\n    pyautogui.press(\"playpause\")\n    return \"Управление воспроизведением\"\ndef media_next():\n    \"\"\"Следующий трек\"\"\"\n    pyautogui.press(\"nexttrack\")\n    return \"Переключение на следующий трек\"\n# Управление воспроизведением\ndef media_play():",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "media_next",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_next():\n    \"\"\"Следующий трек\"\"\"\n    pyautogui.press(\"nexttrack\")\n    return \"Переключение на следующий трек\"\n# Управление воспроизведением\ndef media_play():\n    \"\"\"Начать воспроизведение медиа\"\"\"\ndef media_stop():\n    \"\"\"Остановить воспроизведение медиа\"\"\"\ndef media_previous():",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "media_play",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_play():\n    \"\"\"Начать воспроизведение медиа\"\"\"\ndef media_stop():\n    \"\"\"Остановить воспроизведение медиа\"\"\"\ndef media_previous():\n    \"\"\"Перейти к предыдущему треку\"\"\"\ndef media_fast_forward(seconds=10):\n    \"\"\"Перемотка вперед\"\"\"\ndef media_rewind(seconds=10):\n    \"\"\"Перемотка назад\"\"\"",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "media_stop",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_stop():\n    \"\"\"Остановить воспроизведение медиа\"\"\"\ndef media_previous():\n    \"\"\"Перейти к предыдущему треку\"\"\"\ndef media_fast_forward(seconds=10):\n    \"\"\"Перемотка вперед\"\"\"\ndef media_rewind(seconds=10):\n    \"\"\"Перемотка назад\"\"\"\n# Управление громкостью медиа\ndef media_volume_up():",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "media_previous",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_previous():\n    \"\"\"Перейти к предыдущему треку\"\"\"\ndef media_fast_forward(seconds=10):\n    \"\"\"Перемотка вперед\"\"\"\ndef media_rewind(seconds=10):\n    \"\"\"Перемотка назад\"\"\"\n# Управление громкостью медиа\ndef media_volume_up():\n    \"\"\"Увеличить громкость медиа\"\"\"\ndef media_volume_down():",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "media_fast_forward",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_fast_forward(seconds=10):\n    \"\"\"Перемотка вперед\"\"\"\ndef media_rewind(seconds=10):\n    \"\"\"Перемотка назад\"\"\"\n# Управление громкостью медиа\ndef media_volume_up():\n    \"\"\"Увеличить громкость медиа\"\"\"\ndef media_volume_down():\n    \"\"\"Уменьшить громкость медиа\"\"\"\ndef media_mute():",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "media_rewind",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_rewind(seconds=10):\n    \"\"\"Перемотка назад\"\"\"\n# Управление громкостью медиа\ndef media_volume_up():\n    \"\"\"Увеличить громкость медиа\"\"\"\ndef media_volume_down():\n    \"\"\"Уменьшить громкость медиа\"\"\"\ndef media_mute():\n    \"\"\"Отключить звук медиа\"\"\"\n# Плейлисты и файлы",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "media_volume_up",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_volume_up():\n    \"\"\"Увеличить громкость медиа\"\"\"\ndef media_volume_down():\n    \"\"\"Уменьшить громкость медиа\"\"\"\ndef media_mute():\n    \"\"\"Отключить звук медиа\"\"\"\n# Плейлисты и файлы\ndef open_media_file(file_path):\n    \"\"\"Открыть медиа-файл в плеере по умолчанию\"\"\"\ndef create_playlist(files, name=None):",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "media_volume_down",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_volume_down():\n    \"\"\"Уменьшить громкость медиа\"\"\"\ndef media_mute():\n    \"\"\"Отключить звук медиа\"\"\"\n# Плейлисты и файлы\ndef open_media_file(file_path):\n    \"\"\"Открыть медиа-файл в плеере по умолчанию\"\"\"\ndef create_playlist(files, name=None):\n    \"\"\"Создать плейлист из файлов\"\"\"\ndef save_playlist(playlist, path):",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "media_mute",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def media_mute():\n    \"\"\"Отключить звук медиа\"\"\"\n# Плейлисты и файлы\ndef open_media_file(file_path):\n    \"\"\"Открыть медиа-файл в плеере по умолчанию\"\"\"\ndef create_playlist(files, name=None):\n    \"\"\"Создать плейлист из файлов\"\"\"\ndef save_playlist(playlist, path):\n    \"\"\"Сохранить плейлист в файл\"\"\"\ndef load_playlist(path):",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "open_media_file",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def open_media_file(file_path):\n    \"\"\"Открыть медиа-файл в плеере по умолчанию\"\"\"\ndef create_playlist(files, name=None):\n    \"\"\"Создать плейлист из файлов\"\"\"\ndef save_playlist(playlist, path):\n    \"\"\"Сохранить плейлист в файл\"\"\"\ndef load_playlist(path):\n    \"\"\"Загрузить плейлист из файла\"\"\"\ndef get_commands():\n    return {",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "create_playlist",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def create_playlist(files, name=None):\n    \"\"\"Создать плейлист из файлов\"\"\"\ndef save_playlist(playlist, path):\n    \"\"\"Сохранить плейлист в файл\"\"\"\ndef load_playlist(path):\n    \"\"\"Загрузить плейлист из файла\"\"\"\ndef get_commands():\n    return {\n        \"начать воспроизведение\": media_play,\n        \"пауза\": media_pause,",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "save_playlist",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def save_playlist(playlist, path):\n    \"\"\"Сохранить плейлист в файл\"\"\"\ndef load_playlist(path):\n    \"\"\"Загрузить плейлист из файла\"\"\"\ndef get_commands():\n    return {\n        \"начать воспроизведение\": media_play,\n        \"пауза\": media_pause,\n        \"стоп\": media_stop,\n        \"следующий трек\": media_next,",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "load_playlist",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def load_playlist(path):\n    \"\"\"Загрузить плейлист из файла\"\"\"\ndef get_commands():\n    return {\n        \"начать воспроизведение\": media_play,\n        \"пауза\": media_pause,\n        \"стоп\": media_stop,\n        \"следующий трек\": media_next,\n        \"предыдущий трек\": media_previous,\n        \"перемотать вперед\": media_fast_forward,",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "get_commands",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def get_commands():\n    return {\n        \"начать воспроизведение\": media_play,\n        \"пауза\": media_pause,\n        \"стоп\": media_stop,\n        \"следующий трек\": media_next,\n        \"предыдущий трек\": media_previous,\n        \"перемотать вперед\": media_fast_forward,\n        \"перемотать назад\": media_rewind,\n        \"увеличить громкость медиа\": media_volume_up,",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "get_aliases",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def get_aliases():\n    return {\n        \"следующая песня\": \"следующий трек\",\n        \"следующая композиция\": \"следующий трек\",\n        \"пауза воспроизведения\": \"пауза\",\n        \"плей\": \"начать воспроизведение\",\n        \"пуск\": \"начать воспроизведение\",\n        \"остановить\": \"стоп\",\n    }\ndef get_intents():",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "get_intents",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def get_intents():\n    return {\n        \"управление_медиа\": [\n            \"начать воспроизведение\",\n            \"пауза\",\n            \"стоп\",\n            \"следующий трек\",\n            \"предыдущий трек\",\n            \"перемотать вперед\",\n            \"перемотать назад\",",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "get_categories",
        "kind": 2,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "def get_categories():\n    return {\"Медиа\": [\"управление_медиа\", \"управление_звуком_медиа\", \"плейлисты\"]}",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.media_commands",
        "description": "commands.media_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\ndef media_pause():\n    \"\"\"Пауза/воспроизведение медиа\"\"\"\n    pyautogui.press(\"playpause\")\n    return \"Управление воспроизведением\"\ndef media_next():\n    \"\"\"Следующий трек\"\"\"\n    pyautogui.press(\"nexttrack\")\n    return \"Переключение на следующий трек\"\n# Управление воспроизведением",
        "detail": "commands.media_commands",
        "documentation": {}
    },
    {
        "label": "switch_to_application",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def switch_to_application(app_name):\n    \"\"\"Переключиться на указанное приложение\"\"\"\n    pyautogui.hotkey(\"alt\", \"tab\")\n    pyautogui.write(app_name)\n    pyautogui.press(\"enter\")\ndef switch_to_next_window():\n    \"\"\"Переключиться на следующее окно (Alt+Tab)\"\"\"\ndef switch_to_previous_window():\n    \"\"\"Переключиться на предыдущее окно (Alt+Shift+Tab)\"\"\"\ndef list_open_windows():",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "switch_to_next_window",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def switch_to_next_window():\n    \"\"\"Переключиться на следующее окно (Alt+Tab)\"\"\"\ndef switch_to_previous_window():\n    \"\"\"Переключиться на предыдущее окно (Alt+Shift+Tab)\"\"\"\ndef list_open_windows():\n    \"\"\"Показать список открытых окон\"\"\"\n# Навигация по рабочим столам\ndef switch_to_desktop(desktop_number):\n    \"\"\"Переключиться на виртуальный рабочий стол\"\"\"\ndef create_virtual_desktop():",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "switch_to_previous_window",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def switch_to_previous_window():\n    \"\"\"Переключиться на предыдущее окно (Alt+Shift+Tab)\"\"\"\ndef list_open_windows():\n    \"\"\"Показать список открытых окон\"\"\"\n# Навигация по рабочим столам\ndef switch_to_desktop(desktop_number):\n    \"\"\"Переключиться на виртуальный рабочий стол\"\"\"\ndef create_virtual_desktop():\n    \"\"\"Создать новый виртуальный рабочий стол\"\"\"\ndef close_virtual_desktop():",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "list_open_windows",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def list_open_windows():\n    \"\"\"Показать список открытых окон\"\"\"\n# Навигация по рабочим столам\ndef switch_to_desktop(desktop_number):\n    \"\"\"Переключиться на виртуальный рабочий стол\"\"\"\ndef create_virtual_desktop():\n    \"\"\"Создать новый виртуальный рабочий стол\"\"\"\ndef close_virtual_desktop():\n    \"\"\"Закрыть текущий виртуальный рабочий стол\"\"\"\n# Навигация по веб-страницам",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "switch_to_desktop",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def switch_to_desktop(desktop_number):\n    \"\"\"Переключиться на виртуальный рабочий стол\"\"\"\ndef create_virtual_desktop():\n    \"\"\"Создать новый виртуальный рабочий стол\"\"\"\ndef close_virtual_desktop():\n    \"\"\"Закрыть текущий виртуальный рабочий стол\"\"\"\n# Навигация по веб-страницам\ndef open_tab(url=None):\n    \"\"\"Открыть новую вкладку в браузере\"\"\"\ndef close_tab():",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "create_virtual_desktop",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def create_virtual_desktop():\n    \"\"\"Создать новый виртуальный рабочий стол\"\"\"\ndef close_virtual_desktop():\n    \"\"\"Закрыть текущий виртуальный рабочий стол\"\"\"\n# Навигация по веб-страницам\ndef open_tab(url=None):\n    \"\"\"Открыть новую вкладку в браузере\"\"\"\ndef close_tab():\n    \"\"\"Закрыть текущую вкладку\"\"\"\ndef switch_to_tab(tab_number):",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "close_virtual_desktop",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def close_virtual_desktop():\n    \"\"\"Закрыть текущий виртуальный рабочий стол\"\"\"\n# Навигация по веб-страницам\ndef open_tab(url=None):\n    \"\"\"Открыть новую вкладку в браузере\"\"\"\ndef close_tab():\n    \"\"\"Закрыть текущую вкладку\"\"\"\ndef switch_to_tab(tab_number):\n    \"\"\"Переключиться на вкладку по номеру\"\"\"\ndef switch_to_next_tab():",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "open_tab",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def open_tab(url=None):\n    \"\"\"Открыть новую вкладку в браузере\"\"\"\ndef close_tab():\n    \"\"\"Закрыть текущую вкладку\"\"\"\ndef switch_to_tab(tab_number):\n    \"\"\"Переключиться на вкладку по номеру\"\"\"\ndef switch_to_next_tab():\n    \"\"\"Переключиться на следующую вкладку\"\"\"\ndef switch_to_previous_tab():\n    \"\"\"Переключиться на предыдущую вкладку\"\"\"",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "close_tab",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def close_tab():\n    \"\"\"Закрыть текущую вкладку\"\"\"\ndef switch_to_tab(tab_number):\n    \"\"\"Переключиться на вкладку по номеру\"\"\"\ndef switch_to_next_tab():\n    \"\"\"Переключиться на следующую вкладку\"\"\"\ndef switch_to_previous_tab():\n    \"\"\"Переключиться на предыдущую вкладку\"\"\"",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "switch_to_tab",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def switch_to_tab(tab_number):\n    \"\"\"Переключиться на вкладку по номеру\"\"\"\ndef switch_to_next_tab():\n    \"\"\"Переключиться на следующую вкладку\"\"\"\ndef switch_to_previous_tab():\n    \"\"\"Переключиться на предыдущую вкладку\"\"\"",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "switch_to_next_tab",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def switch_to_next_tab():\n    \"\"\"Переключиться на следующую вкладку\"\"\"\ndef switch_to_previous_tab():\n    \"\"\"Переключиться на предыдущую вкладку\"\"\"",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "switch_to_previous_tab",
        "kind": 2,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "def switch_to_previous_tab():\n    \"\"\"Переключиться на предыдущую вкладку\"\"\"",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.navigation_commands",
        "description": "commands.navigation_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n# Перемещение по приложениям\ndef switch_to_application(app_name):\n    \"\"\"Переключиться на указанное приложение\"\"\"\n    pyautogui.hotkey(\"alt\", \"tab\")\n    pyautogui.write(app_name)\n    pyautogui.press(\"enter\")\ndef switch_to_next_window():\n    \"\"\"Переключиться на следующее окно (Alt+Tab)\"\"\"\ndef switch_to_previous_window():",
        "detail": "commands.navigation_commands",
        "documentation": {}
    },
    {
        "label": "discover_devices",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def discover_devices():\n    \"\"\"Обнаружить устройства умного дома\"\"\"\ndef list_devices():\n    \"\"\"Вывести список устройств\"\"\"\ndef get_device_status(device_id):\n    \"\"\"Получить статус устройства\"\"\"\n# Освещение\ndef turn_on_light(device_id=None, room=None):\n    \"\"\"Включить свет\"\"\"\ndef turn_off_light(device_id=None, room=None):",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "list_devices",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def list_devices():\n    \"\"\"Вывести список устройств\"\"\"\ndef get_device_status(device_id):\n    \"\"\"Получить статус устройства\"\"\"\n# Освещение\ndef turn_on_light(device_id=None, room=None):\n    \"\"\"Включить свет\"\"\"\ndef turn_off_light(device_id=None, room=None):\n    \"\"\"Выключить свет\"\"\"\ndef set_brightness(device_id, level):",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "get_device_status",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def get_device_status(device_id):\n    \"\"\"Получить статус устройства\"\"\"\n# Освещение\ndef turn_on_light(device_id=None, room=None):\n    \"\"\"Включить свет\"\"\"\ndef turn_off_light(device_id=None, room=None):\n    \"\"\"Выключить свет\"\"\"\ndef set_brightness(device_id, level):\n    \"\"\"Установить яркость света\"\"\"\ndef set_light_color(device_id, color):",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "turn_on_light",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def turn_on_light(device_id=None, room=None):\n    \"\"\"Включить свет\"\"\"\ndef turn_off_light(device_id=None, room=None):\n    \"\"\"Выключить свет\"\"\"\ndef set_brightness(device_id, level):\n    \"\"\"Установить яркость света\"\"\"\ndef set_light_color(device_id, color):\n    \"\"\"Установить цвет света\"\"\"\n# Климат\ndef set_temperature(device_id, temperature):",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "turn_off_light",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def turn_off_light(device_id=None, room=None):\n    \"\"\"Выключить свет\"\"\"\ndef set_brightness(device_id, level):\n    \"\"\"Установить яркость света\"\"\"\ndef set_light_color(device_id, color):\n    \"\"\"Установить цвет света\"\"\"\n# Климат\ndef set_temperature(device_id, temperature):\n    \"\"\"Установить температуру\"\"\"\ndef get_temperature(device_id=None, room=None):",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "set_brightness",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def set_brightness(device_id, level):\n    \"\"\"Установить яркость света\"\"\"\ndef set_light_color(device_id, color):\n    \"\"\"Установить цвет света\"\"\"\n# Климат\ndef set_temperature(device_id, temperature):\n    \"\"\"Установить температуру\"\"\"\ndef get_temperature(device_id=None, room=None):\n    \"\"\"Получить текущую температуру\"\"\"\ndef turn_on_climate_device(device_id, mode=None):",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "set_light_color",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def set_light_color(device_id, color):\n    \"\"\"Установить цвет света\"\"\"\n# Климат\ndef set_temperature(device_id, temperature):\n    \"\"\"Установить температуру\"\"\"\ndef get_temperature(device_id=None, room=None):\n    \"\"\"Получить текущую температуру\"\"\"\ndef turn_on_climate_device(device_id, mode=None):\n    \"\"\"Включить устройство климат-контроля\"\"\"\ndef turn_off_climate_device(device_id):",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "set_temperature",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def set_temperature(device_id, temperature):\n    \"\"\"Установить температуру\"\"\"\ndef get_temperature(device_id=None, room=None):\n    \"\"\"Получить текущую температуру\"\"\"\ndef turn_on_climate_device(device_id, mode=None):\n    \"\"\"Включить устройство климат-контроля\"\"\"\ndef turn_off_climate_device(device_id):\n    \"\"\"Выключить устройство климат-контроля\"\"\"\n# Безопасность\ndef arm_security_system():",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "get_temperature",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def get_temperature(device_id=None, room=None):\n    \"\"\"Получить текущую температуру\"\"\"\ndef turn_on_climate_device(device_id, mode=None):\n    \"\"\"Включить устройство климат-контроля\"\"\"\ndef turn_off_climate_device(device_id):\n    \"\"\"Выключить устройство климат-контроля\"\"\"\n# Безопасность\ndef arm_security_system():\n    \"\"\"Активировать охранную систему\"\"\"\ndef disarm_security_system():",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "turn_on_climate_device",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def turn_on_climate_device(device_id, mode=None):\n    \"\"\"Включить устройство климат-контроля\"\"\"\ndef turn_off_climate_device(device_id):\n    \"\"\"Выключить устройство климат-контроля\"\"\"\n# Безопасность\ndef arm_security_system():\n    \"\"\"Активировать охранную систему\"\"\"\ndef disarm_security_system():\n    \"\"\"Деактивировать охранную систему\"\"\"\ndef get_security_status():",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "turn_off_climate_device",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def turn_off_climate_device(device_id):\n    \"\"\"Выключить устройство климат-контроля\"\"\"\n# Безопасность\ndef arm_security_system():\n    \"\"\"Активировать охранную систему\"\"\"\ndef disarm_security_system():\n    \"\"\"Деактивировать охранную систему\"\"\"\ndef get_security_status():\n    \"\"\"Получить статус охранной системы\"\"\"\ndef check_cameras():",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "arm_security_system",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def arm_security_system():\n    \"\"\"Активировать охранную систему\"\"\"\ndef disarm_security_system():\n    \"\"\"Деактивировать охранную систему\"\"\"\ndef get_security_status():\n    \"\"\"Получить статус охранной системы\"\"\"\ndef check_cameras():\n    \"\"\"Проверить камеры наблюдения\"\"\"",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "disarm_security_system",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def disarm_security_system():\n    \"\"\"Деактивировать охранную систему\"\"\"\ndef get_security_status():\n    \"\"\"Получить статус охранной системы\"\"\"\ndef check_cameras():\n    \"\"\"Проверить камеры наблюдения\"\"\"",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "get_security_status",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def get_security_status():\n    \"\"\"Получить статус охранной системы\"\"\"\ndef check_cameras():\n    \"\"\"Проверить камеры наблюдения\"\"\"",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "check_cameras",
        "kind": 2,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "def check_cameras():\n    \"\"\"Проверить камеры наблюдения\"\"\"",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.smart_home_commands",
        "description": "commands.smart_home_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n# Общие функции\ndef discover_devices():\n    \"\"\"Обнаружить устройства умного дома\"\"\"\ndef list_devices():\n    \"\"\"Вывести список устройств\"\"\"\ndef get_device_status(device_id):\n    \"\"\"Получить статус устройства\"\"\"\n# Освещение\ndef turn_on_light(device_id=None, room=None):",
        "detail": "commands.smart_home_commands",
        "documentation": {}
    },
    {
        "label": "minimize_all_windows",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def minimize_all_windows():\n    \"\"\"Свернуть все окна (Win+D)\"\"\"\n    logger.info(\"Начало выполнения функции minimize_all_windows()\")\n    try:\n        # Метод с использованием PowerShell\n        logger.info(\"Попытка использования PowerShell для сворачивания всех окон\")\n        os.system('powershell -command \"(New-Object -ComObject Shell.Application).MinimizeAll()\"')\n        logger.info(\"Команда PowerShell выполнена\")\n        return \"Все окна свернуты\"\n    except Exception as e:",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "open_browser",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def open_browser():\n    \"\"\"Открыть браузер по умолчанию\"\"\"\n    os.system(\"start https://www.google.com\")\n    return \"Браузер открыт\"\ndef take_screenshot(path=None):\n    \"\"\"Сделать скриншот и сохранить по указанному пути\"\"\"\n    screenshot_path = path or Config.SCREENSHOT_DIR\n    os.makedirs(screenshot_path, exist_ok=True)\n    filename = f\"screenshot_{int(time.time())}.png\"\n    full_path = os.path.join(screenshot_path, filename)",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "take_screenshot",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def take_screenshot(path=None):\n    \"\"\"Сделать скриншот и сохранить по указанному пути\"\"\"\n    screenshot_path = path or Config.SCREENSHOT_DIR\n    os.makedirs(screenshot_path, exist_ok=True)\n    filename = f\"screenshot_{int(time.time())}.png\"\n    full_path = os.path.join(screenshot_path, filename)\n    pyautogui.screenshot(full_path)\n    return f\"Скриншот сохранен: {filename}\"\ndef volume_up(steps=5):\n    \"\"\"Увеличить громкость системы\"\"\"",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "volume_up",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def volume_up(steps=5):\n    \"\"\"Увеличить громкость системы\"\"\"\n    for _ in range(steps):  # Увеличиваем на заданное количество шагов\n        pyautogui.press(\"volumeup\")\n    return \"Громкость увеличена\"\ndef volume_down(steps=5):\n    \"\"\"Уменьшить громкость системы\"\"\"\n    for _ in range(steps):  # Уменьшаем на заданное количество шагов\n        pyautogui.press(\"volumedown\")\n    return \"Громкость уменьшена\"",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "volume_down",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def volume_down(steps=5):\n    \"\"\"Уменьшить громкость системы\"\"\"\n    for _ in range(steps):  # Уменьшаем на заданное количество шагов\n        pyautogui.press(\"volumedown\")\n    return \"Громкость уменьшена\"\ndef set_volume(level):\n    \"\"\"Установить уровень громкости (0-100%)\"\"\"\n    pyautogui.press(\"volumemute\")\n    for _ in range(level):  # Увеличиваем на заданное количество шагов\n        pyautogui.press(\"volumeup\")",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "set_volume",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def set_volume(level):\n    \"\"\"Установить уровень громкости (0-100%)\"\"\"\n    pyautogui.press(\"volumemute\")\n    for _ in range(level):  # Увеличиваем на заданное количество шагов\n        pyautogui.press(\"volumeup\")\ndef open_notepad():\n    \"\"\"Открыть блокнот\"\"\"\n    os.system(\"notepad\")\n    return \"Блокнот открыт\"\ndef speak_text(text):",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "open_notepad",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def open_notepad():\n    \"\"\"Открыть блокнот\"\"\"\n    os.system(\"notepad\")\n    return \"Блокнот открыт\"\ndef speak_text(text):\n    \"\"\"Озвучить текст\"\"\"\n    engine = pyttsx3.init()\n    engine.say(text)\n    engine.runAndWait()\n    return f\"Текст '{text}' озвучен\"",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "speak_text",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def speak_text(text):\n    \"\"\"Озвучить текст\"\"\"\n    engine = pyttsx3.init()\n    engine.say(text)\n    engine.runAndWait()\n    return f\"Текст '{text}' озвучен\"\ndef shutdown_computer(timeout=30):\n    \"\"\"Выключение компьютера с опциональной задержкой\"\"\"\n    os.system(f\"shutdown /s /t {timeout}\")\n    return f\"Компьютер будет выключен через {timeout} секунд\"",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "shutdown_computer",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def shutdown_computer(timeout=30):\n    \"\"\"Выключение компьютера с опциональной задержкой\"\"\"\n    os.system(f\"shutdown /s /t {timeout}\")\n    return f\"Компьютер будет выключен через {timeout} секунд\"\ndef restart_computer(timeout=30):\n    \"\"\"Перезагрузка компьютера с опциональной задержкой\"\"\"\n    os.system(f\"shutdown /r /t {timeout}\")\n    return f\"Компьютер будет перезагружен через {timeout} секунд\"\n# Управление окнами\ndef maximize_window(title=None):",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "restart_computer",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def restart_computer(timeout=30):\n    \"\"\"Перезагрузка компьютера с опциональной задержкой\"\"\"\n    os.system(f\"shutdown /r /t {timeout}\")\n    return f\"Компьютер будет перезагружен через {timeout} секунд\"\n# Управление окнами\ndef maximize_window(title=None):\n    \"\"\"Развернуть окно\"\"\"\ndef restore_window(title=None):\n    \"\"\"Восстановить окно\"\"\"\ndef close_window(title=None):",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "maximize_window",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def maximize_window(title=None):\n    \"\"\"Развернуть окно\"\"\"\ndef restore_window(title=None):\n    \"\"\"Восстановить окно\"\"\"\ndef close_window(title=None):\n    \"\"\"Закрыть активное окно или окно с указанным заголовком\"\"\"\n# Управление системой\ndef sleep_computer():\n    \"\"\"Перевести компьютер в спящий режим\"\"\"\ndef lock_computer():",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "restore_window",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def restore_window(title=None):\n    \"\"\"Восстановить окно\"\"\"\ndef close_window(title=None):\n    \"\"\"Закрыть активное окно или окно с указанным заголовком\"\"\"\n# Управление системой\ndef sleep_computer():\n    \"\"\"Перевести компьютер в спящий режим\"\"\"\ndef lock_computer():\n    \"\"\"Заблокировать компьютер\"\"\"\ndef logout_user():",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "close_window",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def close_window(title=None):\n    \"\"\"Закрыть активное окно или окно с указанным заголовком\"\"\"\n# Управление системой\ndef sleep_computer():\n    \"\"\"Перевести компьютер в спящий режим\"\"\"\ndef lock_computer():\n    \"\"\"Заблокировать компьютер\"\"\"\ndef logout_user():\n    \"\"\"Выйти из системы\"\"\"\ndef mute_sound():",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "sleep_computer",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def sleep_computer():\n    \"\"\"Перевести компьютер в спящий режим\"\"\"\ndef lock_computer():\n    \"\"\"Заблокировать компьютер\"\"\"\ndef logout_user():\n    \"\"\"Выйти из системы\"\"\"\ndef mute_sound():\n    \"\"\"Выключить звук\"\"\"\ndef unmute_sound():\n    \"\"\"Включить звук\"\"\"",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "lock_computer",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def lock_computer():\n    \"\"\"Заблокировать компьютер\"\"\"\ndef logout_user():\n    \"\"\"Выйти из системы\"\"\"\ndef mute_sound():\n    \"\"\"Выключить звук\"\"\"\ndef unmute_sound():\n    \"\"\"Включить звук\"\"\"\n# Скриншоты и запись экрана\ndef start_screen_recording(path=None):",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "logout_user",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def logout_user():\n    \"\"\"Выйти из системы\"\"\"\ndef mute_sound():\n    \"\"\"Выключить звук\"\"\"\ndef unmute_sound():\n    \"\"\"Включить звук\"\"\"\n# Скриншоты и запись экрана\ndef start_screen_recording(path=None):\n    \"\"\"Начать запись экрана\"\"\"\ndef stop_screen_recording():",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "mute_sound",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def mute_sound():\n    \"\"\"Выключить звук\"\"\"\ndef unmute_sound():\n    \"\"\"Включить звук\"\"\"\n# Скриншоты и запись экрана\ndef start_screen_recording(path=None):\n    \"\"\"Начать запись экрана\"\"\"\ndef stop_screen_recording():\n    \"\"\"Остановить запись экрана\"\"\"\n# Буфер обмена",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "unmute_sound",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def unmute_sound():\n    \"\"\"Включить звук\"\"\"\n# Скриншоты и запись экрана\ndef start_screen_recording(path=None):\n    \"\"\"Начать запись экрана\"\"\"\ndef stop_screen_recording():\n    \"\"\"Остановить запись экрана\"\"\"\n# Буфер обмена\ndef copy_to_clipboard(text):\n    \"\"\"Скопировать текст в буфер обмена\"\"\"",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "start_screen_recording",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def start_screen_recording(path=None):\n    \"\"\"Начать запись экрана\"\"\"\ndef stop_screen_recording():\n    \"\"\"Остановить запись экрана\"\"\"\n# Буфер обмена\ndef copy_to_clipboard(text):\n    \"\"\"Скопировать текст в буфер обмена\"\"\"\ndef paste_from_clipboard():\n    \"\"\"Вставить текст из буфера обмена\"\"\"\ndef clear_clipboard():",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "stop_screen_recording",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def stop_screen_recording():\n    \"\"\"Остановить запись экрана\"\"\"\n# Буфер обмена\ndef copy_to_clipboard(text):\n    \"\"\"Скопировать текст в буфер обмена\"\"\"\ndef paste_from_clipboard():\n    \"\"\"Вставить текст из буфера обмена\"\"\"\ndef clear_clipboard():\n    \"\"\"Очистить буфер обмена\"\"\"\ndef show_notification(title, message):",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "copy_to_clipboard",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def copy_to_clipboard(text):\n    \"\"\"Скопировать текст в буфер обмена\"\"\"\ndef paste_from_clipboard():\n    \"\"\"Вставить текст из буфера обмена\"\"\"\ndef clear_clipboard():\n    \"\"\"Очистить буфер обмена\"\"\"\ndef show_notification(title, message):\n    \"\"\"Показать уведомление\"\"\"\n# Система\ndef get_system_info():",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "paste_from_clipboard",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def paste_from_clipboard():\n    \"\"\"Вставить текст из буфера обмена\"\"\"\ndef clear_clipboard():\n    \"\"\"Очистить буфер обмена\"\"\"\ndef show_notification(title, message):\n    \"\"\"Показать уведомление\"\"\"\n# Система\ndef get_system_info():\n    \"\"\"Получить информацию о системе\"\"\"\ndef list_running_processes():",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "clear_clipboard",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def clear_clipboard():\n    \"\"\"Очистить буфер обмена\"\"\"\ndef show_notification(title, message):\n    \"\"\"Показать уведомление\"\"\"\n# Система\ndef get_system_info():\n    \"\"\"Получить информацию о системе\"\"\"\ndef list_running_processes():\n    \"\"\"Показать список запущенных процессов\"\"\"\ndef kill_process(process_name_or_id):",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "show_notification",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def show_notification(title, message):\n    \"\"\"Показать уведомление\"\"\"\n# Система\ndef get_system_info():\n    \"\"\"Получить информацию о системе\"\"\"\ndef list_running_processes():\n    \"\"\"Показать список запущенных процессов\"\"\"\ndef kill_process(process_name_or_id):\n    \"\"\"Завершить процесс по имени или ID\"\"\"\ndef get_commands():",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "get_system_info",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def get_system_info():\n    \"\"\"Получить информацию о системе\"\"\"\ndef list_running_processes():\n    \"\"\"Показать список запущенных процессов\"\"\"\ndef kill_process(process_name_or_id):\n    \"\"\"Завершить процесс по имени или ID\"\"\"\ndef get_commands():\n    return {\n        \"свернуть все окна\": minimize_all_windows,\n        \"развернуть окно\": maximize_window,",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "list_running_processes",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def list_running_processes():\n    \"\"\"Показать список запущенных процессов\"\"\"\ndef kill_process(process_name_or_id):\n    \"\"\"Завершить процесс по имени или ID\"\"\"\ndef get_commands():\n    return {\n        \"свернуть все окна\": minimize_all_windows,\n        \"развернуть окно\": maximize_window,\n        \"закрыть окно\": close_window,\n        \"выключить компьютер\": shutdown_computer,",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "kill_process",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def kill_process(process_name_or_id):\n    \"\"\"Завершить процесс по имени или ID\"\"\"\ndef get_commands():\n    return {\n        \"свернуть все окна\": minimize_all_windows,\n        \"развернуть окно\": maximize_window,\n        \"закрыть окно\": close_window,\n        \"выключить компьютер\": shutdown_computer,\n        \"перезагрузить компьютер\": restart_computer,\n        \"спящий режим\": sleep_computer,",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "get_commands",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def get_commands():\n    return {\n        \"свернуть все окна\": minimize_all_windows,\n        \"развернуть окно\": maximize_window,\n        \"закрыть окно\": close_window,\n        \"выключить компьютер\": shutdown_computer,\n        \"перезагрузить компьютер\": restart_computer,\n        \"спящий режим\": sleep_computer,\n        \"заблокировать компьютер\": lock_computer,\n        \"выйти из системы\": logout_user,",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "get_aliases",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def get_aliases():\n    return {\n        \"скрин\": \"сделать скриншот\",\n        \"снимок экрана\": \"сделать скриншот\",\n        \"скриншот\": \"сделать скриншот\",\n        \"выключить пк\": \"выключить компьютер\",\n        \"перезагрузить пк\": \"перезагрузить компьютер\",\n        \"громче\": \"увеличить громкость\",\n        \"тише\": \"уменьшить громкость\",\n        \"заблокировать\": \"заблокировать компьютер\",",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "get_intents",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def get_intents():\n    return {\n        \"управление_окнами\": [\"свернуть все окна\", \"развернуть окно\", \"закрыть окно\"],\n        \"управление_системой\": [\n            \"выключить компьютер\",\n            \"перезагрузить компьютер\",\n            \"спящий режим\",\n            \"заблокировать компьютер\",\n            \"выйти из системы\",\n        ],",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "get_categories",
        "kind": 2,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "def get_categories():\n    return {\n        \"Система\": [\n            \"управление_окнами\",\n            \"управление_системой\",\n            \"управление_звуком\",\n            \"скриншоты_запись\",\n            \"буфер_обмена\",\n            \"информация_система\",\n        ]",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.system_commands",
        "description": "commands.system_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\ndef minimize_all_windows():\n    \"\"\"Свернуть все окна (Win+D)\"\"\"\n    logger.info(\"Начало выполнения функции minimize_all_windows()\")\n    try:\n        # Метод с использованием PowerShell\n        logger.info(\"Попытка использования PowerShell для сворачивания всех окон\")\n        os.system('powershell -command \"(New-Object -ComObject Shell.Application).MinimizeAll()\"')\n        logger.info(\"Команда PowerShell выполнена\")\n        return \"Все окна свернуты\"",
        "detail": "commands.system_commands",
        "documentation": {}
    },
    {
        "label": "move_mouse",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def move_mouse(x, y):\n    \"\"\"Переместить курсор мыши в указанную позицию\"\"\"\n    pyautogui.moveTo(x, y)\ndef click_mouse(x=None, y=None, button=\"left\"):\n    \"\"\"Кликнуть мышью в текущей или указанной позиции\"\"\"\ndef double_click(x=None, y=None):\n    \"\"\"Двойной клик мышью\"\"\"\ndef right_click(x=None, y=None):\n    \"\"\"Клик правой кнопкой мыши\"\"\"\ndef drag_mouse(start_x, start_y, end_x, end_y):",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "click_mouse",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def click_mouse(x=None, y=None, button=\"left\"):\n    \"\"\"Кликнуть мышью в текущей или указанной позиции\"\"\"\ndef double_click(x=None, y=None):\n    \"\"\"Двойной клик мышью\"\"\"\ndef right_click(x=None, y=None):\n    \"\"\"Клик правой кнопкой мыши\"\"\"\ndef drag_mouse(start_x, start_y, end_x, end_y):\n    \"\"\"Перетащить элемент мышью\"\"\"\ndef scroll_up(clicks=3):\n    \"\"\"Прокрутить колесо мыши вверх\"\"\"",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "double_click",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def double_click(x=None, y=None):\n    \"\"\"Двойной клик мышью\"\"\"\ndef right_click(x=None, y=None):\n    \"\"\"Клик правой кнопкой мыши\"\"\"\ndef drag_mouse(start_x, start_y, end_x, end_y):\n    \"\"\"Перетащить элемент мышью\"\"\"\ndef scroll_up(clicks=3):\n    \"\"\"Прокрутить колесо мыши вверх\"\"\"\ndef scroll_down(clicks=3):\n    \"\"\"Прокрутить колесо мыши вниз\"\"\"",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "right_click",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def right_click(x=None, y=None):\n    \"\"\"Клик правой кнопкой мыши\"\"\"\ndef drag_mouse(start_x, start_y, end_x, end_y):\n    \"\"\"Перетащить элемент мышью\"\"\"\ndef scroll_up(clicks=3):\n    \"\"\"Прокрутить колесо мыши вверх\"\"\"\ndef scroll_down(clicks=3):\n    \"\"\"Прокрутить колесо мыши вниз\"\"\"\n# Управление клавиатурой\ndef type_text(text):",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "drag_mouse",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def drag_mouse(start_x, start_y, end_x, end_y):\n    \"\"\"Перетащить элемент мышью\"\"\"\ndef scroll_up(clicks=3):\n    \"\"\"Прокрутить колесо мыши вверх\"\"\"\ndef scroll_down(clicks=3):\n    \"\"\"Прокрутить колесо мыши вниз\"\"\"\n# Управление клавиатурой\ndef type_text(text):\n    \"\"\"Ввести текст\"\"\"\ndef press_key(key):",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "scroll_up",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def scroll_up(clicks=3):\n    \"\"\"Прокрутить колесо мыши вверх\"\"\"\ndef scroll_down(clicks=3):\n    \"\"\"Прокрутить колесо мыши вниз\"\"\"\n# Управление клавиатурой\ndef type_text(text):\n    \"\"\"Ввести текст\"\"\"\ndef press_key(key):\n    \"\"\"Нажать клавишу\"\"\"\ndef hotkey(*keys):",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "scroll_down",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def scroll_down(clicks=3):\n    \"\"\"Прокрутить колесо мыши вниз\"\"\"\n# Управление клавиатурой\ndef type_text(text):\n    \"\"\"Ввести текст\"\"\"\ndef press_key(key):\n    \"\"\"Нажать клавишу\"\"\"\ndef hotkey(*keys):\n    \"\"\"Нажать комбинацию клавиш\"\"\"\ndef copy():",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "type_text",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def type_text(text):\n    \"\"\"Ввести текст\"\"\"\ndef press_key(key):\n    \"\"\"Нажать клавишу\"\"\"\ndef hotkey(*keys):\n    \"\"\"Нажать комбинацию клавиш\"\"\"\ndef copy():\n    \"\"\"Копировать (Ctrl+C)\"\"\"\ndef cut():\n    \"\"\"Вырезать (Ctrl+X)\"\"\"",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "press_key",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def press_key(key):\n    \"\"\"Нажать клавишу\"\"\"\ndef hotkey(*keys):\n    \"\"\"Нажать комбинацию клавиш\"\"\"\ndef copy():\n    \"\"\"Копировать (Ctrl+C)\"\"\"\ndef cut():\n    \"\"\"Вырезать (Ctrl+X)\"\"\"\ndef paste():\n    \"\"\"Вставить (Ctrl+V)\"\"\"",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "hotkey",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def hotkey(*keys):\n    \"\"\"Нажать комбинацию клавиш\"\"\"\ndef copy():\n    \"\"\"Копировать (Ctrl+C)\"\"\"\ndef cut():\n    \"\"\"Вырезать (Ctrl+X)\"\"\"\ndef paste():\n    \"\"\"Вставить (Ctrl+V)\"\"\"\ndef select_all():\n    \"\"\"Выделить всё (Ctrl+A)\"\"\"",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def copy():\n    \"\"\"Копировать (Ctrl+C)\"\"\"\ndef cut():\n    \"\"\"Вырезать (Ctrl+X)\"\"\"\ndef paste():\n    \"\"\"Вставить (Ctrl+V)\"\"\"\ndef select_all():\n    \"\"\"Выделить всё (Ctrl+A)\"\"\"\n# Элементы интерфейса\ndef find_element_by_image(image_path):",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "cut",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def cut():\n    \"\"\"Вырезать (Ctrl+X)\"\"\"\ndef paste():\n    \"\"\"Вставить (Ctrl+V)\"\"\"\ndef select_all():\n    \"\"\"Выделить всё (Ctrl+A)\"\"\"\n# Элементы интерфейса\ndef find_element_by_image(image_path):\n    \"\"\"Найти элемент по изображению\"\"\"\ndef find_element_by_text(text):",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "paste",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def paste():\n    \"\"\"Вставить (Ctrl+V)\"\"\"\ndef select_all():\n    \"\"\"Выделить всё (Ctrl+A)\"\"\"\n# Элементы интерфейса\ndef find_element_by_image(image_path):\n    \"\"\"Найти элемент по изображению\"\"\"\ndef find_element_by_text(text):\n    \"\"\"Найти элемент по тексту\"\"\"\ndef wait_for_element(image_path, timeout=10):",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "select_all",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def select_all():\n    \"\"\"Выделить всё (Ctrl+A)\"\"\"\n# Элементы интерфейса\ndef find_element_by_image(image_path):\n    \"\"\"Найти элемент по изображению\"\"\"\ndef find_element_by_text(text):\n    \"\"\"Найти элемент по тексту\"\"\"\ndef wait_for_element(image_path, timeout=10):\n    \"\"\"Ожидать появления элемента\"\"\"\ndef interact_with_element(element, action=\"click\"):",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "find_element_by_image",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def find_element_by_image(image_path):\n    \"\"\"Найти элемент по изображению\"\"\"\ndef find_element_by_text(text):\n    \"\"\"Найти элемент по тексту\"\"\"\ndef wait_for_element(image_path, timeout=10):\n    \"\"\"Ожидать появления элемента\"\"\"\ndef interact_with_element(element, action=\"click\"):\n    \"\"\"Взаимодействовать с элементом интерфейса\"\"\"\ndef get_commands():\n    return {",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "find_element_by_text",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def find_element_by_text(text):\n    \"\"\"Найти элемент по тексту\"\"\"\ndef wait_for_element(image_path, timeout=10):\n    \"\"\"Ожидать появления элемента\"\"\"\ndef interact_with_element(element, action=\"click\"):\n    \"\"\"Взаимодействовать с элементом интерфейса\"\"\"\ndef get_commands():\n    return {\n        \"переместить мышь\": move_mouse,\n        \"кликнуть\": click_mouse,",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "wait_for_element",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def wait_for_element(image_path, timeout=10):\n    \"\"\"Ожидать появления элемента\"\"\"\ndef interact_with_element(element, action=\"click\"):\n    \"\"\"Взаимодействовать с элементом интерфейса\"\"\"\ndef get_commands():\n    return {\n        \"переместить мышь\": move_mouse,\n        \"кликнуть\": click_mouse,\n        \"двойной клик\": double_click,\n        \"правый клик\": right_click,",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "interact_with_element",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def interact_with_element(element, action=\"click\"):\n    \"\"\"Взаимодействовать с элементом интерфейса\"\"\"\ndef get_commands():\n    return {\n        \"переместить мышь\": move_mouse,\n        \"кликнуть\": click_mouse,\n        \"двойной клик\": double_click,\n        \"правый клик\": right_click,\n        \"перетащить\": drag_mouse,\n        \"прокрутить вверх\": scroll_up,",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "get_commands",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def get_commands():\n    return {\n        \"переместить мышь\": move_mouse,\n        \"кликнуть\": click_mouse,\n        \"двойной клик\": double_click,\n        \"правый клик\": right_click,\n        \"перетащить\": drag_mouse,\n        \"прокрутить вверх\": scroll_up,\n        \"прокрутить вниз\": scroll_down,\n        \"ввести текст\": type_text,",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "get_aliases",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def get_aliases():\n    return {\n        \"клик\": \"кликнуть\",\n        \"нажать\": \"кликнуть\",\n        \"двойной щелчок\": \"двойной клик\",\n        \"щелкнуть правой кнопкой\": \"правый клик\",\n        \"перетянуть\": \"перетащить\",\n        \"напечатать\": \"ввести текст\",\n    }\ndef get_intents():",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "get_intents",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def get_intents():\n    return {\n        \"управление_мышью\": [\n            \"переместить мышь\",\n            \"кликнуть\",\n            \"двойной клик\",\n            \"правый клик\",\n            \"перетащить\",\n            \"прокрутить вверх\",\n            \"прокрутить вниз\",",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "get_categories",
        "kind": 2,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "def get_categories():\n    return {\"Интерфейс\": [\"управление_мышью\", \"управление_клавиатурой\", \"поиск_элементов\"]}",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.ui_commands",
        "description": "commands.ui_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n# Управление мышью\ndef move_mouse(x, y):\n    \"\"\"Переместить курсор мыши в указанную позицию\"\"\"\n    pyautogui.moveTo(x, y)\ndef click_mouse(x=None, y=None, button=\"left\"):\n    \"\"\"Кликнуть мышью в текущей или указанной позиции\"\"\"\ndef double_click(x=None, y=None):\n    \"\"\"Двойной клик мышью\"\"\"\ndef right_click(x=None, y=None):",
        "detail": "commands.ui_commands",
        "documentation": {}
    },
    {
        "label": "create_reminder",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def create_reminder(text, time):\n    \"\"\"Создать напоминание на указанное время\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(\"reminder\")\n    pyautogui.press(\"enter\")\ndef list_reminders():\n    \"\"\"Показать список напоминаний\"\"\"\ndef delete_reminder(reminder_id):\n    \"\"\"Удалить напоминание\"\"\"\ndef add_task(text, deadline=None, priority=None):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "list_reminders",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def list_reminders():\n    \"\"\"Показать список напоминаний\"\"\"\ndef delete_reminder(reminder_id):\n    \"\"\"Удалить напоминание\"\"\"\ndef add_task(text, deadline=None, priority=None):\n    \"\"\"Добавить задачу в список дел\"\"\"\ndef list_tasks():\n    \"\"\"Показать список задач\"\"\"\ndef mark_task_complete(task_id):\n    \"\"\"Отметить задачу как выполненную\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "delete_reminder",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def delete_reminder(reminder_id):\n    \"\"\"Удалить напоминание\"\"\"\ndef add_task(text, deadline=None, priority=None):\n    \"\"\"Добавить задачу в список дел\"\"\"\ndef list_tasks():\n    \"\"\"Показать список задач\"\"\"\ndef mark_task_complete(task_id):\n    \"\"\"Отметить задачу как выполненную\"\"\"\ndef delete_task(task_id):\n    \"\"\"Удалить задачу\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "add_task",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def add_task(text, deadline=None, priority=None):\n    \"\"\"Добавить задачу в список дел\"\"\"\ndef list_tasks():\n    \"\"\"Показать список задач\"\"\"\ndef mark_task_complete(task_id):\n    \"\"\"Отметить задачу как выполненную\"\"\"\ndef delete_task(task_id):\n    \"\"\"Удалить задачу\"\"\"\n# Календарь и встречи\ndef create_event(title, date, time, description=None, location=None):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "list_tasks",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def list_tasks():\n    \"\"\"Показать список задач\"\"\"\ndef mark_task_complete(task_id):\n    \"\"\"Отметить задачу как выполненную\"\"\"\ndef delete_task(task_id):\n    \"\"\"Удалить задачу\"\"\"\n# Календарь и встречи\ndef create_event(title, date, time, description=None, location=None):\n    \"\"\"Создать событие в календаре\"\"\"\ndef list_events(date=None):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "mark_task_complete",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def mark_task_complete(task_id):\n    \"\"\"Отметить задачу как выполненную\"\"\"\ndef delete_task(task_id):\n    \"\"\"Удалить задачу\"\"\"\n# Календарь и встречи\ndef create_event(title, date, time, description=None, location=None):\n    \"\"\"Создать событие в календаре\"\"\"\ndef list_events(date=None):\n    \"\"\"Показать события на указанную дату или все события\"\"\"\ndef update_event(event_id, **kwargs):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "delete_task",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def delete_task(task_id):\n    \"\"\"Удалить задачу\"\"\"\n# Календарь и встречи\ndef create_event(title, date, time, description=None, location=None):\n    \"\"\"Создать событие в календаре\"\"\"\ndef list_events(date=None):\n    \"\"\"Показать события на указанную дату или все события\"\"\"\ndef update_event(event_id, **kwargs):\n    \"\"\"Обновить данные события\"\"\"\ndef delete_event(event_id):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "create_event",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def create_event(title, date, time, description=None, location=None):\n    \"\"\"Создать событие в календаре\"\"\"\ndef list_events(date=None):\n    \"\"\"Показать события на указанную дату или все события\"\"\"\ndef update_event(event_id, **kwargs):\n    \"\"\"Обновить данные события\"\"\"\ndef delete_event(event_id):\n    \"\"\"Удалить событие\"\"\"\n# Заметки\ndef create_note(title, content):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "list_events",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def list_events(date=None):\n    \"\"\"Показать события на указанную дату или все события\"\"\"\ndef update_event(event_id, **kwargs):\n    \"\"\"Обновить данные события\"\"\"\ndef delete_event(event_id):\n    \"\"\"Удалить событие\"\"\"\n# Заметки\ndef create_note(title, content):\n    \"\"\"Создать новую заметку\"\"\"\ndef list_notes():",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "update_event",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def update_event(event_id, **kwargs):\n    \"\"\"Обновить данные события\"\"\"\ndef delete_event(event_id):\n    \"\"\"Удалить событие\"\"\"\n# Заметки\ndef create_note(title, content):\n    \"\"\"Создать новую заметку\"\"\"\ndef list_notes():\n    \"\"\"Показать список заметок\"\"\"\ndef read_note(note_id):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "delete_event",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def delete_event(event_id):\n    \"\"\"Удалить событие\"\"\"\n# Заметки\ndef create_note(title, content):\n    \"\"\"Создать новую заметку\"\"\"\ndef list_notes():\n    \"\"\"Показать список заметок\"\"\"\ndef read_note(note_id):\n    \"\"\"Прочитать содержимое заметки\"\"\"\ndef update_note(note_id, content):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "create_note",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def create_note(title, content):\n    \"\"\"Создать новую заметку\"\"\"\ndef list_notes():\n    \"\"\"Показать список заметок\"\"\"\ndef read_note(note_id):\n    \"\"\"Прочитать содержимое заметки\"\"\"\ndef update_note(note_id, content):\n    \"\"\"Обновить содержимое заметки\"\"\"\ndef delete_note(note_id):\n    \"\"\"Удалить заметку\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "list_notes",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def list_notes():\n    \"\"\"Показать список заметок\"\"\"\ndef read_note(note_id):\n    \"\"\"Прочитать содержимое заметки\"\"\"\ndef update_note(note_id, content):\n    \"\"\"Обновить содержимое заметки\"\"\"\ndef delete_note(note_id):\n    \"\"\"Удалить заметку\"\"\"\n# Веб-функции\ndef search_web(query):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "read_note",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def read_note(note_id):\n    \"\"\"Прочитать содержимое заметки\"\"\"\ndef update_note(note_id, content):\n    \"\"\"Обновить содержимое заметки\"\"\"\ndef delete_note(note_id):\n    \"\"\"Удалить заметку\"\"\"\n# Веб-функции\ndef search_web(query):\n    \"\"\"Искать в интернете\"\"\"\n    # Реализация поиска в интернете",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "update_note",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def update_note(note_id, content):\n    \"\"\"Обновить содержимое заметки\"\"\"\ndef delete_note(note_id):\n    \"\"\"Удалить заметку\"\"\"\n# Веб-функции\ndef search_web(query):\n    \"\"\"Искать в интернете\"\"\"\n    # Реализация поиска в интернете\n    pass\ndef navigate_to(url):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "delete_note",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def delete_note(note_id):\n    \"\"\"Удалить заметку\"\"\"\n# Веб-функции\ndef search_web(query):\n    \"\"\"Искать в интернете\"\"\"\n    # Реализация поиска в интернете\n    pass\ndef navigate_to(url):\n    \"\"\"Перейти по адресу URL\"\"\"\n    # Реализация перехода по URL",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "search_web",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def search_web(query):\n    \"\"\"Искать в интернете\"\"\"\n    # Реализация поиска в интернете\n    pass\ndef navigate_to(url):\n    \"\"\"Перейти по адресу URL\"\"\"\n    # Реализация перехода по URL\n    pass\ndef refresh_page():\n    \"\"\"Обновить страницу\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "navigate_to",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def navigate_to(url):\n    \"\"\"Перейти по адресу URL\"\"\"\n    # Реализация перехода по URL\n    pass\ndef refresh_page():\n    \"\"\"Обновить страницу\"\"\"\n    # Реализация обновления страницы\n    pass\ndef go_back():\n    \"\"\"Вернуться на предыдущую страницу\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "refresh_page",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def refresh_page():\n    \"\"\"Обновить страницу\"\"\"\n    # Реализация обновления страницы\n    pass\ndef go_back():\n    \"\"\"Вернуться на предыдущую страницу\"\"\"\n    # Реализация перехода назад\n    pass\ndef go_forward():\n    \"\"\"Перейти на следующую страницу\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "go_back",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def go_back():\n    \"\"\"Вернуться на предыдущую страницу\"\"\"\n    # Реализация перехода назад\n    pass\ndef go_forward():\n    \"\"\"Перейти на следующую страницу\"\"\"\n    # Реализация перехода вперед\n    pass\ndef add_bookmark(title=None, url=None):\n    \"\"\"Добавить текущую страницу в закладки\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "go_forward",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def go_forward():\n    \"\"\"Перейти на следующую страницу\"\"\"\n    # Реализация перехода вперед\n    pass\ndef add_bookmark(title=None, url=None):\n    \"\"\"Добавить текущую страницу в закладки\"\"\"\n    # Реализация добавления закладки\n    pass\ndef open_bookmark(bookmark_name):\n    \"\"\"Открыть закладку\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "add_bookmark",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def add_bookmark(title=None, url=None):\n    \"\"\"Добавить текущую страницу в закладки\"\"\"\n    # Реализация добавления закладки\n    pass\ndef open_bookmark(bookmark_name):\n    \"\"\"Открыть закладку\"\"\"\n    # Реализация открытия закладки\n    pass\ndef show_history():\n    \"\"\"Показать историю браузера\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "open_bookmark",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def open_bookmark(bookmark_name):\n    \"\"\"Открыть закладку\"\"\"\n    # Реализация открытия закладки\n    pass\ndef show_history():\n    \"\"\"Показать историю браузера\"\"\"\n    # Реализация показа истории\n    pass\ndef clear_history():\n    \"\"\"Очистить историю браузера\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "show_history",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def show_history():\n    \"\"\"Показать историю браузера\"\"\"\n    # Реализация показа истории\n    pass\ndef clear_history():\n    \"\"\"Очистить историю браузера\"\"\"\n    # Реализация очистки истории\n    pass\ndef download_file(url, path=None):\n    \"\"\"Скачать файл по URL\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "clear_history",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def clear_history():\n    \"\"\"Очистить историю браузера\"\"\"\n    # Реализация очистки истории\n    pass\ndef download_file(url, path=None):\n    \"\"\"Скачать файл по URL\"\"\"\n    # Реализация скачивания файла\n    pass\ndef check_downloads():\n    \"\"\"Проверить загрузки в браузере\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "download_file",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def download_file(url, path=None):\n    \"\"\"Скачать файл по URL\"\"\"\n    # Реализация скачивания файла\n    pass\ndef check_downloads():\n    \"\"\"Проверить загрузки в браузере\"\"\"\n    # Реализация проверки загрузок\n    pass\ndef open_downloads_folder():\n    \"\"\"Открыть папку загрузок\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "check_downloads",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def check_downloads():\n    \"\"\"Проверить загрузки в браузере\"\"\"\n    # Реализация проверки загрузок\n    pass\ndef open_downloads_folder():\n    \"\"\"Открыть папку загрузок\"\"\"\n    # Реализация открытия папки загрузок\n    pass\ndef open_social_network(network_name):\n    \"\"\"Открыть социальную сеть\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "open_downloads_folder",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def open_downloads_folder():\n    \"\"\"Открыть папку загрузок\"\"\"\n    # Реализация открытия папки загрузок\n    pass\ndef open_social_network(network_name):\n    \"\"\"Открыть социальную сеть\"\"\"\n    # Реализация открытия соцсети\n    pass\ndef post_to_social_network(network_name, message, attachments=None):\n    \"\"\"Опубликовать сообщение в социальной сети\"\"\"",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "open_social_network",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def open_social_network(network_name):\n    \"\"\"Открыть социальную сеть\"\"\"\n    # Реализация открытия соцсети\n    pass\ndef post_to_social_network(network_name, message, attachments=None):\n    \"\"\"Опубликовать сообщение в социальной сети\"\"\"\n    # Реализация публикации в соцсети\n    pass\ndef get_commands():\n    return {",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "post_to_social_network",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def post_to_social_network(network_name, message, attachments=None):\n    \"\"\"Опубликовать сообщение в социальной сети\"\"\"\n    # Реализация публикации в соцсети\n    pass\ndef get_commands():\n    return {\n        \"искать в интернете\": search_web,\n        \"перейти по адресу\": navigate_to,\n        \"обновить страницу\": refresh_page,\n        \"назад\": go_back,",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "get_commands",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def get_commands():\n    return {\n        \"искать в интернете\": search_web,\n        \"перейти по адресу\": navigate_to,\n        \"обновить страницу\": refresh_page,\n        \"назад\": go_back,\n        \"вперед\": go_forward,\n        \"добавить в закладки\": add_bookmark,\n        \"открыть закладку\": open_bookmark,\n        \"показать историю браузера\": show_history,",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "get_aliases",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def get_aliases():\n    return {\n        \"поиск в интернете\": \"искать в интернете\",\n        \"поиск в сети\": \"искать в интернете\",\n        \"открыть сайт\": \"перейти по адресу\",\n        \"обновить сайт\": \"обновить страницу\",\n        \"вернуться\": \"назад\",\n    }\ndef get_intents():\n    return {",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "get_intents",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def get_intents():\n    return {\n        \"навигация_веб\": [\n            \"искать в интернете\",\n            \"перейти по адресу\",\n            \"обновить страницу\",\n            \"назад\",\n            \"вперед\",\n        ],\n        \"закладки_история\": [",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "get_categories",
        "kind": 2,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "def get_categories():\n    return {\"Интернет\": [\"навигация_веб\", \"закладки_история\", \"загрузки\", \"социальные_сети\"]}",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "commands.web_commands",
        "description": "commands.web_commands",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n# Напоминания и задачи\ndef create_reminder(text, time):\n    \"\"\"Создать напоминание на указанное время\"\"\"\n    pyautogui.press(\"win\")\n    pyautogui.write(\"reminder\")\n    pyautogui.press(\"enter\")\ndef list_reminders():\n    \"\"\"Показать список напоминаний\"\"\"\ndef delete_reminder(reminder_id):",
        "detail": "commands.web_commands",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "kind": 6,
        "importPath": "core.common.filesystem.base",
        "description": "core.common.filesystem.base",
        "peekOfCode": "class AbstractFileSystem(ABC):\n    \"\"\"\n    Абстрактный класс для работы с файловой системой.\n    Определяет методы для работы с файлами и директориями.\n    \"\"\"\n    @abstractmethod\n    def list_directory(self, path: str, pattern: str = \"*\", recursive: bool = False) -> List[str]:\n        \"\"\"\n        Получить список файлов в директории.\n        Args:",
        "detail": "core.common.filesystem.base",
        "documentation": {}
    },
    {
        "label": "create_file_system",
        "kind": 2,
        "importPath": "core.common.filesystem.factory",
        "description": "core.common.filesystem.factory",
        "peekOfCode": "def create_file_system(name: str, **kwargs) -> AbstractFileSystem:\n    \"\"\"\n    Создает новый экземпляр файловой системы с указанным именем.\n    Args:\n        name (str): Имя реализации файловой системы\n        **kwargs: Дополнительные параметры для конструктора\n    Returns:\n        AbstractFileSystem: Экземпляр файловой системы\n    Raises:\n        KeyError: Если реализация с указанным именем не зарегистрирована",
        "detail": "core.common.filesystem.factory",
        "documentation": {}
    },
    {
        "label": "get_file_system",
        "kind": 2,
        "importPath": "core.common.filesystem.factory",
        "description": "core.common.filesystem.factory",
        "peekOfCode": "def get_file_system(name: Optional[str] = None) -> AbstractFileSystem:\n    \"\"\"\n    Возвращает экземпляр файловой системы с указанным именем.\n    Если экземпляр уже был создан ранее, возвращает его из кэша.\n    Если имя не указано, определяет текущую операционную систему и возвращает соответствующую реализацию.\n    Args:\n        name (Optional[str]): Имя реализации файловой системы или None для автоопределения\n    Returns:\n        AbstractFileSystem: Экземпляр файловой системы\n    Raises:",
        "detail": "core.common.filesystem.factory",
        "documentation": {}
    },
    {
        "label": "register_file_system_implementation",
        "kind": 2,
        "importPath": "core.common.filesystem.factory",
        "description": "core.common.filesystem.factory",
        "peekOfCode": "def register_file_system_implementation(\n    name: str, implementation: Type[AbstractFileSystem]\n) -> None:\n    \"\"\"\n    Регистрирует реализацию файловой системы.\n    Перенаправляет вызов к функции в registry.py для обратной совместимости.\n    Args:\n        name (str): Имя реализации\n        implementation (Type[AbstractFileSystem]): Класс реализации\n    \"\"\"",
        "detail": "core.common.filesystem.factory",
        "documentation": {}
    },
    {
        "label": "register_file_system",
        "kind": 2,
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "peekOfCode": "def register_file_system(name: str, implementation: Type[AbstractFileSystem]) -> None:\n    \"\"\"\n    Регистрирует реализацию файловой системы в глобальном реестре.\n    Args:\n        name (str): Имя реализации (например, \"windows\", \"linux\", \"mac\")\n        implementation (Type[AbstractFileSystem]): Класс, реализующий AbstractFileSystem\n    \"\"\"\n    global _file_system_implementations\n    _file_system_implementations[name.lower()] = implementation\ndef get_registered_file_systems() -> Dict[str, Type[AbstractFileSystem]]:",
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "get_registered_file_systems",
        "kind": 2,
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "peekOfCode": "def get_registered_file_systems() -> Dict[str, Type[AbstractFileSystem]]:\n    \"\"\"\n    Возвращает словарь всех зарегистрированных реализаций файловой системы.\n    Returns:\n        Dict[str, Type[AbstractFileSystem]]: Словарь с именами и классами реализаций\n    \"\"\"\n    return _file_system_implementations.copy()\ndef get_file_system_implementation(name: str) -> Type[AbstractFileSystem]:\n    \"\"\"\n    Возвращает класс реализации файловой системы по имени.",
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "get_file_system_implementation",
        "kind": 2,
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "peekOfCode": "def get_file_system_implementation(name: str) -> Type[AbstractFileSystem]:\n    \"\"\"\n    Возвращает класс реализации файловой системы по имени.\n    Args:\n        name (str): Имя реализации файловой системы\n    Returns:\n        Type[AbstractFileSystem]: Класс реализации файловой системы\n    Raises:\n        KeyError: Если реализация с указанным именем не зарегистрирована\n    \"\"\"",
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "is_file_system_registered",
        "kind": 2,
        "importPath": "core.common.filesystem.registry",
        "description": "core.common.filesystem.registry",
        "peekOfCode": "def is_file_system_registered(name: str) -> bool:\n    \"\"\"\n    Проверяет, зарегистрирована ли реализация файловой системы с указанным именем.\n    Args:\n        name (str): Имя реализации файловой системы\n    Returns:\n        bool: True, если реализация зарегистрирована, иначе False\n    \"\"\"\n    return name.lower() in _file_system_implementations\n# Автоматическая регистрация доступных реализаций файловой системы",
        "detail": "core.common.filesystem.registry",
        "documentation": {}
    },
    {
        "label": "AbstractKeyboard",
        "kind": 6,
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "peekOfCode": "class AbstractKeyboard(ABC):\n    \"\"\"\n    Абстрактный базовый класс для контроллеров клавиатуры.\n    Определяет интерфейс, который должен быть реализован всеми\n    конкретными контроллерами клавиатуры.\n    \"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"\n        Инициализация контроллера клавиатуры.\n        Args:",
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "AbstractMouse",
        "kind": 6,
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "peekOfCode": "class AbstractMouse(ABC):\n    \"\"\"\n    Абстрактный базовый класс для контроллеров мыши.\n    Определяет интерфейс, который должен быть реализован всеми\n    конкретными контроллерами мыши.\n    \"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"\n        Инициализация контроллера мыши.\n        Args:",
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "InputController",
        "kind": 6,
        "importPath": "core.common.input.base",
        "description": "core.common.input.base",
        "peekOfCode": "class InputController:\n    \"\"\"\n    Комбинированный контроллер ввода, объединяющий функциональность\n    клавиатуры и мыши.\n    \"\"\"\n    def __init__(self, keyboard: AbstractKeyboard, mouse: AbstractMouse):\n        \"\"\"\n        Инициализация контроллера ввода.\n        Args:\n            keyboard: Экземпляр контроллера клавиатуры.",
        "detail": "core.common.input.base",
        "documentation": {}
    },
    {
        "label": "get_keyboard",
        "kind": 2,
        "importPath": "core.common.input.factory",
        "description": "core.common.input.factory",
        "peekOfCode": "def get_keyboard(\n    human_like=True, platform_name=None, new_instance=False\n) -> Optional[AbstractKeyboard]:\n    \"\"\"\n    Возвращает экземпляр контроллера клавиатуры для текущей или указанной платформы.\n    Args:\n        human_like (bool, optional): Признак человекоподобного поведения.\n        platform_name (str, optional): Имя платформы (если None, используется текущая платформа).\n        new_instance (bool, optional): Признак создания нового экземпляра (не использовать кэш).\n    Returns:",
        "detail": "core.common.input.factory",
        "documentation": {}
    },
    {
        "label": "get_mouse",
        "kind": 2,
        "importPath": "core.common.input.factory",
        "description": "core.common.input.factory",
        "peekOfCode": "def get_mouse(human_like=True, platform_name=None, new_instance=False) -> Optional[AbstractMouse]:\n    \"\"\"\n    Возвращает экземпляр контроллера мыши для текущей или указанной платформы.\n    Args:\n        human_like (bool, optional): Признак человекоподобного поведения.\n        platform_name (str, optional): Имя платформы (если None, используется текущая платформа).\n        new_instance (bool, optional): Признак создания нового экземпляра (не использовать кэш).\n    Returns:\n        AbstractMouse: Экземпляр контроллера мыши или None, если не найден.\n    \"\"\"",
        "detail": "core.common.input.factory",
        "documentation": {}
    },
    {
        "label": "get_input_controller",
        "kind": 2,
        "importPath": "core.common.input.factory",
        "description": "core.common.input.factory",
        "peekOfCode": "def get_input_controller(\n    human_like=True, platform_name=None, new_instance=False\n) -> Optional[InputController]:\n    \"\"\"\n    Возвращает комбинированный контроллер ввода для текущей или указанной платформы.\n    Args:\n        human_like (bool, optional): Признак человекоподобного поведения.\n        platform_name (str, optional): Имя платформы (если None, используется текущая платформа).\n        new_instance (bool, optional): Признак создания нового экземпляра (не использовать кэш).\n    Returns:",
        "detail": "core.common.input.factory",
        "documentation": {}
    },
    {
        "label": "register_keyboard",
        "kind": 2,
        "importPath": "core.common.input.factory",
        "description": "core.common.input.factory",
        "peekOfCode": "def register_keyboard(name: str, keyboard_class: Any) -> bool:\n    \"\"\"\n    Регистрирует класс контроллера клавиатуры в реестре.\n    Args:\n        name: Уникальное имя контроллера.\n        keyboard_class: Класс контроллера клавиатуры.\n    Returns:\n        True если регистрация успешна, иначе False.\n    \"\"\"\n    return registry.register_keyboard(name, keyboard_class)",
        "detail": "core.common.input.factory",
        "documentation": {}
    },
    {
        "label": "register_mouse",
        "kind": 2,
        "importPath": "core.common.input.factory",
        "description": "core.common.input.factory",
        "peekOfCode": "def register_mouse(name: str, mouse_class: Any) -> bool:\n    \"\"\"\n    Регистрирует класс контроллера мыши в реестре.\n    Args:\n        name: Уникальное имя контроллера.\n        mouse_class: Класс контроллера мыши.\n    Returns:\n        True если регистрация успешна, иначе False.\n    \"\"\"\n    return registry.register_mouse(name, mouse_class)",
        "detail": "core.common.input.factory",
        "documentation": {}
    },
    {
        "label": "registry",
        "kind": 5,
        "importPath": "core.common.input.factory",
        "description": "core.common.input.factory",
        "peekOfCode": "registry = InputRegistry()\n# Кэш для хранения экземпляров контроллеров\n_keyboard_instances = {}\n_mouse_instances = {}\ndef get_keyboard(\n    human_like=True, platform_name=None, new_instance=False\n) -> Optional[AbstractKeyboard]:\n    \"\"\"\n    Возвращает экземпляр контроллера клавиатуры для текущей или указанной платформы.\n    Args:",
        "detail": "core.common.input.factory",
        "documentation": {}
    },
    {
        "label": "_keyboard_instances",
        "kind": 5,
        "importPath": "core.common.input.factory",
        "description": "core.common.input.factory",
        "peekOfCode": "_keyboard_instances = {}\n_mouse_instances = {}\ndef get_keyboard(\n    human_like=True, platform_name=None, new_instance=False\n) -> Optional[AbstractKeyboard]:\n    \"\"\"\n    Возвращает экземпляр контроллера клавиатуры для текущей или указанной платформы.\n    Args:\n        human_like (bool, optional): Признак человекоподобного поведения.\n        platform_name (str, optional): Имя платформы (если None, используется текущая платформа).",
        "detail": "core.common.input.factory",
        "documentation": {}
    },
    {
        "label": "_mouse_instances",
        "kind": 5,
        "importPath": "core.common.input.factory",
        "description": "core.common.input.factory",
        "peekOfCode": "_mouse_instances = {}\ndef get_keyboard(\n    human_like=True, platform_name=None, new_instance=False\n) -> Optional[AbstractKeyboard]:\n    \"\"\"\n    Возвращает экземпляр контроллера клавиатуры для текущей или указанной платформы.\n    Args:\n        human_like (bool, optional): Признак человекоподобного поведения.\n        platform_name (str, optional): Имя платформы (если None, используется текущая платформа).\n        new_instance (bool, optional): Признак создания нового экземпляра (не использовать кэш).",
        "detail": "core.common.input.factory",
        "documentation": {}
    },
    {
        "label": "InputRegistry",
        "kind": 6,
        "importPath": "core.common.input.registry",
        "description": "core.common.input.registry",
        "peekOfCode": "class InputRegistry:\n    \"\"\"\n    Реестр контроллеров ввода.\n    Хранит информацию о доступных классах контроллеров клавиатуры и мыши.\n    \"\"\"\n    def __new__(cls, auto_register=True):\n        \"\"\"\n        Создает единственный экземпляр класса (синглтон).\n        Args:\n            auto_register (bool): Если True, автоматически регистрирует стандартные контроллеры.",
        "detail": "core.common.input.registry",
        "documentation": {}
    },
    {
        "label": "_instance",
        "kind": 5,
        "importPath": "core.common.input.registry",
        "description": "core.common.input.registry",
        "peekOfCode": "_instance = None\nclass InputRegistry:\n    \"\"\"\n    Реестр контроллеров ввода.\n    Хранит информацию о доступных классах контроллеров клавиатуры и мыши.\n    \"\"\"\n    def __new__(cls, auto_register=True):\n        \"\"\"\n        Создает единственный экземпляр класса (синглтон).\n        Args:",
        "detail": "core.common.input.registry",
        "documentation": {}
    },
    {
        "label": "AbstractProcessManager",
        "kind": 6,
        "importPath": "core.common.process.base",
        "description": "core.common.process.base",
        "peekOfCode": "class AbstractProcessManager(ABC):\n    \"\"\"\n    Абстрактный класс для управления процессами.\n    Определяет интерфейс для платформо-зависимых реализаций.\n    \"\"\"\n    @abstractmethod\n    def start_process(\n        self,\n        executable: str,\n        args: Optional[List[str]] = None,",
        "detail": "core.common.process.base",
        "documentation": {}
    },
    {
        "label": "ProcessManagerFactory",
        "kind": 6,
        "importPath": "core.common.process.factory",
        "description": "core.common.process.factory",
        "peekOfCode": "class ProcessManagerFactory:\n    \"\"\"\n    Фабрика для создания менеджеров процессов.\n    \"\"\"\n    @staticmethod\n    def create_process_manager() -> AbstractProcessManager:\n        \"\"\"\n        Создать менеджер процессов для текущей платформы.\n        Returns:\n            AbstractProcessManager: Менеджер процессов для текущей платформы",
        "detail": "core.common.process.factory",
        "documentation": {}
    },
    {
        "label": "AbstractRegistryManager",
        "kind": 6,
        "importPath": "core.common.registry.base",
        "description": "core.common.registry.base",
        "peekOfCode": "class AbstractRegistryManager(ABC):\n    \"\"\"\n    Абстрактный класс для управления реестром.\n    Определяет интерфейс для платформо-зависимых реализаций.\n    \"\"\"\n    @abstractmethod\n    def read_value(self, root_key: Any, key_path: str, value_name: str) -> Any:\n        \"\"\"\n        Читает значение из реестра.\n        Args:",
        "detail": "core.common.registry.base",
        "documentation": {}
    },
    {
        "label": "ComponentRegistry",
        "kind": 6,
        "importPath": "core.common.registry.component_registry",
        "description": "core.common.registry.component_registry",
        "peekOfCode": "class ComponentRegistry:\n    \"\"\"\n    Реестр компонентов системы.\n    Обеспечивает регистрацию, поиск и управление компонентами.\n    \"\"\"\n    def __init__(self):\n        self._components = {}\n    def register(self, name, component):\n        \"\"\"\n        Регистрирует компонент в реестре.",
        "detail": "core.common.registry.component_registry",
        "documentation": {}
    },
    {
        "label": "RegistryManagerFactory",
        "kind": 6,
        "importPath": "core.common.registry.factory",
        "description": "core.common.registry.factory",
        "peekOfCode": "class RegistryManagerFactory:\n    \"\"\"\n    Фабрика для создания менеджеров реестра.\n    \"\"\"\n    @staticmethod\n    def create_registry_manager() -> AbstractRegistryManager:\n        \"\"\"\n        Создать менеджер реестра для текущей платформы.\n        Returns:\n            AbstractRegistryManager: Менеджер реестра для текущей платформы",
        "detail": "core.common.registry.factory",
        "documentation": {}
    },
    {
        "label": "AbstractSystemInfo",
        "kind": 6,
        "importPath": "core.common.system.base",
        "description": "core.common.system.base",
        "peekOfCode": "class AbstractSystemInfo(ABC):\n    \"\"\"\n    Абстрактный класс для получения системной информации.\n    Определяет интерфейс для платформо-зависимых реализаций.\n    \"\"\"\n    @abstractmethod\n    def get_os_info(self) -> Dict[str, Any]:\n        \"\"\"\n        Получает информацию об операционной системе.\n        Returns:",
        "detail": "core.common.system.base",
        "documentation": {}
    },
    {
        "label": "SystemInfoFactory",
        "kind": 6,
        "importPath": "core.common.system.factory",
        "description": "core.common.system.factory",
        "peekOfCode": "class SystemInfoFactory:\n    \"\"\"\n    Фабрика для создания объектов системной информации.\n    \"\"\"\n    @staticmethod\n    def create_system_info() -> AbstractSystemInfo:\n        \"\"\"\n        Создать объект системной информации для текущей платформы.\n        Returns:\n            AbstractSystemInfo: Объект системной информации для текущей платформы",
        "detail": "core.common.system.factory",
        "documentation": {}
    },
    {
        "label": "AbstractWindowManager",
        "kind": 6,
        "importPath": "core.common.window.base",
        "description": "core.common.window.base",
        "peekOfCode": "class AbstractWindowManager(ABC):\n    \"\"\"\n    Абстрактный класс для управления окнами.\n    Определяет интерфейс для платформо-зависимых реализаций.\n    \"\"\"\n    @abstractmethod\n    def get_all_windows(self) -> List[Any]:\n        \"\"\"\n        Получение списка всех открытых окон.\n        Returns:",
        "detail": "core.common.window.base",
        "documentation": {}
    },
    {
        "label": "WindowManagerFactory",
        "kind": 6,
        "importPath": "core.common.window.factory",
        "description": "core.common.window.factory",
        "peekOfCode": "class WindowManagerFactory:\n    \"\"\"\n    Фабрика для создания менеджеров окон.\n    \"\"\"\n    @staticmethod\n    def create_window_manager(backend: Optional[str] = None) -> AbstractWindowManager:\n        \"\"\"\n        Создать менеджер окон для текущей платформы.\n        Args:\n            backend (Optional[str]): Предпочтительный бэкенд",
        "detail": "core.common.window.factory",
        "documentation": {}
    },
    {
        "label": "ErrorHandler",
        "kind": 6,
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "peekOfCode": "class ErrorHandler:\n    \"\"\"\n    Обработчик ошибок.\n    Предоставляет функции для обработки и логирования ошибок различных типов.\n    \"\"\"\n    def __init__(self, logger_name=\"error_handler\"):\n        \"\"\"\n        Инициализация обработчика ошибок.\n        Args:\n            logger_name (str, optional): Имя логгера",
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "kind": 2,
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "peekOfCode": "def handle_error(exception, context=None, callback=None, log_level=\"error\", module=None):\n    \"\"\"\n    Глобальная функция для обработки ошибок с использованием глобального экземпляра ErrorHandler.\n    Args:\n        exception (Exception): Исключение, вызвавшее ошибку\n        context (str, optional): Контекст, в котором произошла ошибка\n        callback (callable, optional): Функция обратного вызова для обработки ошибки\n        log_level (str, optional): Уровень логирования ('error', 'warning', 'critical')\n        module (str, optional): Имя модуля, в котором произошла ошибка, для группировки логов\n    Returns:",
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_warning",
        "kind": 2,
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "peekOfCode": "def handle_warning(message, context=None, module=None):\n    \"\"\"\n    Глобальная функция для обработки предупреждений с использованием глобального экземпляра ErrorHandler.\n    Args:\n        message (str): Сообщение предупреждения\n        context (str, optional): Контекст, в котором произошло предупреждение\n        module (str, optional): Имя модуля, в котором произошло предупреждение\n    Returns:\n        bool: True, если предупреждение обработано\n    \"\"\"",
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_llm_error",
        "kind": 2,
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "peekOfCode": "def handle_llm_error(message, exception=None, model=None, prompt=None):\n    \"\"\"\n    Глобальная функция для обработки ошибок LLM с использованием глобального экземпляра ErrorHandler.\n    Args:\n        message (str): Сообщение об ошибке\n        exception (Exception, optional): Исключение, вызвавшее ошибку\n        model (str, optional): Модель LLM, вызвавшая ошибку\n        prompt (str, optional): Промпт, вызвавший ошибку\n    Returns:\n        bool: True, если ошибка обработана, False в противном случае",
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_api_error",
        "kind": 2,
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "peekOfCode": "def handle_api_error(exception: Exception, context: str) -> Dict[str, Any]:\n    \"\"\"\n    Глобальная функция для обработки ошибок API с использованием глобального экземпляра ErrorHandler.\n    Args:\n        exception (Exception): Исключение\n        context (str): Контекст, в котором произошла ошибка\n    Returns:\n        Dict[str, Any]: Информация об ошибке\n    \"\"\"\n    return _error_handler.handle_api_error(exception, context)",
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_rate_limit",
        "kind": 2,
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "peekOfCode": "def handle_rate_limit(exception: Exception, context: str) -> Dict[str, Any]:\n    \"\"\"\n    Глобальная функция для обработки ошибок превышения лимита запросов\n    с использованием глобального экземпляра ErrorHandler.\n    Args:\n        exception (Exception): Исключение\n        context (str): Контекст, в котором произошла ошибка\n    Returns:\n        Dict[str, Any]: Информация об ошибке\n    \"\"\"",
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_timeout",
        "kind": 2,
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "peekOfCode": "def handle_timeout(exception: Exception, context: str) -> Dict[str, Any]:\n    \"\"\"\n    Глобальная функция для обработки ошибок таймаута с использованием глобального экземпляра ErrorHandler.\n    Args:\n        exception (Exception): Исключение\n        context (str): Контекст, в котором произошла ошибка\n    Returns:\n        Dict[str, Any]: Информация об ошибке\n    \"\"\"\n    return _error_handler.handle_timeout(exception, context)",
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "get_error_handler",
        "kind": 2,
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "peekOfCode": "def get_error_handler() -> ErrorHandler:\n    \"\"\"\n    Возвращает глобальный экземпляр ErrorHandler.\n    Returns:\n        ErrorHandler: Глобальный экземпляр ErrorHandler\n    \"\"\"\n    return _error_handler",
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "_error_handler",
        "kind": 5,
        "importPath": "core.common.error_handler",
        "description": "core.common.error_handler",
        "peekOfCode": "_error_handler = ErrorHandler()\n# Глобальные функции для обратной совместимости и удобства\ndef handle_error(exception, context=None, callback=None, log_level=\"error\", module=None):\n    \"\"\"\n    Глобальная функция для обработки ошибок с использованием глобального экземпляра ErrorHandler.\n    Args:\n        exception (Exception): Исключение, вызвавшее ошибку\n        context (str, optional): Контекст, в котором произошла ошибка\n        callback (callable, optional): Функция обратного вызова для обработки ошибки\n        log_level (str, optional): Уровень логирования ('error', 'warning', 'critical')",
        "detail": "core.common.error_handler",
        "documentation": {}
    },
    {
        "label": "AbstractFileSystem",
        "kind": 6,
        "importPath": "core.common.file_system",
        "description": "core.common.file_system",
        "peekOfCode": "class AbstractFileSystem:\n    \"\"\"Абстрактный класс для работы с файловой системой\"\"\"\n    # Базовые операции с файлами\n    def list_directory(self, path: str, pattern: str = \"*\", recursive: bool = False) -> List[str]:\n        \"\"\"Получить список файлов в директории\n        Args:\n            path: Путь к директории\n            pattern: Шаблон для фильтрации файлов\n            recursive: Рекурсивный поиск в поддиректориях\n        Returns:",
        "detail": "core.common.file_system",
        "documentation": {}
    },
    {
        "label": "TaskRepository",
        "kind": 6,
        "importPath": "core.db.repository.task_repository",
        "description": "core.db.repository.task_repository",
        "peekOfCode": "class TaskRepository:\n    \"\"\"Класс для работы с задачами в базе данных.\"\"\"\n    def __init__(self, db_session: Session):\n        \"\"\"\n        Инициализирует репозиторий задач.\n        Args:\n            db_session (Session): Сессия SQLAlchemy для работы с БД.\n        \"\"\"\n        self.db = db_session\n    def _user_exists(self, user_id: int) -> bool:",
        "detail": "core.db.repository.task_repository",
        "documentation": {}
    },
    {
        "label": "UserRepository",
        "kind": 6,
        "importPath": "core.db.repository.user_repository",
        "description": "core.db.repository.user_repository",
        "peekOfCode": "class UserRepository:\n    \"\"\"Репозиторий для работы с пользователями.\"\"\"\n    def __init__(self, db_session: Session):\n        self.db = db_session\n    def get_by_username(self, username: str) -> Optional[User]:\n        \"\"\"\n        Получает пользователя по имени пользователя.\n        Args:\n            username: Имя пользователя\n        Returns:",
        "detail": "core.db.repository.user_repository",
        "documentation": {}
    },
    {
        "label": "WorkflowRepository",
        "kind": 6,
        "importPath": "core.db.repository.workflow_repository",
        "description": "core.db.repository.workflow_repository",
        "peekOfCode": "class WorkflowRepository:\n    \"\"\"Класс для работы с рабочими процессами в базе данных.\"\"\"\n    def __init__(self, db_session: Session):\n        \"\"\"\n        Инициализирует репозиторий рабочих процессов.\n        Args:\n            db_session (Session): Сессия SQLAlchemy для работы с БД.\n        \"\"\"\n        self.db = db_session\n    def create(self, user_id: int, name: str, description: Optional[str] = None) -> Workflow:",
        "detail": "core.db.repository.workflow_repository",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 6,
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "peekOfCode": "class Base(DeclarativeBase):\n    pass\ndef get_engine():\n    \"\"\"\n    Возвращает движок SQLAlchemy.\n    Полезно для тестов и инициализации.\n    \"\"\"\n    return engine\ndef get_db():\n    \"\"\"",
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "get_engine",
        "kind": 2,
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "peekOfCode": "def get_engine():\n    \"\"\"\n    Возвращает движок SQLAlchemy.\n    Полезно для тестов и инициализации.\n    \"\"\"\n    return engine\ndef get_db():\n    \"\"\"\n    Генератор для получения сессии базы данных.\n    Используется для внедрения зависимостей в FastAPI.",
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "peekOfCode": "def get_db():\n    \"\"\"\n    Генератор для получения сессии базы данных.\n    Используется для внедрения зависимостей в FastAPI.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "create_tables",
        "kind": 2,
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "peekOfCode": "def create_tables():\n    \"\"\"\n    Создает все таблицы в базе данных.\n    Используется для инициализации схемы.\n    \"\"\"\n    Base.metadata.create_all(bind=engine)\ndef drop_tables():\n    \"\"\"\n    Удаляет все таблицы из базы данных.\n    Используется для очистки в тестах.",
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "drop_tables",
        "kind": 2,
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "peekOfCode": "def drop_tables():\n    \"\"\"\n    Удаляет все таблицы из базы данных.\n    Используется для очистки в тестах.\n    \"\"\"\n    Base.metadata.drop_all(bind=engine)",
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "peekOfCode": "DATABASE_URL = os.environ.get(\"DATABASE_URL\", \"postgresql://postgres:postgres@localhost/neurolink\")\nprint(f\"Using DATABASE_URL: {DATABASE_URL}\")  # Отладочный вывод\n# Создаем движок SQLAlchemy\nengine = create_engine(DATABASE_URL)\n# Создаем фабрику сессий\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nclass Base(DeclarativeBase):\n    pass\ndef get_engine():\n    \"\"\"",
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "peekOfCode": "engine = create_engine(DATABASE_URL)\n# Создаем фабрику сессий\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nclass Base(DeclarativeBase):\n    pass\ndef get_engine():\n    \"\"\"\n    Возвращает движок SQLAlchemy.\n    Полезно для тестов и инициализации.\n    \"\"\"",
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "core.db.connection",
        "description": "core.db.connection",
        "peekOfCode": "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nclass Base(DeclarativeBase):\n    pass\ndef get_engine():\n    \"\"\"\n    Возвращает движок SQLAlchemy.\n    Полезно для тестов и инициализации.\n    \"\"\"\n    return engine\ndef get_db():",
        "detail": "core.db.connection",
        "documentation": {}
    },
    {
        "label": "Pagination",
        "kind": 6,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "class Pagination:\n    \"\"\"Класс для представления результатов с пагинацией\"\"\"\n    def __init__(self, items, page, per_page, total):\n        self.items = items\n        self.page = page\n        self.per_page = per_page\n        self.total = total\n        # Вычисляем количество страниц\n        self.pages = (total + per_page - 1) // per_page if total > 0 else 0\n        # Определяем, есть ли предыдущая/следующая страницы",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_user",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def create_user(db: Session, **kwargs) -> User:\n    \"\"\"Создает нового пользователя в базе данных\"\"\"\n    user = User(**kwargs)\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n    return user\ndef get_user_by_id(db: Session, user_id: int) -> Optional[User]:\n    \"\"\"Получает пользователя по ID\"\"\"\n    return db.query(User).filter(User.id == user_id).first()",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_user_by_id",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_user_by_id(db: Session, user_id: int) -> Optional[User]:\n    \"\"\"Получает пользователя по ID\"\"\"\n    return db.query(User).filter(User.id == user_id).first()\ndef get_user_by_username(db: Session, username: str) -> Optional[User]:\n    \"\"\"Получает пользователя по имени пользователя\"\"\"\n    return db.query(User).filter(User.username == username).first()\ndef get_user_by_email(db: Session, email: str) -> Optional[User]:\n    \"\"\"Получает пользователя по email\"\"\"\n    return db.query(User).filter(User.email == email).first()\ndef update_user(db: Session, user_id: int, **kwargs) -> Optional[User]:",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_user_by_username",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_user_by_username(db: Session, username: str) -> Optional[User]:\n    \"\"\"Получает пользователя по имени пользователя\"\"\"\n    return db.query(User).filter(User.username == username).first()\ndef get_user_by_email(db: Session, email: str) -> Optional[User]:\n    \"\"\"Получает пользователя по email\"\"\"\n    return db.query(User).filter(User.email == email).first()\ndef update_user(db: Session, user_id: int, **kwargs) -> Optional[User]:\n    \"\"\"Обновляет данные пользователя\"\"\"\n    user = get_user_by_id(db, user_id)\n    if not user:",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_user_by_email",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_user_by_email(db: Session, email: str) -> Optional[User]:\n    \"\"\"Получает пользователя по email\"\"\"\n    return db.query(User).filter(User.email == email).first()\ndef update_user(db: Session, user_id: int, **kwargs) -> Optional[User]:\n    \"\"\"Обновляет данные пользователя\"\"\"\n    user = get_user_by_id(db, user_id)\n    if not user:\n        return None\n    for key, value in kwargs.items():\n        setattr(user, key, value)",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "update_user",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def update_user(db: Session, user_id: int, **kwargs) -> Optional[User]:\n    \"\"\"Обновляет данные пользователя\"\"\"\n    user = get_user_by_id(db, user_id)\n    if not user:\n        return None\n    for key, value in kwargs.items():\n        setattr(user, key, value)\n    db.commit()\n    db.refresh(user)\n    return user",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_ai_model",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def create_ai_model(db: Session, **kwargs) -> AIModel:\n    \"\"\"Создает новую модель ИИ в базе данных\"\"\"\n    model = AIModel(**kwargs)\n    db.add(model)\n    db.commit()\n    db.refresh(model)\n    return model\ndef get_ai_model_by_id(db: Session, model_id: int) -> Optional[AIModel]:\n    \"\"\"Получает модель ИИ по ID\"\"\"\n    return db.query(AIModel).filter(AIModel.id == model_id).first()",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_ai_model_by_id",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_ai_model_by_id(db: Session, model_id: int) -> Optional[AIModel]:\n    \"\"\"Получает модель ИИ по ID\"\"\"\n    return db.query(AIModel).filter(AIModel.id == model_id).first()\ndef get_ai_models(db: Session, is_api: Optional[bool] = None) -> List[AIModel]:\n    \"\"\"Получает список моделей ИИ с возможностью фильтрации\"\"\"\n    query = db.query(AIModel)\n    if is_api is not None:\n        query = query.filter(AIModel.is_api == is_api)\n    return query.all()\ndef update_ai_model(db: Session, model_id: int, **kwargs) -> Optional[AIModel]:",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_ai_models",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_ai_models(db: Session, is_api: Optional[bool] = None) -> List[AIModel]:\n    \"\"\"Получает список моделей ИИ с возможностью фильтрации\"\"\"\n    query = db.query(AIModel)\n    if is_api is not None:\n        query = query.filter(AIModel.is_api == is_api)\n    return query.all()\ndef update_ai_model(db: Session, model_id: int, **kwargs) -> Optional[AIModel]:\n    \"\"\"Обновляет данные модели ИИ\"\"\"\n    model = get_ai_model_by_id(db, model_id)\n    if not model:",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "update_ai_model",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def update_ai_model(db: Session, model_id: int, **kwargs) -> Optional[AIModel]:\n    \"\"\"Обновляет данные модели ИИ\"\"\"\n    model = get_ai_model_by_id(db, model_id)\n    if not model:\n        return None\n    for key, value in kwargs.items():\n        setattr(model, key, value)\n    db.commit()\n    db.refresh(model)\n    return model",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_task",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def create_task(db: Session, **kwargs) -> Task:\n    \"\"\"Создает новую задачу в базе данных\"\"\"\n    task = Task(**kwargs)\n    db.add(task)\n    db.commit()\n    db.refresh(task)\n    return task\ndef get_task_by_id(db: Session, task_id: int) -> Optional[Task]:\n    \"\"\"Получает задачу по ID\"\"\"\n    return db.query(Task).filter(Task.id == task_id).first()",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_task_by_id",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_task_by_id(db: Session, task_id: int) -> Optional[Task]:\n    \"\"\"Получает задачу по ID\"\"\"\n    return db.query(Task).filter(Task.id == task_id).first()\ndef get_tasks_by_user(db: Session, user_id: int) -> List[Task]:\n    \"\"\"Получает список задач пользователя\"\"\"\n    return db.query(Task).filter(Task.user_id == user_id).all()\ndef update_task(db: Session, task_id: int, **kwargs) -> Optional[Task]:\n    \"\"\"Обновляет данные задачи\"\"\"\n    task = get_task_by_id(db, task_id)\n    if not task:",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_tasks_by_user",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_tasks_by_user(db: Session, user_id: int) -> List[Task]:\n    \"\"\"Получает список задач пользователя\"\"\"\n    return db.query(Task).filter(Task.user_id == user_id).all()\ndef update_task(db: Session, task_id: int, **kwargs) -> Optional[Task]:\n    \"\"\"Обновляет данные задачи\"\"\"\n    task = get_task_by_id(db, task_id)\n    if not task:\n        return None\n    for key, value in kwargs.items():\n        setattr(task, key, value)",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "update_task",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def update_task(db: Session, task_id: int, **kwargs) -> Optional[Task]:\n    \"\"\"Обновляет данные задачи\"\"\"\n    task = get_task_by_id(db, task_id)\n    if not task:\n        return None\n    for key, value in kwargs.items():\n        setattr(task, key, value)\n    db.commit()\n    db.refresh(task)\n    return task",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "update_task_status",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def update_task_status(db: Session, task_id: int, status: str) -> Optional[Task]:\n    \"\"\"Обновляет статус задачи\"\"\"\n    task = get_task_by_id(db, task_id)\n    if not task:\n        return None\n    # SQLAlchemy позволяет присваивать обычные значения колонкам,\n    # несмотря на проблемы с типизацией\n    task.status = status  # type: ignore\n    # Используем безопасную проверку на None\n    if status == \"completed\" and task.completed_at is None:",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "delete_task",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def delete_task(db: Session, task_id: int) -> bool:\n    \"\"\"Удаляет задачу\"\"\"\n    task = get_task_by_id(db, task_id)\n    if not task:\n        return False\n    db.delete(task)\n    db.commit()\n    return True\n# Функции CRUD для рабочих процессов (Workflow)\ndef create_workflow(db: Session, **kwargs) -> Workflow:",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "create_workflow",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def create_workflow(db: Session, **kwargs) -> Workflow:\n    \"\"\"Создает новый рабочий процесс в базе данных\"\"\"\n    workflow = Workflow(**kwargs)\n    db.add(workflow)\n    db.commit()\n    db.refresh(workflow)\n    return workflow\ndef get_workflow_by_id(db: Session, workflow_id: int) -> Optional[Workflow]:\n    \"\"\"Получает рабочий процесс по ID\"\"\"\n    return db.query(Workflow).filter(Workflow.id == workflow_id).first()",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_workflow_by_id",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_workflow_by_id(db: Session, workflow_id: int) -> Optional[Workflow]:\n    \"\"\"Получает рабочий процесс по ID\"\"\"\n    return db.query(Workflow).filter(Workflow.id == workflow_id).first()\ndef get_workflows_by_user(db: Session, user_id: int) -> List[Workflow]:\n    \"\"\"Получает список рабочих процессов пользователя\"\"\"\n    return db.query(Workflow).filter(Workflow.user_id == user_id).all()\nclass Pagination:\n    \"\"\"Класс для представления результатов с пагинацией\"\"\"\n    def __init__(self, items, page, per_page, total):\n        self.items = items",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_workflows_by_user",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_workflows_by_user(db: Session, user_id: int) -> List[Workflow]:\n    \"\"\"Получает список рабочих процессов пользователя\"\"\"\n    return db.query(Workflow).filter(Workflow.user_id == user_id).all()\nclass Pagination:\n    \"\"\"Класс для представления результатов с пагинацией\"\"\"\n    def __init__(self, items, page, per_page, total):\n        self.items = items\n        self.page = page\n        self.per_page = per_page\n        self.total = total",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "get_tasks_with_pagination",
        "kind": 2,
        "importPath": "core.db.crud",
        "description": "core.db.crud",
        "peekOfCode": "def get_tasks_with_pagination(\n    db: Session,\n    user_id: int,\n    page: int = 1,\n    per_page: int = 10,\n    status: Optional[str] = None,\n    priority: Optional[int] = None,\n    sort_by: Optional[str] = None,\n    sort_order: str = \"asc\",\n    search_query: Optional[str] = None,",
        "detail": "core.db.crud",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "core.db.models",
        "description": "core.db.models",
        "peekOfCode": "class User(Base):\n    \"\"\"Модель пользователя.\"\"\"\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(100), unique=True, index=True, nullable=False)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    salt = Column(String(255))  # Добавляем поле для соли\n    role = Column(String(50), default=\"user\")  # Добавляем поле для роли\n    display_name = Column(String(100))",
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "AIModel",
        "kind": 6,
        "importPath": "core.db.models",
        "description": "core.db.models",
        "peekOfCode": "class AIModel(Base):\n    \"\"\"Модель для AI моделей.\"\"\"\n    __tablename__ = \"ai_models\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False)\n    provider = Column(String(100), nullable=False)\n    is_api = Column(Boolean, default=True)\n    base_url = Column(String(255))\n    api_key_name = Column(String(100))\n    is_active = Column(Boolean, default=True)",
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "core.db.models",
        "description": "core.db.models",
        "peekOfCode": "class Task(Base):\n    \"\"\"Модель задачи.\"\"\"\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    title = Column(String(255), nullable=False)\n    description = Column(Text)\n    status = Column(String(50), default=\"created\")  # created, in_progress, completed\n    priority = Column(Integer, default=1)  # 1 - низкий, 2 - средний, 3 - высокий\n    due_date = Column(DateTime(timezone=True))",
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "TaskExecution",
        "kind": 6,
        "importPath": "core.db.models",
        "description": "core.db.models",
        "peekOfCode": "class TaskExecution(Base):\n    \"\"\"Модель выполнения задачи.\"\"\"\n    __tablename__ = \"task_executions\"\n    id = Column(Integer, primary_key=True, index=True)\n    task_id = Column(Integer, ForeignKey(\"tasks.id\"), nullable=False)\n    model_id = Column(Integer, ForeignKey(\"ai_models.id\"))\n    input_data = Column(Text)\n    output_data = Column(Text)\n    status = Column(String(50))\n    started_at = Column(DateTime(timezone=True), server_default=func.now())",
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "Workflow",
        "kind": 6,
        "importPath": "core.db.models",
        "description": "core.db.models",
        "peekOfCode": "class Workflow(Base):\n    \"\"\"Модель рабочего процесса (workflow).\"\"\"\n    __tablename__ = \"workflows\"\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    name = Column(String(255), nullable=False)\n    description = Column(Text)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())",
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "WorkflowStep",
        "kind": 6,
        "importPath": "core.db.models",
        "description": "core.db.models",
        "peekOfCode": "class WorkflowStep(Base):\n    \"\"\"Модель шага рабочего процесса.\"\"\"\n    __tablename__ = \"workflow_steps\"\n    id = Column(Integer, primary_key=True, index=True)\n    workflow_id = Column(Integer, ForeignKey(\"workflows.id\"), nullable=False)\n    name = Column(String(255), nullable=False)\n    description = Column(Text)\n    order = Column(Integer, nullable=False)\n    configuration = Column(JSON)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())",
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "RoutingRule",
        "kind": 6,
        "importPath": "core.db.models",
        "description": "core.db.models",
        "peekOfCode": "class RoutingRule(Base):\n    \"\"\"Модель правила маршрутизации.\"\"\"\n    __tablename__ = \"routing_rules\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(255), nullable=False)\n    description = Column(Text)\n    rule_type = Column(String(50), nullable=False)\n    pattern = Column(String(255), nullable=False)\n    target_model_id = Column(Integer, ForeignKey(\"ai_models.id\"))\n    priority = Column(Integer, default=0)",
        "detail": "core.db.models",
        "documentation": {}
    },
    {
        "label": "TransactionManager",
        "kind": 6,
        "importPath": "core.db.transaction",
        "description": "core.db.transaction",
        "peekOfCode": "class TransactionManager:\n    \"\"\"\n    Менеджер транзакций для управления операциями базы данных.\n    \"\"\"\n    def __init__(self, db_session: Session):\n        \"\"\"\n        Инициализирует менеджер транзакций.\n        Args:\n            db_session (Session): Сессия SQLAlchemy.\n        \"\"\"",
        "detail": "core.db.transaction",
        "documentation": {}
    },
    {
        "label": "transaction",
        "kind": 2,
        "importPath": "core.db.transaction",
        "description": "core.db.transaction",
        "peekOfCode": "def transaction(db_session: Session) -> Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    Декоратор для выполнения функции внутри транзакции.\n    Args:\n        db_session (Session): Сессия SQLAlchemy.\n    Returns:\n        Callable: Декорированная функция.\n    \"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @wraps(func)",
        "detail": "core.db.transaction",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "core.db.transaction",
        "description": "core.db.transaction",
        "peekOfCode": "T = TypeVar(\"T\")\nclass TransactionManager:\n    \"\"\"\n    Менеджер транзакций для управления операциями базы данных.\n    \"\"\"\n    def __init__(self, db_session: Session):\n        \"\"\"\n        Инициализирует менеджер транзакций.\n        Args:\n            db_session (Session): Сессия SQLAlchemy.",
        "detail": "core.db.transaction",
        "documentation": {}
    },
    {
        "label": "ActionPlanner",
        "kind": 6,
        "importPath": "core.llm.action_planner",
        "description": "core.llm.action_planner",
        "peekOfCode": "class ActionPlanner:\n    \"\"\"\n    Планировщик действий на основе запросов к нейросети.\n    \"\"\"\n    def __init__(self, api_connector, error_handler=None, action_executor=None):\n        \"\"\"\n        Инициализация планировщика действий.\n        Args:\n            api_connector (object): Коннектор API нейросети\n            error_handler (object, optional): Обработчик ошибок",
        "detail": "core.llm.action_planner",
        "documentation": {}
    },
    {
        "label": "LLMApiClient",
        "kind": 6,
        "importPath": "core.llm.api_client",
        "description": "core.llm.api_client",
        "peekOfCode": "class LLMApiClient:\n    \"\"\"\n    Клиент для взаимодействия с API языковой модели.\n    \"\"\"\n    def __init__(self, api_key=None, base_url=None):\n        \"\"\"\n        Инициализация клиента API.\n        Args:\n            api_key (str, optional): Ключ API для аутентификации\n            base_url (str, optional): Базовый URL API",
        "detail": "core.llm.api_client",
        "documentation": {}
    },
    {
        "label": "APIConnector",
        "kind": 6,
        "importPath": "core.llm.api_connector",
        "description": "core.llm.api_connector",
        "peekOfCode": "class APIConnector:\n    \"\"\"\n    Коннектор для взаимодействия с API нейросетей.\n    \"\"\"\n    def __init__(self, api_key: str, base_url: str, error_handler=None):\n        \"\"\"\n        Инициализация коннектора API.\n        Args:\n            api_key (str): API-ключ для аутентификации\n            base_url (str): Базовый URL API",
        "detail": "core.llm.api_connector",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "kind": 2,
        "importPath": "core.llm.error_handler",
        "description": "core.llm.error_handler",
        "peekOfCode": "def handle_error(exception, context=None, callback=None, log_level=\"error\"):\n    \"\"\"\n    Обработка ошибок для LLM модуля.\n    Args:\n        exception: Исключение\n        context: Контекст ошибки\n        callback: Функция обратного вызова\n        log_level: Уровень логирования\n    Returns:\n        bool: True если ошибка обработана",
        "detail": "core.llm.error_handler",
        "documentation": {}
    },
    {
        "label": "handle_llm_error",
        "kind": 2,
        "importPath": "core.llm.error_handler",
        "description": "core.llm.error_handler",
        "peekOfCode": "def handle_llm_error(message, exception=None, model=None, prompt=None):\n    \"\"\"\n    Специализированный обработчик ошибок LLM.\n    Args:\n        message: Сообщение об ошибке\n        exception: Исключение\n        model: Модель LLM\n        prompt: Промпт\n    Returns:\n        bool: True если ошибка обработана",
        "detail": "core.llm.error_handler",
        "documentation": {}
    },
    {
        "label": "PromptProcessor",
        "kind": 6,
        "importPath": "core.llm.prompt_processor",
        "description": "core.llm.prompt_processor",
        "peekOfCode": "class PromptProcessor:\n    \"\"\"\n    Процессор для работы с промптами.\n    \"\"\"\n    def __init__(self, error_handler=None):\n        \"\"\"\n        Инициализация процессора промптов.\n        Args:\n            error_handler (object, optional): Обработчик ошибок\n        \"\"\"",
        "detail": "core.llm.prompt_processor",
        "documentation": {}
    },
    {
        "label": "ResponseParser",
        "kind": 6,
        "importPath": "core.llm.response_parser",
        "description": "core.llm.response_parser",
        "peekOfCode": "class ResponseParser:\n    \"\"\"\n    Парсер для обработки ответов нейросети.\n    \"\"\"\n    def __init__(self, error_handler=None):\n        \"\"\"\n        Инициализация парсера ответов.\n        Args:\n            error_handler (object, optional): Обработчик ошибок\n        \"\"\"",
        "detail": "core.llm.response_parser",
        "documentation": {}
    },
    {
        "label": "LinuxFileSystem",
        "kind": 6,
        "importPath": "core.platform.linux.file_system",
        "description": "core.platform.linux.file_system",
        "peekOfCode": "class LinuxFileSystem(AbstractFileSystem):\n    \"\"\"Реализация файловой системы для Linux\"\"\"\n    def list_directory(self, path):\n        \"\"\"Получить список файлов в директории\"\"\"\n        try:\n            return os.listdir(path)\n        except Exception as e:\n            handle_error(f\"Ошибка при получении списка файлов: {e}\", e)\n            return []\n    def file_exists(self, path):",
        "detail": "core.platform.linux.file_system",
        "documentation": {}
    },
    {
        "label": "MacOSFileSystem",
        "kind": 6,
        "importPath": "core.platform.macos.file_system",
        "description": "core.platform.macos.file_system",
        "peekOfCode": "class MacOSFileSystem(AbstractFileSystem):\n    \"\"\"Реализация файловой системы для MacOS\"\"\"\n    def list_directory(self, path):\n        \"\"\"Получить список файлов в директории\"\"\"\n        try:\n            return os.listdir(path)\n        except Exception as e:\n            handle_error(f\"Ошибка при получении списка файлов: {e}\", e)\n            return []\n    def file_exists(self, path):",
        "detail": "core.platform.macos.file_system",
        "documentation": {}
    },
    {
        "label": "Win32FileSystem",
        "kind": 6,
        "importPath": "core.platform.windows.filesystem.win32_file_system",
        "description": "core.platform.windows.filesystem.win32_file_system",
        "peekOfCode": "class Win32FileSystem(AbstractFileSystem):\n    \"\"\"\n    Реализация работы с файловой системой для Windows.\n    Предоставляет методы для работы с файлами и директориями.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Инициализация файловой системы Windows\"\"\"\n        super().__init__()\n    def file_exists(self, path: str) -> bool:\n        \"\"\"",
        "detail": "core.platform.windows.filesystem.win32_file_system",
        "documentation": {}
    },
    {
        "label": "WindowsKeyboard",
        "kind": 6,
        "importPath": "core.platform.windows.input.keyboard",
        "description": "core.platform.windows.input.keyboard",
        "peekOfCode": "class WindowsKeyboard(AbstractKeyboard):\n    \"\"\"Реализация клавиатуры для операционной системы Windows.\"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"\n        Инициализирует контроллер клавиатуры.\n        Args:\n            human_like (bool): Флаг, указывающий, нужно ли эмулировать человеческое поведение.\n        \"\"\"\n        self.human_like = human_like\n        self.controller = None  # Для тестирования будет заменено моком",
        "detail": "core.platform.windows.input.keyboard",
        "documentation": {}
    },
    {
        "label": "VK_CODES",
        "kind": 5,
        "importPath": "core.platform.windows.input.keyboard",
        "description": "core.platform.windows.input.keyboard",
        "peekOfCode": "VK_CODES = {\n    \"backspace\": 0x08,\n    \"tab\": 0x09,\n    \"enter\": 0x0D,\n    \"shift\": 0x10,\n    \"ctrl\": 0x11,\n    \"alt\": 0x12,\n    \"pause\": 0x13,\n    \"caps_lock\": 0x14,\n    \"esc\": 0x1B,",
        "detail": "core.platform.windows.input.keyboard",
        "documentation": {}
    },
    {
        "label": "POINT",
        "kind": 6,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "class POINT(ctypes.Structure):\n    _fields_ = [(\"x\", ctypes.c_long), (\"y\", ctypes.c_long)]\nclass MOUSEINPUT(ctypes.Structure):\n    _fields_ = [\n        (\"dx\", wintypes.LONG),\n        (\"dy\", wintypes.LONG),\n        (\"mouseData\", wintypes.DWORD),\n        (\"dwFlags\", wintypes.DWORD),\n        (\"time\", wintypes.DWORD),\n        (\"dwExtraInfo\", ctypes.POINTER(ctypes.c_ulong)),",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEINPUT",
        "kind": 6,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "class MOUSEINPUT(ctypes.Structure):\n    _fields_ = [\n        (\"dx\", wintypes.LONG),\n        (\"dy\", wintypes.LONG),\n        (\"mouseData\", wintypes.DWORD),\n        (\"dwFlags\", wintypes.DWORD),\n        (\"time\", wintypes.DWORD),\n        (\"dwExtraInfo\", ctypes.POINTER(ctypes.c_ulong)),\n    ]\nclass INPUT(ctypes.Structure):",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "INPUT",
        "kind": 6,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "class INPUT(ctypes.Structure):\n    _fields_ = [(\"type\", wintypes.DWORD), (\"mi\", MOUSEINPUT)]\n# Константы для действий с мышью\nMOUSEEVENTF_MOVE = 0x0001\nMOUSEEVENTF_LEFTDOWN = 0x0002\nMOUSEEVENTF_LEFTUP = 0x0004\nMOUSEEVENTF_RIGHTDOWN = 0x0008\nMOUSEEVENTF_RIGHTUP = 0x0010\nMOUSEEVENTF_MIDDLEDOWN = 0x0020\nMOUSEEVENTF_MIDDLEUP = 0x0040",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "WindowsMouse",
        "kind": 6,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "class WindowsMouse(AbstractMouse):\n    \"\"\"Реализация мыши для операционной системы Windows.\"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"\n        Инициализирует контроллер мыши.\n        Args:\n            human_like (bool): Флаг, указывающий, нужно ли эмулировать человеческое поведение.\n        \"\"\"\n        self.human_like = human_like\n        self.controller = None  # Для тестирования будет заменено моком",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEEVENTF_MOVE",
        "kind": 5,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "MOUSEEVENTF_MOVE = 0x0001\nMOUSEEVENTF_LEFTDOWN = 0x0002\nMOUSEEVENTF_LEFTUP = 0x0004\nMOUSEEVENTF_RIGHTDOWN = 0x0008\nMOUSEEVENTF_RIGHTUP = 0x0010\nMOUSEEVENTF_MIDDLEDOWN = 0x0020\nMOUSEEVENTF_MIDDLEUP = 0x0040\nMOUSEEVENTF_WHEEL = 0x0800\nMOUSEEVENTF_ABSOLUTE = 0x8000\nclass WindowsMouse(AbstractMouse):",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEEVENTF_LEFTDOWN",
        "kind": 5,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "MOUSEEVENTF_LEFTDOWN = 0x0002\nMOUSEEVENTF_LEFTUP = 0x0004\nMOUSEEVENTF_RIGHTDOWN = 0x0008\nMOUSEEVENTF_RIGHTUP = 0x0010\nMOUSEEVENTF_MIDDLEDOWN = 0x0020\nMOUSEEVENTF_MIDDLEUP = 0x0040\nMOUSEEVENTF_WHEEL = 0x0800\nMOUSEEVENTF_ABSOLUTE = 0x8000\nclass WindowsMouse(AbstractMouse):\n    \"\"\"Реализация мыши для операционной системы Windows.\"\"\"",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEEVENTF_LEFTUP",
        "kind": 5,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "MOUSEEVENTF_LEFTUP = 0x0004\nMOUSEEVENTF_RIGHTDOWN = 0x0008\nMOUSEEVENTF_RIGHTUP = 0x0010\nMOUSEEVENTF_MIDDLEDOWN = 0x0020\nMOUSEEVENTF_MIDDLEUP = 0x0040\nMOUSEEVENTF_WHEEL = 0x0800\nMOUSEEVENTF_ABSOLUTE = 0x8000\nclass WindowsMouse(AbstractMouse):\n    \"\"\"Реализация мыши для операционной системы Windows.\"\"\"\n    def __init__(self, human_like: bool = True):",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEEVENTF_RIGHTDOWN",
        "kind": 5,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "MOUSEEVENTF_RIGHTDOWN = 0x0008\nMOUSEEVENTF_RIGHTUP = 0x0010\nMOUSEEVENTF_MIDDLEDOWN = 0x0020\nMOUSEEVENTF_MIDDLEUP = 0x0040\nMOUSEEVENTF_WHEEL = 0x0800\nMOUSEEVENTF_ABSOLUTE = 0x8000\nclass WindowsMouse(AbstractMouse):\n    \"\"\"Реализация мыши для операционной системы Windows.\"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEEVENTF_RIGHTUP",
        "kind": 5,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "MOUSEEVENTF_RIGHTUP = 0x0010\nMOUSEEVENTF_MIDDLEDOWN = 0x0020\nMOUSEEVENTF_MIDDLEUP = 0x0040\nMOUSEEVENTF_WHEEL = 0x0800\nMOUSEEVENTF_ABSOLUTE = 0x8000\nclass WindowsMouse(AbstractMouse):\n    \"\"\"Реализация мыши для операционной системы Windows.\"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"\n        Инициализирует контроллер мыши.",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEEVENTF_MIDDLEDOWN",
        "kind": 5,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "MOUSEEVENTF_MIDDLEDOWN = 0x0020\nMOUSEEVENTF_MIDDLEUP = 0x0040\nMOUSEEVENTF_WHEEL = 0x0800\nMOUSEEVENTF_ABSOLUTE = 0x8000\nclass WindowsMouse(AbstractMouse):\n    \"\"\"Реализация мыши для операционной системы Windows.\"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"\n        Инициализирует контроллер мыши.\n        Args:",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEEVENTF_MIDDLEUP",
        "kind": 5,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "MOUSEEVENTF_MIDDLEUP = 0x0040\nMOUSEEVENTF_WHEEL = 0x0800\nMOUSEEVENTF_ABSOLUTE = 0x8000\nclass WindowsMouse(AbstractMouse):\n    \"\"\"Реализация мыши для операционной системы Windows.\"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"\n        Инициализирует контроллер мыши.\n        Args:\n            human_like (bool): Флаг, указывающий, нужно ли эмулировать человеческое поведение.",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEEVENTF_WHEEL",
        "kind": 5,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "MOUSEEVENTF_WHEEL = 0x0800\nMOUSEEVENTF_ABSOLUTE = 0x8000\nclass WindowsMouse(AbstractMouse):\n    \"\"\"Реализация мыши для операционной системы Windows.\"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"\n        Инициализирует контроллер мыши.\n        Args:\n            human_like (bool): Флаг, указывающий, нужно ли эмулировать человеческое поведение.\n        \"\"\"",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "MOUSEEVENTF_ABSOLUTE",
        "kind": 5,
        "importPath": "core.platform.windows.input.mouse",
        "description": "core.platform.windows.input.mouse",
        "peekOfCode": "MOUSEEVENTF_ABSOLUTE = 0x8000\nclass WindowsMouse(AbstractMouse):\n    \"\"\"Реализация мыши для операционной системы Windows.\"\"\"\n    def __init__(self, human_like: bool = True):\n        \"\"\"\n        Инициализирует контроллер мыши.\n        Args:\n            human_like (bool): Флаг, указывающий, нужно ли эмулировать человеческое поведение.\n        \"\"\"\n        self.human_like = human_like",
        "detail": "core.platform.windows.input.mouse",
        "documentation": {}
    },
    {
        "label": "Win32ProcessManager",
        "kind": 6,
        "importPath": "core.platform.windows.process.win32_process_manager",
        "description": "core.platform.windows.process.win32_process_manager",
        "peekOfCode": "class Win32ProcessManager(AbstractProcessManager):\n    \"\"\"\n    Windows-реализация менеджера процессов.\n    Реализует AbstractProcessManager для Windows-платформы.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Инициализация менеджера процессов Windows.\"\"\"\n        pass\n    def start_process(\n        self,",
        "detail": "core.platform.windows.process.win32_process_manager",
        "documentation": {}
    },
    {
        "label": "Win32RegistryManager",
        "kind": 6,
        "importPath": "core.platform.windows.registry.win32_registry_manager",
        "description": "core.platform.windows.registry.win32_registry_manager",
        "peekOfCode": "class Win32RegistryManager(AbstractRegistryManager):\n    \"\"\"\n    Менеджер реестра Windows.\n    Предоставляет функции для работы с реестром Windows.\n    \"\"\"\n    # Константы для корневых ключей реестра\n    HKEY_CLASSES_ROOT = winreg.HKEY_CLASSES_ROOT\n    HKEY_CURRENT_USER = winreg.HKEY_CURRENT_USER\n    HKEY_LOCAL_MACHINE = winreg.HKEY_LOCAL_MACHINE\n    HKEY_USERS = winreg.HKEY_USERS",
        "detail": "core.platform.windows.registry.win32_registry_manager",
        "documentation": {}
    },
    {
        "label": "Win32SystemInfo",
        "kind": 6,
        "importPath": "core.platform.windows.system.win32_system_info",
        "description": "core.platform.windows.system.win32_system_info",
        "peekOfCode": "class Win32SystemInfo(AbstractSystemInfo):\n    \"\"\"\n    Класс для получения системной информации Windows.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Инициализация класса системной информации.\"\"\"\n        try:\n            self.wmi_client = wmi.WMI()\n        except Exception as e:\n            handle_error(f\"Error initializing WMI: {e}\", e, module=\"system\")",
        "detail": "core.platform.windows.system.win32_system_info",
        "documentation": {}
    },
    {
        "label": "PyGetWindowManager",
        "kind": 6,
        "importPath": "core.platform.windows.window.pygetwindow_manager",
        "description": "core.platform.windows.window.pygetwindow_manager",
        "peekOfCode": "class PyGetWindowManager(AbstractWindowManager):\n    \"\"\"\n    Менеджер окон Windows, использующий библиотеку pygetwindow.\n    \"\"\"\n    def get_all_windows(self) -> List[Any]:\n        \"\"\"\n        Получение списка всех открытых окон.\n        Returns:\n            List[Any]: Список объектов окон\n        \"\"\"",
        "detail": "core.platform.windows.window.pygetwindow_manager",
        "documentation": {}
    },
    {
        "label": "Win32WindowManager",
        "kind": 6,
        "importPath": "core.platform.windows.window.win32_window_manager",
        "description": "core.platform.windows.window.win32_window_manager",
        "peekOfCode": "class Win32WindowManager(AbstractWindowManager):\n    \"\"\"\n    Менеджер окон Windows, использующий Win32 API.\n    \"\"\"\n    def get_all_windows(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Получение списка всех открытых окон.\n        Returns:\n            List[Dict[str, Any]]: Список словарей с информацией о каждом окне\n        \"\"\"",
        "detail": "core.platform.windows.window.win32_window_manager",
        "documentation": {}
    },
    {
        "label": "create_access_token",
        "kind": 2,
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "peekOfCode": "def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"\n    Создает JWT токен доступа.\n    Args:\n        data: Данные для включения в токен\n        expires_delta: Время жизни токена\n    Returns:\n        str: JWT токен\n    \"\"\"\n    to_encode = data.copy()",
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "verify_token",
        "kind": 2,
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "peekOfCode": "def verify_token(token: str) -> Dict[str, Any]:\n    \"\"\"\n    Проверяет JWT токен.\n    Args:\n        token: JWT токен для проверки\n    Returns:\n        Dict[str, Any]: Декодированные данные из токена\n    Raises:\n        jwt.InvalidTokenError: Если токен невалидный\n        jwt.ExpiredSignatureError: Если токен истек",
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "decode_token",
        "kind": 2,
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "peekOfCode": "def decode_token(token: str) -> Dict[str, Any]:\n    \"\"\"\n    Декодирует JWT токен без проверки.\n    Args:\n        token: JWT токен для декодирования\n    Returns:\n        Dict[str, Any]: Декодированные данные из токена\n    \"\"\"\n    try:\n        # Декодируем без проверки подписи для тестирования",
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "create_refresh_token",
        "kind": 2,
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "peekOfCode": "def create_refresh_token(user_id: int) -> str:\n    \"\"\"\n    Создает refresh токен.\n    Args:\n        user_id: ID пользователя\n    Returns:\n        str: Refresh токен\n    \"\"\"\n    data = {\"user_id\": user_id, \"type\": \"refresh\"}\n    expire = datetime.now(timezone.utc) + timedelta(days=7)  # Refresh токен на 7 дней",
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "generate_token_signature",
        "kind": 2,
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "peekOfCode": "def generate_token_signature(token: str, secret: str) -> str:\n    \"\"\"\n    Генерирует подпись для токена.\n    Args:\n        token: Токен для подписи\n        secret: Секретный ключ\n    Returns:\n        str: Подпись токена\n    \"\"\"\n    return hashlib.sha256(f\"{token}{secret}\".encode()).hexdigest()",
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "peekOfCode": "SECRET_KEY = \"neuro-link-secret-key-change-in-production\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\ndef create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"\n    Создает JWT токен доступа.\n    Args:\n        data: Данные для включения в токен\n        expires_delta: Время жизни токена\n    Returns:",
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "kind": 5,
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "peekOfCode": "ALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\ndef create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"\n    Создает JWT токен доступа.\n    Args:\n        data: Данные для включения в токен\n        expires_delta: Время жизни токена\n    Returns:\n        str: JWT токен",
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN_EXPIRE_MINUTES",
        "kind": 5,
        "importPath": "core.security.jwt_handler",
        "description": "core.security.jwt_handler",
        "peekOfCode": "ACCESS_TOKEN_EXPIRE_MINUTES = 30\ndef create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"\n    Создает JWT токен доступа.\n    Args:\n        data: Данные для включения в токен\n        expires_delta: Время жизни токена\n    Returns:\n        str: JWT токен\n    \"\"\"",
        "detail": "core.security.jwt_handler",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "kind": 2,
        "importPath": "core.security.password",
        "description": "core.security.password",
        "peekOfCode": "def hash_password(password: str, salt: Optional[str] = None) -> Tuple[str, str]:\n    \"\"\"\n    Хеширует пароль с солью.\n    Args:\n        password: Пароль для хеширования\n        salt: Соль (если не указана, генерируется автоматически)\n    Returns:\n        Tuple[str, str]: Кортеж (хеш_пароля, соль)\n    \"\"\"\n    salt = salt or secrets.token_hex(16)  # Используем или переданную соль, или генерируем новую",
        "detail": "core.security.password",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "kind": 2,
        "importPath": "core.security.password",
        "description": "core.security.password",
        "peekOfCode": "def verify_password(password: str, stored_hash: str, salt: str) -> bool:\n    \"\"\"\n    Проверяет пароль против сохраненного хеша.\n    Args:\n        password: Вводимый пароль\n        stored_hash: Сохраненный хеш\n        salt: Соль\n    Returns:\n        bool: True если пароль верный\n    \"\"\"",
        "detail": "core.security.password",
        "documentation": {}
    },
    {
        "label": "generate_secure_password",
        "kind": 2,
        "importPath": "core.security.password",
        "description": "core.security.password",
        "peekOfCode": "def generate_secure_password(length: int = 12) -> str:\n    \"\"\"\n    Генерирует безопасный пароль.\n    Args:\n        length: Длина пароля\n    Returns:\n        str: Сгенерированный пароль\n    \"\"\"\n    import string\n    characters = string.ascii_letters + string.digits + \"!@#$%^&*\"",
        "detail": "core.security.password",
        "documentation": {}
    },
    {
        "label": "AIModelService",
        "kind": 6,
        "importPath": "core.services.ai_model_service",
        "description": "core.services.ai_model_service",
        "peekOfCode": "class AIModelService:\n    \"\"\"Сервис управления AI моделями.\"\"\"\n    def __init__(self, db_session: Session):\n        \"\"\"\n        Инициализирует сервис AI моделей.\n        Args:\n            db_session: Сессия базы данных\n        \"\"\"\n        self.db = db_session\n    def create_model(",
        "detail": "core.services.ai_model_service",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.services.ai_model_service",
        "description": "core.services.ai_model_service",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass AIModelService:\n    \"\"\"Сервис управления AI моделями.\"\"\"\n    def __init__(self, db_session: Session):\n        \"\"\"\n        Инициализирует сервис AI моделей.\n        Args:\n            db_session: Сессия базы данных\n        \"\"\"\n        self.db = db_session",
        "detail": "core.services.ai_model_service",
        "documentation": {}
    },
    {
        "label": "AuthService",
        "kind": 6,
        "importPath": "core.services.auth_service",
        "description": "core.services.auth_service",
        "peekOfCode": "class AuthService:\n    \"\"\"Сервис для работы с аутентификацией и авторизацией.\"\"\"\n    def __init__(self, db_session: Session):\n        \"\"\"\n        Инициализирует сервис аутентификации.\n        Args:\n            db_session: Сессия базы данных\n        \"\"\"\n        self.db = db_session\n        self.user_repo = UserRepository(db_session)",
        "detail": "core.services.auth_service",
        "documentation": {}
    },
    {
        "label": "PermissionService",
        "kind": 6,
        "importPath": "core.services.permission_service",
        "description": "core.services.permission_service",
        "peekOfCode": "class PermissionService:\n    \"\"\"Сервис для работы с правами доступа.\"\"\"\n    def __init__(self, db_session: Session):\n        \"\"\"\n        Инициализирует сервис прав доступа.\n        Args:\n            db_session: Сессия базы данных\n        \"\"\"\n        self.db = db_session\n        self.auth_service = AuthService(db_session)",
        "detail": "core.services.permission_service",
        "documentation": {}
    },
    {
        "label": "TaskService",
        "kind": 6,
        "importPath": "core.services.task_service",
        "description": "core.services.task_service",
        "peekOfCode": "class TaskService:\n    \"\"\"Сервис управления задачами.\"\"\"\n    def __init__(self, db_session: Session):\n        self.db = db_session\n    def create_task(\n        self,\n        user_id: int,\n        title: str,\n        description: Optional[str] = None,\n        priority: int = 1,",
        "detail": "core.services.task_service",
        "documentation": {}
    },
    {
        "label": "UserService",
        "kind": 6,
        "importPath": "core.services.user_service",
        "description": "core.services.user_service",
        "peekOfCode": "class UserService(AuthService):\n    \"\"\"Расширенный сервис пользователей.\"\"\"\n    def update_user_profile(\n        self,\n        user_id: int,\n        display_name: Optional[str] = None,\n        bio: Optional[str] = None,\n        avatar_url: Optional[str] = None,\n    ) -> Optional[User]:\n        \"\"\"Обновление профиля пользователя.\"\"\"",
        "detail": "core.services.user_service",
        "documentation": {}
    },
    {
        "label": "AuthOperationsMixin",
        "kind": 6,
        "importPath": "core.task.auth_operations",
        "description": "core.task.auth_operations",
        "peekOfCode": "class AuthOperationsMixin:\n    \"\"\"\n    Миксин для операций авторизации пользователей.\n    \"\"\"\n    def _is_auth_operation(self):\n        \"\"\"Проверяет, является ли задача операцией авторизации.\"\"\"\n        auth_keywords = [\n            \"зарегистрировать пользователя\",\n            \"регистрация\",\n            \"создать пользователя\",",
        "detail": "core.task.auth_operations",
        "documentation": {}
    },
    {
        "label": "BaseTask",
        "kind": 6,
        "importPath": "core.task.base",
        "description": "core.task.base",
        "peekOfCode": "class BaseTask:\n    \"\"\"\n    Базовая задача для выполнения системой.\n    \"\"\"\n    def __init__(self, description, registry):\n        \"\"\"\n        Инициализирует задачу.\n        Args:\n            description (str): Описание задачи\n            registry: Реестр компонентов системы",
        "detail": "core.task.base",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "core.task.base",
        "description": "core.task.base",
        "peekOfCode": "class Task(\n    AuthOperationsMixin,\n    ModelOrchestrationOperationsMixin,\n    VisionOperationsMixin,\n    WebOperationsMixin,\n    WindowsOperationsMixin,\n    FileOperationsMixin,\n    BaseTask,\n):\n    \"\"\"",
        "detail": "core.task.base",
        "documentation": {}
    },
    {
        "label": "FileOperationsMixin",
        "kind": 6,
        "importPath": "core.task.file_operations",
        "description": "core.task.file_operations",
        "peekOfCode": "class FileOperationsMixin:\n    \"\"\"\n    Миксин для файловых операций.\n    \"\"\"\n    def _is_file_operation(self: \"Task\") -> bool:\n        \"\"\"\n        Проверяет, является ли задача файловой операцией.\n        Returns:\n            bool: True если это файловая операция\n        \"\"\"",
        "detail": "core.task.file_operations",
        "documentation": {}
    },
    {
        "label": "HasDescription",
        "kind": 6,
        "importPath": "core.task.model_orchestration_operations",
        "description": "core.task.model_orchestration_operations",
        "peekOfCode": "class HasDescription(Protocol):\n    \"\"\"Протокол для объектов с описанием.\"\"\"\n    description: str\nclass ModelOrchestrationOperationsMixin:\n    \"\"\"\n    Миксин для операций оркестрации моделей.\n    \"\"\"\n    def _is_model_orchestration_operation(self) -> bool:\n        \"\"\"\n        Определяет, является ли задача операцией оркестрации моделей.",
        "detail": "core.task.model_orchestration_operations",
        "documentation": {}
    },
    {
        "label": "ModelOrchestrationOperationsMixin",
        "kind": 6,
        "importPath": "core.task.model_orchestration_operations",
        "description": "core.task.model_orchestration_operations",
        "peekOfCode": "class ModelOrchestrationOperationsMixin:\n    \"\"\"\n    Миксин для операций оркестрации моделей.\n    \"\"\"\n    def _is_model_orchestration_operation(self) -> bool:\n        \"\"\"\n        Определяет, является ли задача операцией оркестрации моделей.\n        \"\"\"\n        # Проверяем, что объект имеет атрибут description\n        description = getattr(self, \"description\", \"\")",
        "detail": "core.task.model_orchestration_operations",
        "documentation": {}
    },
    {
        "label": "TaskProtocol",
        "kind": 6,
        "importPath": "core.task.protocols",
        "description": "core.task.protocols",
        "peekOfCode": "class TaskProtocol(Protocol):\n    \"\"\"Протокол для класса Task.\"\"\"\n    description: str\n    _registry: Any\n    def _extract_filename(self) -> str | None:\n        \"\"\"Извлекает имя файла из описания задачи.\"\"\"\n        ...\n    def _extract_content(self) -> str:\n        \"\"\"Извлекает содержимое для записи в файл.\"\"\"\n        ...",
        "detail": "core.task.protocols",
        "documentation": {}
    },
    {
        "label": "WebTaskProtocol",
        "kind": 6,
        "importPath": "core.task.protocols",
        "description": "core.task.protocols",
        "peekOfCode": "class WebTaskProtocol(TaskProtocol, Protocol):\n    \"\"\"Протокол для веб-операций Task.\"\"\"\n    def _perform_duckduckgo_search(self, browser_controller: Any) -> TaskResult:\n        \"\"\"Выполняет поиск в DuckDuckGo.\"\"\"\n        ...\n    def _perform_web_search_with_protection(self, browser_controller: Any) -> TaskResult:\n        \"\"\"Выполняет поиск с защитой от ботов.\"\"\"\n        ...\n    def _check_bot_protection(self, browser_controller: Any) -> TaskResult:\n        \"\"\"Проверяет защиту от ботов.\"\"\"",
        "detail": "core.task.protocols",
        "documentation": {}
    },
    {
        "label": "WindowsTaskProtocol",
        "kind": 6,
        "importPath": "core.task.protocols",
        "description": "core.task.protocols",
        "peekOfCode": "class WindowsTaskProtocol(TaskProtocol, Protocol):\n    \"\"\"Протокол для Windows-операций Task.\"\"\"\n    def _launch_calculator(self) -> TaskResult:\n        \"\"\"Запускает калькулятор.\"\"\"\n        ...\n    def _launch_notepad(self) -> TaskResult:\n        \"\"\"Запускает блокнот.\"\"\"\n        ...\n    def _launch_application(self, app_name: str) -> TaskResult:\n        \"\"\"Запускает приложение.\"\"\"",
        "detail": "core.task.protocols",
        "documentation": {}
    },
    {
        "label": "FileTaskProtocol",
        "kind": 6,
        "importPath": "core.task.protocols",
        "description": "core.task.protocols",
        "peekOfCode": "class FileTaskProtocol(TaskProtocol, Protocol):\n    \"\"\"Протокол для файловых операций Task.\"\"\"\n    def _create_file(self, filesystem: Any) -> TaskResult:\n        \"\"\"Создает файл.\"\"\"\n        ...\n    def _read_file(self, filesystem: Any) -> TaskResult:\n        \"\"\"Читает файл.\"\"\"\n        ...\n    def _delete_file(self, filesystem: Any) -> TaskResult:\n        \"\"\"Удаляет файл.\"\"\"",
        "detail": "core.task.protocols",
        "documentation": {}
    },
    {
        "label": "TaskResult",
        "kind": 6,
        "importPath": "core.task.result",
        "description": "core.task.result",
        "peekOfCode": "class TaskResult:\n    \"\"\"\n    Результат выполнения задачи.\n    \"\"\"\n    def __init__(self, success, details=\"\"):\n        \"\"\"\n        Инициализирует результат задачи.\n        Args:\n            success (bool): Успешность выполнения\n            details (str): Подробности выполнения",
        "detail": "core.task.result",
        "documentation": {}
    },
    {
        "label": "VisionOperationsMixin",
        "kind": 6,
        "importPath": "core.task.vision_operations",
        "description": "core.task.vision_operations",
        "peekOfCode": "class VisionOperationsMixin:\n    \"\"\"\n    Миксин для операций компьютерного зрения.\n    \"\"\"\n    def _is_computer_vision_operation(self) -> bool:\n        \"\"\"\n        Проверяет, является ли задача операцией компьютерного зрения.\n        Returns:\n            bool: True если это операция компьютерного зрения\n        \"\"\"",
        "detail": "core.task.vision_operations",
        "documentation": {}
    },
    {
        "label": "WebOperationsMixin",
        "kind": 6,
        "importPath": "core.task.web_operations",
        "description": "core.task.web_operations",
        "peekOfCode": "class WebOperationsMixin:\n    \"\"\"\n    Миксин для веб-операций.\n    \"\"\"\n    def _is_web_operation(self: \"Task\") -> bool:\n        \"\"\"\n        Проверяет, является ли задача веб-операцией.\n        Returns:\n            bool: True если это веб-операция\n        \"\"\"",
        "detail": "core.task.web_operations",
        "documentation": {}
    },
    {
        "label": "WindowsOperationsMixin",
        "kind": 6,
        "importPath": "core.task.windows_operations",
        "description": "core.task.windows_operations",
        "peekOfCode": "class WindowsOperationsMixin:\n    \"\"\"\n    Миксин для Windows-операций.\n    \"\"\"\n    def _is_windows_operation(self: \"Task\") -> bool:\n        \"\"\"\n        Проверяет, является ли задача Windows-операцией.\n        Returns:\n            bool: True если это Windows-операция\n        \"\"\"",
        "detail": "core.task.windows_operations",
        "documentation": {}
    },
    {
        "label": "ElementLocalization",
        "kind": 6,
        "importPath": "core.vision.element_localization",
        "description": "core.vision.element_localization",
        "peekOfCode": "class ElementLocalization:\n    \"\"\"Класс для локализации элементов на экране\"\"\"\n    def __init__(self):\n        \"\"\"Инициализация\"\"\"\n        self.screen_capture = ScreenCapture()\n        self.element_recognition = ElementRecognition()\n    def locate_element_by_template(self, template, threshold=0.8):\n        \"\"\"\n        Локализует элемент на экране по шаблону\n        Args:",
        "detail": "core.vision.element_localization",
        "documentation": {}
    },
    {
        "label": "ElementRecognition",
        "kind": 6,
        "importPath": "core.vision.element_recognition",
        "description": "core.vision.element_recognition",
        "peekOfCode": "class ElementRecognition:\n    \"\"\"\n    Класс для распознавания элементов интерфейса.\n    \"\"\"\n    def __init__(self, screen_capture=None):\n        \"\"\"\n        Инициализация распознавателя элементов.\n        Args:\n            screen_capture (ScreenCapture, optional): Экземпляр класса для захвата экрана\n        \"\"\"",
        "detail": "core.vision.element_recognition",
        "documentation": {}
    },
    {
        "label": "ImageComparison",
        "kind": 6,
        "importPath": "core.vision.image_comparison",
        "description": "core.vision.image_comparison",
        "peekOfCode": "class ImageComparison:\n    \"\"\"Класс для сравнения изображений\"\"\"\n    def compare_images(self, img1, img2):\n        \"\"\"\n        Сравнивает два изображения и возвращает степень их сходства\n        Args:\n            img1 (numpy.ndarray): Первое изображение\n            img2 (numpy.ndarray): Второе изображение\n        Returns:\n            float: Степень сходства (0-1), где 1 - идентичные изображения",
        "detail": "core.vision.image_comparison",
        "documentation": {}
    },
    {
        "label": "ScreenCapture",
        "kind": 6,
        "importPath": "core.vision.screen_capture",
        "description": "core.vision.screen_capture",
        "peekOfCode": "class ScreenCapture:\n    \"\"\"\n    Класс для захвата и обработки скриншотов экрана.\n    \"\"\"\n    def capture_screen(self, region=None):\n        \"\"\"\n        Захватывает весь экран или указанную область\n        Args:\n            region (tuple, optional): Координаты области (x, y, width, height)\n        Returns:",
        "detail": "core.vision.screen_capture",
        "documentation": {}
    },
    {
        "label": "ScreenChanges",
        "kind": 6,
        "importPath": "core.vision.screen_changes",
        "description": "core.vision.screen_changes",
        "peekOfCode": "class ScreenChanges:\n    \"\"\"Класс для обработки изменений на экране\"\"\"\n    def __init__(self):\n        \"\"\"Инициализация\"\"\"\n        self.screen_capture = ScreenCapture()\n        self.image_comparison = ImageComparison()\n    def detect_changes(self, delay=0.5, threshold=0.95):\n        \"\"\"\n        Обнаруживает изменения на экране\n        Args:",
        "detail": "core.vision.screen_changes",
        "documentation": {}
    },
    {
        "label": "BrowserController",
        "kind": 6,
        "importPath": "core.web.browser_controller",
        "description": "core.web.browser_controller",
        "peekOfCode": "class BrowserController:\n    \"\"\"\n    Класс для управления веб-браузером.\n    \"\"\"\n    def __init__(self, browser_type=\"chrome\", headless=False):\n        \"\"\"\n        Инициализация контроллера браузера.\n        Args:\n            browser_type (str, optional): Тип браузера ('chrome', 'firefox', 'edge')\n            headless (bool, optional): Запускать браузер в фоновом режиме",
        "detail": "core.web.browser_controller",
        "documentation": {}
    },
    {
        "label": "ElementFinder",
        "kind": 6,
        "importPath": "core.web.element_finder",
        "description": "core.web.element_finder",
        "peekOfCode": "class ElementFinder:\n    \"\"\"\n    Класс для поиска элементов на веб-странице.\n    \"\"\"\n    def __init__(self, browser_controller):\n        \"\"\"\n        Инициализация искателя элементов.\n        Args:\n            browser_controller (BrowserController): Контроллер браузера\n        \"\"\"",
        "detail": "core.web.element_finder",
        "documentation": {}
    },
    {
        "label": "ComponentRegistry",
        "kind": 6,
        "importPath": "core.component_registry",
        "description": "core.component_registry",
        "peekOfCode": "class ComponentRegistry:\n    \"\"\"\n    Реестр компонентов системы.\n    Предоставляет централизованный доступ к компонентам по их именам.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Инициализация реестра компонентов.\"\"\"\n        self._components = {}\n    def register(self, name, component):\n        \"\"\"",
        "detail": "core.component_registry",
        "documentation": {}
    },
    {
        "label": "command_interrupt_flag",
        "kind": 5,
        "importPath": "core.globals",
        "description": "core.globals",
        "peekOfCode": "command_interrupt_flag = False",
        "detail": "core.globals",
        "documentation": {}
    },
    {
        "label": "PluginManager",
        "kind": 6,
        "importPath": "core.plugin_manager",
        "description": "core.plugin_manager",
        "peekOfCode": "class PluginManager:\n    \"\"\"\n    Менеджер плагинов.\n    Предоставляет функции для обнаружения, загрузки и выгрузки плагинов.\n    \"\"\"\n    def __init__(self, registry=None):\n        \"\"\"\n        Инициализация менеджера плагинов.\n        Args:\n            registry (ComponentRegistry, optional): Реестр компонентов системы",
        "detail": "core.plugin_manager",
        "documentation": {}
    },
    {
        "label": "System",
        "kind": 6,
        "importPath": "core.system",
        "description": "core.system",
        "peekOfCode": "class System:\n    \"\"\"\n    Основной класс системы, представляющий собой точку входа для взаимодействия с функциональностью.\n    \"\"\"\n    def __init__(self, registry):\n        \"\"\"\n        Инициализирует экземпляр системы.\n        Args:\n            registry: Реестр компонентов системы\n        \"\"\"",
        "detail": "core.system",
        "documentation": {}
    },
    {
        "label": "SystemInitializer",
        "kind": 6,
        "importPath": "core.system_initializer",
        "description": "core.system_initializer",
        "peekOfCode": "class SystemInitializer:\n    \"\"\"\n    Инициализатор системы.\n    Отвечает за инициализацию и завершение работы системы.\n    \"\"\"\n    def __init__(self, registry=None):\n        \"\"\"\n        Инициализация инициализатора системы.\n        Args:\n            registry (ComponentRegistry, optional): Реестр компонентов системы",
        "detail": "core.system_initializer",
        "documentation": {}
    },
    {
        "label": "TaskManager",
        "kind": 6,
        "importPath": "core.task_manager",
        "description": "core.task_manager",
        "peekOfCode": "class TaskManager:\n    \"\"\"\n    Менеджер задач для управления жизненным циклом задач.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Инициализация менеджера задач.\n        \"\"\"\n        self._tasks = {}\n        self._task_counter = 0",
        "detail": "core.task_manager",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "migrations.versions.13ee2f4ed3bb_add_salt_column_to_users",
        "description": "migrations.versions.13ee2f4ed3bb_add_salt_column_to_users",
        "peekOfCode": "def upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # Добавляем столбец salt в таблицу users если его еще нет\n    conn = op.get_bind()\n    inspector = sa.inspect(conn)\n    columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]\n    if \"salt\" not in columns:\n        op.add_column(\"users\", sa.Column(\"salt\", sa.String(255), nullable=True))\n        print(\"✅ Столбец salt добавлен в таблицу users\")\n    else:",
        "detail": "migrations.versions.13ee2f4ed3bb_add_salt_column_to_users",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "migrations.versions.13ee2f4ed3bb_add_salt_column_to_users",
        "description": "migrations.versions.13ee2f4ed3bb_add_salt_column_to_users",
        "peekOfCode": "def downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # Удаляем столбец salt из таблицы users\n    conn = op.get_bind()\n    inspector = sa.inspect(conn)\n    columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]\n    if \"salt\" in columns:\n        op.drop_column(\"users\", \"salt\")\n        print(\"✅ Столбец salt удален из таблицы users\")\n    else:",
        "detail": "migrations.versions.13ee2f4ed3bb_add_salt_column_to_users",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "migrations.versions.52f69517b81e_add_all_missing_tables",
        "description": "migrations.versions.52f69517b81e_add_all_missing_tables",
        "peekOfCode": "def upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"ai_models\",\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"name\", sa.String(length=100), nullable=False),\n        sa.Column(\"provider\", sa.String(length=100), nullable=False),\n        sa.Column(\"is_api\", sa.Boolean(), nullable=True),\n        sa.Column(\"base_url\", sa.String(length=255), nullable=True),",
        "detail": "migrations.versions.52f69517b81e_add_all_missing_tables",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "migrations.versions.52f69517b81e_add_all_missing_tables",
        "description": "migrations.versions.52f69517b81e_add_all_missing_tables",
        "peekOfCode": "def downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    with op.batch_alter_table(\"users\", schema=None) as batch_op:\n        batch_op.alter_column(\n            \"email\",\n            existing_type=sa.String(length=255),\n            type_=sa.VARCHAR(length=100),\n            existing_nullable=False,\n        )",
        "detail": "migrations.versions.52f69517b81e_add_all_missing_tables",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "description": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "peekOfCode": "def upgrade() -> None:\n    \"\"\"Добавляем столбец role в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы\n        columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]\n        if \"role\" not in columns:\n            print(\"🔧 Добавляем столбец role в таблицу users...\")",
        "detail": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "description": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "peekOfCode": "def downgrade() -> None:\n    \"\"\"Удаляем столбец role из таблицы users.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы\n        columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]\n        if \"role\" in columns:\n            print(\"🔧 Удаляем столбец role из таблицы users...\")",
        "detail": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "documentation": {}
    },
    {
        "label": "revision",
        "kind": 5,
        "importPath": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "description": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "peekOfCode": "revision = \"5308b4d57cde\"\ndown_revision = \"b0afe86a69c1\"\nbranch_labels = None\ndepends_on = None\ndef upgrade() -> None:\n    \"\"\"Добавляем столбец role в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:",
        "detail": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "documentation": {}
    },
    {
        "label": "down_revision",
        "kind": 5,
        "importPath": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "description": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "peekOfCode": "down_revision = \"b0afe86a69c1\"\nbranch_labels = None\ndepends_on = None\ndef upgrade() -> None:\n    \"\"\"Добавляем столбец role в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы",
        "detail": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "documentation": {}
    },
    {
        "label": "branch_labels",
        "kind": 5,
        "importPath": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "description": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "peekOfCode": "branch_labels = None\ndepends_on = None\ndef upgrade() -> None:\n    \"\"\"Добавляем столбец role в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы\n        columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]",
        "detail": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "documentation": {}
    },
    {
        "label": "depends_on",
        "kind": 5,
        "importPath": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "description": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "peekOfCode": "depends_on = None\ndef upgrade() -> None:\n    \"\"\"Добавляем столбец role в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы\n        columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]\n        if \"role\" not in columns:",
        "detail": "migrations.versions.5308b4d57cde_add_role_column_to_users",
        "documentation": {}
    },
    {
        "label": "drop_constraint_if_exists",
        "kind": 2,
        "importPath": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "description": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "peekOfCode": "def drop_constraint_if_exists(constraint_name, table_name, type_):\n    \"\"\"Безопасно удаляет ограничение, если оно существует.\"\"\"\n    # Проверяем существование constraint перед удалением\n    conn = op.get_bind()\n    # Запрос для проверки существования constraint\n    query = f\"\"\"\n    SELECT 1 FROM pg_constraint c\n    JOIN pg_namespace n ON n.oid = c.connamespace\n    JOIN pg_class t ON t.oid = c.conrelid\n    WHERE c.conname = '{constraint_name}'",
        "detail": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "documentation": {}
    },
    {
        "label": "drop_table_if_exists",
        "kind": 2,
        "importPath": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "description": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "peekOfCode": "def drop_table_if_exists(table_name):\n    \"\"\"Безопасно удаляет таблицу, если она существует.\"\"\"\n    conn = op.get_bind()\n    inspector = sa.inspect(conn)\n    if inspector.has_table(table_name):\n        op.drop_table(table_name)\n        print(f\"Таблица {table_name} успешно удалена\")\n    else:\n        print(f\"Таблица {table_name} не существует, пропускаем\")\ndef upgrade() -> None:",
        "detail": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "description": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "peekOfCode": "def upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ЭТАП 1: Удаление всех внешних ключей\n    # ai_models внешние ключи\n    drop_constraint_if_exists(\"ai_models_model_type_id_fkey\", \"ai_models\", \"foreignkey\")\n    # api_keys внешние ключи\n    drop_constraint_if_exists(\"api_keys_user_id_fkey\", \"api_keys\", \"foreignkey\")\n    # task_history внешние ключи\n    drop_constraint_if_exists(\"task_history_task_id_fkey\", \"task_history\", \"foreignkey\")\n    drop_constraint_if_exists(\"task_history_user_id_fkey\", \"task_history\", \"foreignkey\")",
        "detail": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "description": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "peekOfCode": "def downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # Удаляем внешние ключи\n    try:\n        op.drop_constraint(\n            \"routing_rules_target_model_id_fkey\", \"routing_rules\", type_=\"foreignkey\"\n        )\n    except Exception:\n        pass\n    try:",
        "detail": "migrations.versions.97eaf3e5639a_manual_initial_migration",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "description": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "peekOfCode": "def upgrade() -> None:\n    \"\"\"Добавляем столбец salt в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы\n        columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]\n        if \"salt\" not in columns:\n            print(\"🔧 Добавляем столбец salt в таблицу users...\")",
        "detail": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "description": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "peekOfCode": "def downgrade() -> None:\n    \"\"\"Удаляем столбец salt из таблицы users.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы\n        columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]\n        if \"salt\" in columns:\n            print(\"🔧 Удаляем столбец salt из таблицы users...\")",
        "detail": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "documentation": {}
    },
    {
        "label": "revision",
        "kind": 5,
        "importPath": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "description": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "peekOfCode": "revision = \"b0afe86a69c1\"\ndown_revision = \"13ee2f4ed3bb\"\nbranch_labels = None\ndepends_on = None\ndef upgrade() -> None:\n    \"\"\"Добавляем столбец salt в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:",
        "detail": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "documentation": {}
    },
    {
        "label": "down_revision",
        "kind": 5,
        "importPath": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "description": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "peekOfCode": "down_revision = \"13ee2f4ed3bb\"\nbranch_labels = None\ndepends_on = None\ndef upgrade() -> None:\n    \"\"\"Добавляем столбец salt в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы",
        "detail": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "documentation": {}
    },
    {
        "label": "branch_labels",
        "kind": 5,
        "importPath": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "description": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "peekOfCode": "branch_labels = None\ndepends_on = None\ndef upgrade() -> None:\n    \"\"\"Добавляем столбец salt в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы\n        columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]",
        "detail": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "documentation": {}
    },
    {
        "label": "depends_on",
        "kind": 5,
        "importPath": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "description": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "peekOfCode": "depends_on = None\ndef upgrade() -> None:\n    \"\"\"Добавляем столбец salt в таблицу users если его нет.\"\"\"\n    # Получаем соединение и инспектор\n    connection = op.get_bind()\n    inspector = inspect(connection)\n    try:\n        # Проверяем существующие столбцы\n        columns = [c[\"name\"] for c in inspector.get_columns(\"users\")]\n        if \"salt\" not in columns:",
        "detail": "migrations.versions.b0afe86a69c1_add_salt_column_only",
        "documentation": {}
    },
    {
        "label": "upgrade",
        "kind": 2,
        "importPath": "migrations.versions.d09550ca714f_add_role_column_to_users_fix",
        "description": "migrations.versions.d09550ca714f_add_role_column_to_users_fix",
        "peekOfCode": "def upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # Проверяем, есть ли уже поле role в таблице users\n    conn = op.get_bind()\n    inspector = sa.inspect(conn)\n    columns = [col[\"name\"] for col in inspector.get_columns(\"users\")]\n    if \"role\" not in columns:\n        # Добавляем поле role если его нет\n        op.add_column(\"users\", sa.Column(\"role\", sa.String(50), server_default=\"user\"))\n        print(\"✅ Поле 'role' добавлено в таблицу users\")",
        "detail": "migrations.versions.d09550ca714f_add_role_column_to_users_fix",
        "documentation": {}
    },
    {
        "label": "downgrade",
        "kind": 2,
        "importPath": "migrations.versions.d09550ca714f_add_role_column_to_users_fix",
        "description": "migrations.versions.d09550ca714f_add_role_column_to_users_fix",
        "peekOfCode": "def downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # Удаляем поле role\n    conn = op.get_bind()\n    inspector = sa.inspect(conn)\n    columns = [col[\"name\"] for col in inspector.get_columns(\"users\")]\n    if \"role\" in columns:\n        op.drop_column(\"users\", \"role\")\n        print(\"✅ Поле 'role' удалено из таблицы users\")",
        "detail": "migrations.versions.d09550ca714f_add_role_column_to_users_fix",
        "documentation": {}
    },
    {
        "label": "get_url",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def get_url():\n    \"\"\"Получаем URL базы данных из переменных окружения\"\"\"\n    db_url = os.environ.get(\n        \"DATABASE_URL\", \"postgresql://neurolink:secure_password@localhost:5432/neurolink\"\n    )\n    print(f\"Using DATABASE_URL: {db_url}\")  # Отладочный вывод\n    return db_url\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "run_migrations_offline",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n    Calls to context.execute() here emit the given string to the\n    script output.\n    \"\"\"\n    url = get_url()",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "run_migrations_online",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n    \"\"\"\n    # Получаем секцию конфигурации\n    configuration = config.get_section(config.config_ini_section, {})\n    # Переопределяем URL базы данных из переменных окружения\n    configuration[\"sqlalchemy.url\"] = get_url()\n    connectable = engine_from_config(",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "config = context.config\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\nimport sys  # noqa: E402",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "target_metadata",
        "kind": 5,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "target_metadata = Base.metadata\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\ndef get_url():\n    \"\"\"Получаем URL базы данных из переменных окружения\"\"\"\n    db_url = os.environ.get(\n        \"DATABASE_URL\", \"postgresql://neurolink:secure_password@localhost:5432/neurolink\"\n    )",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "CommandStep",
        "kind": 6,
        "importPath": "models.command_models",
        "description": "models.command_models",
        "peekOfCode": "class CommandStep:\n    \"\"\"Класс для представления шага выполнения команды\"\"\"\n    step_number: int\n    description: str\n    status: str  # 'pending', 'in_progress', 'completed', 'failed', 'interrupted'\n    result: Optional[str] = None\n    error: Optional[str] = None\n    completion_percentage: float = 0.0\n    accuracy_percentage: float = (\n        90.0  # По умолчанию считаем, что команда выполнена с высокой точностью",
        "detail": "models.command_models",
        "documentation": {}
    },
    {
        "label": "CommandExecution",
        "kind": 6,
        "importPath": "models.command_models",
        "description": "models.command_models",
        "peekOfCode": "class CommandExecution:\n    \"\"\"Класс для представления выполнения команды\"\"\"\n    command_text: str\n    steps: List[CommandStep]\n    start_time: str\n    end_time: Optional[str] = None\n    overall_status: str = \"in_progress\"  # 'in_progress', 'completed', 'failed', 'interrupted'\n    completion_percentage: float = 0.0\n    accuracy_percentage: float = 0.0\n    current_step: int = 0  # Индекс текущего выполняемого шага",
        "detail": "models.command_models",
        "documentation": {}
    },
    {
        "label": "require_auth",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def require_auth(f):\n    \"\"\"Декоратор для проверки авторизации\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        token = request.headers.get(\"Authorization\")\n        if not token:\n            return jsonify({\"success\": False, \"message\": \"Требуется авторизация\"}), 401\n        if token.startswith(\"Bearer \"):\n            token = token[7:]\n        try:",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "query",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def query():\n    # Проверяем, что request.json не None\n    if request.json is None:\n        return jsonify({\"error\": \"Ожидался JSON в теле запроса\"}), 400\n    user_input = request.json.get(\"input\", \"\").lower()\n    # Проверяем, является ли команда составной\n    if any(sep in user_input for sep in [\" и \", \" затем \", \" после этого \", \" потом \", \", \"]):\n        # Обрабатываем составную команду\n        execution_result = execute_command_with_steps(user_input)\n        # Формируем ответ для пользователя",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "clarify",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def clarify():\n    \"\"\"\n    Обрабатывает запросы на уточнение информации от пользователя\n    \"\"\"\n    # Проверяем, что request.json не None\n    if request.json is None:\n        return jsonify({\"error\": \"Ожидался JSON в теле запроса\"}), 400\n    user_input = request.json.get(\"input\", \"\")\n    original_command = request.json.get(\"original_command\", \"\")\n    error_context = request.json.get(\"error_context\", {})",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "confirm_action",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def confirm_action():\n    \"\"\"\n    Обрабатывает подтверждение действия от пользователя\n    \"\"\"\n    # Проверяем, что request.json не None\n    if request.json is None:\n        return jsonify({\"error\": \"Ожидался JSON в теле запроса\"}), 400\n    user_confirmation = request.json.get(\"confirmation\", False)\n    command = request.json.get(\"command\", \"\")\n    code = request.json.get(\"code\", \"\")",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "interrupt_command",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def interrupt_command():\n    \"\"\"\n    Прерывает выполнение текущей команды\n    \"\"\"\n    global command_interrupt_flag\n    # Устанавливаем флаг прерывания\n    command_interrupt_flag = True\n    logger.info(\"Получен запрос на прерывание команды\")\n    detailed_logger.info(\"Получен запрос на прерывание команды\")\n    return jsonify(",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "get_history",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def get_history():\n    \"\"\"Возвращает историю выполненных команд\"\"\"\n    try:\n        # Проверяем, существует ли файл журнала\n        if not os.path.exists(Config.SUMMARY_LOG_FILE):\n            return jsonify({\"history\": [], \"count\": 0, \"message\": \"История команд пуста\"})\n        # Пробуем различные кодировки для чтения файла\n        encodings = [\"utf-8\", \"cp1251\", \"latin-1\"]\n        summary_content = None\n        for encoding in encodings:",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "get_detailed_history",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def get_detailed_history(command_timestamp):\n    \"\"\"Возвращает подробную информацию о выполнении команды\"\"\"\n    try:\n        # Проверяем, существует ли файл журнала\n        if not os.path.exists(Config.DETAILED_LOG_FILE):\n            return jsonify(\n                {\n                    \"command_timestamp\": command_timestamp,\n                    \"details\": [],\n                    \"message\": \"Детальная история команд пуста\",",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "check_ai_models",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def check_ai_models():\n    \"\"\"Проверяет доступность нейросетей\"\"\"\n    # Получаем ID модели из запроса (если есть)\n    model_id = request.json.get(\"model_id\", None) if request.json else None\n    # Проверяем доступность\n    results = check_ai_model_availability(model_id)\n    return jsonify(results)\n@api_bp.route(\"/ai_models/select\", methods=[\"POST\"])\ndef select_ai_model_route():\n    \"\"\"Выбирает нейросеть для использования\"\"\"",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "select_ai_model_route",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def select_ai_model_route():\n    \"\"\"Выбирает нейросеть для использования\"\"\"\n    # Получаем ID модели из запроса\n    model_id = request.json.get(\"model_id\", None) if request.json else None\n    if not model_id:\n        return jsonify({\"success\": False, \"message\": \"Не указан ID нейросети\"})\n    # Выбираем нейросеть\n    result = select_ai_model(model_id)\n    return jsonify(result)\n@api_bp.route(\"/ensure_log_files_exist\", methods=[\"POST\"])",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "ensure_log_files_exist_route",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def ensure_log_files_exist_route():\n    \"\"\"Создает необходимые файлы логов, если они не существуют\"\"\"\n    try:\n        from utils.log_maintenance import ensure_log_files_exist\n        ensure_log_files_exist()\n        return jsonify({\"success\": True, \"message\": \"Проверка файлов логов выполнена\"})\n    except Exception as e:\n        logger.error(f\"Ошибка при создании файлов логов: {str(e)}\")\n        return jsonify({\"success\": False, \"error\": f\"Ошибка при создании файлов логов: {str(e)}\"})\n@api_bp.route(\"/clean_old_logs\", methods=[\"POST\"])",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "clean_old_logs_route",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def clean_old_logs_route():\n    \"\"\"Удаляет старые файлы логов\"\"\"\n    try:\n        from utils.log_maintenance import clean_old_logs\n        # Получаем максимальный возраст файлов из запроса или используем значение по умолчанию\n        max_age_days = request.json.get(\"max_age_days\", 30) if request.json else 30\n        clean_old_logs(max_age_days)\n        return jsonify({\"success\": True, \"message\": f\"Удалены логи старше {max_age_days} дней\"})\n    except Exception as e:\n        logger.error(f\"Ошибка при удалении старых логов: {str(e)}\")",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "get_ai_models_route",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def get_ai_models_route():\n    \"\"\"Возвращает список доступных нейросетей и их статус\"\"\"\n    try:\n        # Получаем данные о моделях из сервиса\n        models_data = get_ai_models()\n        return jsonify(models_data)\n    except Exception as e:\n        logger.error(f\"Ошибка при получении списка нейросетей: {str(e)}\")\n        return jsonify({\"error\": f\"Ошибка при получении списка нейросетей: {str(e)}\", \"models\": []})\n@api_bp.route(\"/export_history_logs\", methods=[\"GET\"])",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "export_history_logs",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def export_history_logs():\n    \"\"\"Экспортирует историю команд в файл\"\"\"\n    try:\n        if not os.path.exists(Config.SUMMARY_LOG_FILE):\n            return jsonify({\"error\": \"Файл истории команд не найден\"}), 404\n        # Читаем содержимое файла\n        with open(Config.SUMMARY_LOG_FILE, \"r\", encoding=\"utf-8\") as f:\n            content = f.read()\n        # Создаем ответ с файлом\n        response = make_response(content)",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "export_detailed_logs",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def export_detailed_logs():\n    \"\"\"Экспортирует детальные логи в файл\"\"\"\n    try:\n        if not os.path.exists(Config.DETAILED_LOG_FILE):\n            return jsonify({\"error\": \"Файл детальных логов не найден\"}), 404\n        # Читаем содержимое файла\n        with open(Config.DETAILED_LOG_FILE, \"r\", encoding=\"utf-8\") as f:\n            content = f.read()\n        # Создаем ответ с файлом\n        response = make_response(content)",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "get_system_logs",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def get_system_logs():\n    \"\"\"\n    Возвращает системные логи (только для разработчиков)\n    Требует аутентификации разработчика\n    \"\"\"\n    # Проверка, является ли пользователь разработчиком\n    developer_mode = request.args.get(\"developer_mode\") == \"true\"\n    developer_key = request.args.get(\"developer_key\", \"\")\n    # Простая проверка ключа разработчика (в реальном приложении нужна более надежная аутентификация)\n    if not developer_mode or developer_key != Config.DEVELOPER_KEY:",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "check_single_ai_model",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def check_single_ai_model(model_id):\n    \"\"\"Проверяет доступность конкретной нейросети\"\"\"\n    try:\n        # Проверяем доступность\n        result = check_ai_model_availability(model_id)\n        return jsonify(result)\n    except Exception as e:\n        logger.error(f\"Ошибка при проверке модели {model_id}: {str(e)}\")\n        return jsonify({\"success\": False, \"message\": f\"Ошибка при проверке модели: {str(e)}\"})\n@api_bp.route(\"/ai_models/update_from_huggingface\", methods=[\"POST\"])",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "update_models_from_huggingface_route",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def update_models_from_huggingface_route():\n    \"\"\"Обновляет список моделей, добавляя популярные модели с Hugging Face Hub\"\"\"\n    try:\n        # Вызываем функцию обновления моделей\n        result = update_models_from_huggingface()\n        return jsonify(result)\n    except Exception as e:\n        logger.error(f\"Ошибка при обновлении списка моделей: {str(e)}\")\n        return jsonify(\n            {\"success\": False, \"message\": f\"Ошибка при обновлении списка моделей: {str(e)}\"}",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "search_models_route",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def search_models_route():\n    \"\"\"Поиск моделей на Hugging Face Hub\"\"\"\n    try:\n        # Получаем параметр запроса\n        query = request.args.get(\"query\", \"\")\n        if not query:\n            return jsonify({\"success\": False, \"message\": \"Не указан поисковый запрос\"})\n        # Вызываем функцию поиска моделей\n        # Предполагается, что функция search_models определена в services/ai_service.py\n        models = search_models(query)",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "select_ai_model_by_id",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def select_ai_model_by_id(model_id):\n    \"\"\"Выбирает нейросеть для использования по ID\"\"\"\n    try:\n        # Выбираем нейросеть\n        result = select_ai_model(model_id)\n        return jsonify(result)\n    except Exception as e:\n        logger.error(f\"Ошибка при выборе модели {model_id}: {str(e)}\")\n        return jsonify({\"success\": False, \"message\": f\"Ошибка при выборе модели: {str(e)}\"})\n@api_bp.route(\"/ai/test\", methods=[\"POST\"])",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "test_ai",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def test_ai():\n    \"\"\"Тестовый AI запрос\"\"\"\n    try:\n        data = request.get_json()\n        prompt = data.get(\"prompt\", \"Hello!\")\n        # Получаем ответ от AI\n        from services.ai_service import get_ai_response\n        response = get_ai_response(prompt)\n        return jsonify(\n            {\"success\": True, \"prompt\": prompt, \"response\": response, \"model\": \"DistilGPT-2 Simple\"}",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "get_models",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def get_models():\n    \"\"\"Получить список AI моделей\"\"\"\n    try:\n        from services.ai_service import get_ai_models\n        models = get_ai_models()\n        return jsonify(models)\n    except Exception as e:\n        return jsonify({\"success\": False, \"error\": str(e)}), 500\nfrom core.db.connection import get_db\nfrom core.services.auth_service import AuthService",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def register():\n    \"\"\"Регистрирует нового пользователя.\"\"\"\n    try:\n        data = request.get_json()\n        if not data:\n            return jsonify({\"success\": False, \"message\": \"Данные не предоставлены\"}), 400\n        username = data.get(\"username\")\n        email = data.get(\"email\")\n        password = data.get(\"password\")\n        display_name = data.get(\"display_name\")",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def login():\n    \"\"\"Аутентифицирует пользователя.\"\"\"\n    try:\n        data = request.get_json()\n        if not data:\n            return jsonify({\"success\": False, \"message\": \"Данные не предоставлены\"}), 400\n        username = data.get(\"username\")\n        password = data.get(\"password\")\n        if not all([username, password]):\n            return (",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "kind": 2,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "def get_current_user():\n    \"\"\"Получает информацию о текущем пользователе по токену.\"\"\"\n    try:\n        # Получаем токен из заголовка Authorization\n        auth_header = request.headers.get(\"Authorization\")\n        if not auth_header or not auth_header.startswith(\"Bearer \"):\n            return jsonify({\"success\": False, \"message\": \"Токен не предоставлен\"}), 401\n        token = auth_header.split(\" \")[1]\n        # Проверяем токен и получаем пользователя\n        from core.db.connection import get_db",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "api_bp",
        "kind": 5,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "api_bp = Blueprint(\"api\", __name__)\nlogger = logging.getLogger(\"neuro_assistant\")\ndetailed_logger = logging.getLogger(\"detailed_log\")\n# Добавить функцию для middleware\nfrom functools import wraps\ndef require_auth(f):\n    \"\"\"Декоратор для проверки авторизации\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        token = request.headers.get(\"Authorization\")",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\ndetailed_logger = logging.getLogger(\"detailed_log\")\n# Добавить функцию для middleware\nfrom functools import wraps\ndef require_auth(f):\n    \"\"\"Декоратор для проверки авторизации\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        token = request.headers.get(\"Authorization\")\n        if not token:",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "detailed_logger",
        "kind": 5,
        "importPath": "routes.api_routes",
        "description": "routes.api_routes",
        "peekOfCode": "detailed_logger = logging.getLogger(\"detailed_log\")\n# Добавить функцию для middleware\nfrom functools import wraps\ndef require_auth(f):\n    \"\"\"Декоратор для проверки авторизации\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        token = request.headers.get(\"Authorization\")\n        if not token:\n            return jsonify({\"success\": False, \"message\": \"Требуется авторизация\"}), 401",
        "detail": "routes.api_routes",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def index():\n    # Список доступных команд с иконками и описаниями\n    commands = [\n        {\n            \"main\": \"открой\",\n            \"alternatives\": [\"запусти\", \"открыть\"],\n            \"description\": \"Открывает программу или файл\",\n            \"icon\": \"folder-open\",\n        },\n        {",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "models",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def models():\n    return render_template(\"models.html\")\n@main_bp.route(\"/models/<model_id>/settings\")\ndef model_settings(model_id):\n    return render_template(\"model_settings.html\", model_id=model_id)\n@main_bp.route(\"/models/browser\")\ndef browser_models():\n    \"\"\"Страница управления браузерными моделями.\"\"\"\n    return render_template(\"browser.html\")\n@main_bp.route(\"/history\")",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "model_settings",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def model_settings(model_id):\n    return render_template(\"model_settings.html\", model_id=model_id)\n@main_bp.route(\"/models/browser\")\ndef browser_models():\n    \"\"\"Страница управления браузерными моделями.\"\"\"\n    return render_template(\"browser.html\")\n@main_bp.route(\"/history\")\ndef history():\n    return render_template(\"history.html\")\n# ✅ НОВЫЙ РОУТ: Детали элемента истории",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "browser_models",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def browser_models():\n    \"\"\"Страница управления браузерными моделями.\"\"\"\n    return render_template(\"browser.html\")\n@main_bp.route(\"/history\")\ndef history():\n    return render_template(\"history.html\")\n# ✅ НОВЫЙ РОУТ: Детали элемента истории\n@main_bp.route(\"/history/<item_id>\")\ndef history_detail(item_id):\n    # Заглушка данных команды (позже заменить на запрос к БД)",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "history",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def history():\n    return render_template(\"history.html\")\n# ✅ НОВЫЙ РОУТ: Детали элемента истории\n@main_bp.route(\"/history/<item_id>\")\ndef history_detail(item_id):\n    # Заглушка данных команды (позже заменить на запрос к БД)\n    command = {\n        \"id\": item_id,\n        \"command\": \"открыть браузер\" if item_id == \"cmd-001\" else f\"команда {item_id}\",\n        \"timestamp\": \"2025-06-17 14:30:15\",",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "history_detail",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def history_detail(item_id):\n    # Заглушка данных команды (позже заменить на запрос к БД)\n    command = {\n        \"id\": item_id,\n        \"command\": \"открыть браузер\" if item_id == \"cmd-001\" else f\"команда {item_id}\",\n        \"timestamp\": \"2025-06-17 14:30:15\",\n        \"status\": \"Выполнено\",\n        \"duration\": \"2.3 сек\",\n        \"result\": f\"Команда {item_id} выполнена успешно. Браузер открыт.\",\n    }",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def settings():\n    return render_template(\"settings.html\")\n@main_bp.route(\"/logs\")\ndef logs():\n    return render_template(\"logs.html\")\n@main_bp.route(\"/help\")\ndef help():\n    return render_template(\"help.html\")\n@main_bp.route(\"/tasks\")\ndef tasks():",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "logs",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def logs():\n    return render_template(\"logs.html\")\n@main_bp.route(\"/help\")\ndef help():\n    return render_template(\"help.html\")\n@main_bp.route(\"/tasks\")\ndef tasks():\n    return render_template(\"tasks.html\")\n@main_bp.route(\"/tasks/<task_id>\")\ndef task_details(task_id):",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "help",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def help():\n    return render_template(\"help.html\")\n@main_bp.route(\"/tasks\")\ndef tasks():\n    return render_template(\"tasks.html\")\n@main_bp.route(\"/tasks/<task_id>\")\ndef task_details(task_id):\n    return render_template(\"task_details.html\", task_id=task_id)\n@main_bp.route(\"/tasks/create\", methods=[\"GET\", \"POST\"])\ndef task_create():",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "tasks",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def tasks():\n    return render_template(\"tasks.html\")\n@main_bp.route(\"/tasks/<task_id>\")\ndef task_details(task_id):\n    return render_template(\"task_details.html\", task_id=task_id)\n@main_bp.route(\"/tasks/create\", methods=[\"GET\", \"POST\"])\ndef task_create():\n    \"\"\"Страница создания новой задачи.\"\"\"\n    if request.method == \"POST\":\n        print(f\"🔍 [DEBUG] POST data: {request.form}\")",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "task_details",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def task_details(task_id):\n    return render_template(\"task_details.html\", task_id=task_id)\n@main_bp.route(\"/tasks/create\", methods=[\"GET\", \"POST\"])\ndef task_create():\n    \"\"\"Страница создания новой задачи.\"\"\"\n    if request.method == \"POST\":\n        print(f\"🔍 [DEBUG] POST data: {request.form}\")\n        print(f\"🔍 [DEBUG] Content-Type: {request.content_type}\")\n        # Имитируем создание задачи\n        import uuid",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "task_create",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def task_create():\n    \"\"\"Страница создания новой задачи.\"\"\"\n    if request.method == \"POST\":\n        print(f\"🔍 [DEBUG] POST data: {request.form}\")\n        print(f\"🔍 [DEBUG] Content-Type: {request.content_type}\")\n        # Имитируем создание задачи\n        import uuid\n        task_id = f\"task-{uuid.uuid4().hex[:8]}\"\n        print(f\"🔍 [DEBUG] POST /tasks/create - перенаправляем на /tasks/{task_id}\")\n        return redirect(f\"/tasks/{task_id}\")",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "orchestrator",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def orchestrator():\n    \"\"\"Страница оркестратора моделей.\"\"\"\n    return render_template(\"orchestrator.html\")\n@main_bp.route(\"/workflows\")\ndef workflows():\n    \"\"\"Страница шаблонов и рабочих процессов.\"\"\"\n    return render_template(\"workflows.html\")\n@main_bp.route(\"/analytics\")\ndef analytics():\n    return render_template(\"analytics.html\")",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "workflows",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def workflows():\n    \"\"\"Страница шаблонов и рабочих процессов.\"\"\"\n    return render_template(\"workflows.html\")\n@main_bp.route(\"/analytics\")\ndef analytics():\n    return render_template(\"analytics.html\")\n@main_bp.route(\"/login\")\ndef login():\n    return render_template(\"auth/login.html\")\n@main_bp.route(\"/register\")",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "analytics",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def analytics():\n    return render_template(\"analytics.html\")\n@main_bp.route(\"/login\")\ndef login():\n    return render_template(\"auth/login.html\")\n@main_bp.route(\"/register\")\ndef register():\n    return render_template(\"auth/register.html\")\n@main_bp.route(\"/admin/users\")\ndef admin_users():",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def login():\n    return render_template(\"auth/login.html\")\n@main_bp.route(\"/register\")\ndef register():\n    return render_template(\"auth/register.html\")\n@main_bp.route(\"/admin/users\")\ndef admin_users():\n    # проверка admin роли\n    return render_template(\"admin/users.html\")",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def register():\n    return render_template(\"auth/register.html\")\n@main_bp.route(\"/admin/users\")\ndef admin_users():\n    # проверка admin роли\n    return render_template(\"admin/users.html\")",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "admin_users",
        "kind": 2,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "def admin_users():\n    # проверка admin роли\n    return render_template(\"admin/users.html\")",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "main_bp",
        "kind": 5,
        "importPath": "routes.main_routes",
        "description": "routes.main_routes",
        "peekOfCode": "main_bp = Blueprint(\"main\", __name__)\n@main_bp.route(\"/\")\ndef index():\n    # Список доступных команд с иконками и описаниями\n    commands = [\n        {\n            \"main\": \"открой\",\n            \"alternatives\": [\"запусти\", \"открыть\"],\n            \"description\": \"Открывает программу или файл\",\n            \"icon\": \"folder-open\",",
        "detail": "routes.main_routes",
        "documentation": {}
    },
    {
        "label": "quick_check",
        "kind": 2,
        "importPath": "scripts.app.health_check",
        "description": "scripts.app.health_check",
        "peekOfCode": "def quick_check(url: str = \"http://localhost:5000\", timeout: int = 3) -> bool:\n    \"\"\"Быстрая проверка приложения\"\"\"\n    try:\n        response = requests.get(url, timeout=timeout)\n        if response.status_code == 200:\n            print(f\"✅ Приложение работает на {url}\")\n            return True\n        else:\n            print(f\"⚠️ Приложение отвечает с кодом {response.status_code}\")\n            return False",
        "detail": "scripts.app.health_check",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.app.health_check",
        "description": "scripts.app.health_check",
        "peekOfCode": "def main():\n    \"\"\"CLI для быстрой проверки\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Быстрая проверка приложения\")\n    parser.add_argument(\"--url\", default=\"http://localhost:5000\", help=\"URL приложения\")\n    parser.add_argument(\"--timeout\", type=int, default=3, help=\"Таймаут в секундах\")\n    args = parser.parse_args()\n    success = quick_check(args.url, args.timeout)\n    sys.exit(0 if success else 1)\nif __name__ == \"__main__\":",
        "detail": "scripts.app.health_check",
        "documentation": {}
    },
    {
        "label": "AppMode",
        "kind": 6,
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "peekOfCode": "class AppMode(Enum):\n    TESTING = \"testing\"\n    DEVELOPMENT = \"development\"\n    PRODUCTION = \"production\"\n    EXTERNAL = \"external\"\n# ✅ ИСПРАВЛЯЕМ AppConfig - добавляем недостающие атрибуты\nclass AppConfig:\n    def __init__(\n        self,\n        port: int = 5000,",
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "kind": 6,
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "peekOfCode": "class AppConfig:\n    def __init__(\n        self,\n        port: int = 5000,\n        host: str = \"127.0.0.1\",\n        mode: AppMode = AppMode.DEVELOPMENT,\n        debug: bool = False,\n        auto_cleanup: bool = True,\n        force_kill: bool = False,\n        timeout: int = 45,  # ✅ ДОБАВЛЯЕМ",
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "AppManager",
        "kind": 6,
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "peekOfCode": "class AppManager:\n    \"\"\"Универсальный менеджер приложений\"\"\"\n    def __init__(self, config: Optional[AppConfig] = None):\n        self.config = config or AppConfig()\n        self.app_url = f\"http://{self.config.host}:{self.config.port}\"\n        self.process: Optional[subprocess.Popen] = None\n        self.app_dir = Path(__file__).parent.parent.parent\n        self._start_time: Optional[float] = None\n        self._metrics: Dict[str, Any] = {}\n        # ✅ ТОЛЬКО ErrorHandler, никакого logging",
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "create_test_manager",
        "kind": 2,
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "peekOfCode": "def create_test_manager(port: int = 5000) -> AppManager:\n    \"\"\"Создает менеджер для тестирования\"\"\"\n    config = AppConfig(\n        port=port,\n        mode=AppMode.TESTING,\n        debug=True,\n        auto_cleanup=True,\n        force_kill=True,\n        timeout=45,\n    )",
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "create_external_manager",
        "kind": 2,
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "peekOfCode": "def create_external_manager(port: int = 5000) -> AppManager:\n    \"\"\"Создает менеджер для работы с внешним приложением\"\"\"\n    config = AppConfig(\n        port=port,\n        mode=AppMode.EXTERNAL,\n        debug=False,\n        auto_cleanup=False,\n        force_kill=False,\n        timeout=10,\n    )",
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "create_dev_manager",
        "kind": 2,
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "peekOfCode": "def create_dev_manager(port: int = 5000) -> AppManager:\n    \"\"\"Создает менеджер для разработки\"\"\"\n    config = AppConfig(\n        port=port,\n        mode=AppMode.DEVELOPMENT,\n        debug=True,\n        auto_cleanup=True,\n        force_kill=False,\n        timeout=30,\n    )",
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.app.manager",
        "description": "scripts.app.manager",
        "peekOfCode": "def main():\n    \"\"\"Точка входа для запуска из командной строки\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Управление приложением\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Порт приложения\")\n    parser.add_argument(\"--mode\", choices=[\"test\", \"dev\", \"external\"], default=\"dev\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Режим отладки\")\n    args = parser.parse_args()\n    # Создаем менеджер в зависимости от режима\n    if args.mode == \"test\":",
        "detail": "scripts.app.manager",
        "documentation": {}
    },
    {
        "label": "ConnectionDebugger",
        "kind": 6,
        "importPath": "scripts.network.connection_debugger",
        "description": "scripts.network.connection_debugger",
        "peekOfCode": "class ConnectionDebugger:\n    \"\"\"Отладчик TCP соединений\"\"\"\n    def __init__(self, port: int = 5000):\n        self.port = port\n        self.logs_dir = Path(\"logs\")\n        self.logs_dir.mkdir(exist_ok=True)\n    def get_connections_info(self) -> Dict[str, Any]:\n        \"\"\"Собирает информацию о соединениях на порту\"\"\"\n        connections = []\n        for conn in psutil.net_connections():",
        "detail": "scripts.network.connection_debugger",
        "documentation": {}
    },
    {
        "label": "trace_port_connections",
        "kind": 2,
        "importPath": "scripts.network.connection_debugger",
        "description": "scripts.network.connection_debugger",
        "peekOfCode": "def trace_port_connections(port: int = 5000, duration: int = 60) -> None:\n    \"\"\"Простая функция для трассировки порта\"\"\"\n    debugger = ConnectionDebugger(port)\n    debugger.trace_connections(duration, interval=2)\ndef main():\n    \"\"\"CLI для отладки соединений\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Отладка TCP соединений\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Порт для мониторинга\")\n    parser.add_argument(\"--duration\", type=int, default=300, help=\"Длительность мониторинга\")",
        "detail": "scripts.network.connection_debugger",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.network.connection_debugger",
        "description": "scripts.network.connection_debugger",
        "peekOfCode": "def main():\n    \"\"\"CLI для отладки соединений\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Отладка TCP соединений\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Порт для мониторинга\")\n    parser.add_argument(\"--duration\", type=int, default=300, help=\"Длительность мониторинга\")\n    parser.add_argument(\"--interval\", type=int, default=5, help=\"Интервал проверки\")\n    parser.add_argument(\"--once\", action=\"store_true\", help=\"Однократная проверка\")\n    args = parser.parse_args()\n    debugger = ConnectionDebugger(args.port)",
        "detail": "scripts.network.connection_debugger",
        "documentation": {}
    },
    {
        "label": "PortConfig",
        "kind": 6,
        "importPath": "scripts.network.port_manager",
        "description": "scripts.network.port_manager",
        "peekOfCode": "class PortConfig:\n    \"\"\"Конфигурация для работы с портами\"\"\"\n    port: Optional[int] = None  # ← Изменено на None для автопоиска\n    host: str = \"localhost\"\n    timeout: int = 30\n    force_kill: bool = False\n    safe_pids: List[int] = field(default_factory=lambda: [0, 4])  # Системные процессы Windows\n    port_range_start: int = 5000  # ← НОВОЕ: начало диапазона\n    port_range_size: int = 100  # ← НОВОЕ: размер диапазона\n    reserved_ports: List[int] = field(default_factory=list)  # ← НОВОЕ: зарезервированные порты",
        "detail": "scripts.network.port_manager",
        "documentation": {}
    },
    {
        "label": "PortManager",
        "kind": 6,
        "importPath": "scripts.network.port_manager",
        "description": "scripts.network.port_manager",
        "peekOfCode": "class PortManager:\n    \"\"\"Универсальный менеджер портов\"\"\"\n    def __init__(self, config: Optional[PortConfig] = None):\n        self.config = config or PortConfig()\n        # Устанавливаем переменные окружения для других компонентов\n        if self.config.port:\n            os.environ[\"MANAGED_PORT\"] = str(self.config.port)\n    @property\n    def port(self) -> int:\n        \"\"\"Текущий порт\"\"\"",
        "detail": "scripts.network.port_manager",
        "documentation": {}
    },
    {
        "label": "cleanup_port",
        "kind": 2,
        "importPath": "scripts.network.port_manager",
        "description": "scripts.network.port_manager",
        "peekOfCode": "def cleanup_port(port: int = 5000, force: bool = False) -> bool:\n    \"\"\"Функция для быстрой очистки порта\"\"\"\n    config = PortConfig(port=port, force_kill=force)\n    manager = PortManager(config)\n    return manager.smart_cleanup()\ndef cleanup_all_flask_processes() -> int:\n    \"\"\"Завершает все Flask/Python веб-процессы\"\"\"\n    killed_count = 0\n    for proc in psutil.process_iter([\"pid\", \"name\", \"cmdline\"]):\n        try:",
        "detail": "scripts.network.port_manager",
        "documentation": {}
    },
    {
        "label": "cleanup_all_flask_processes",
        "kind": 2,
        "importPath": "scripts.network.port_manager",
        "description": "scripts.network.port_manager",
        "peekOfCode": "def cleanup_all_flask_processes() -> int:\n    \"\"\"Завершает все Flask/Python веб-процессы\"\"\"\n    killed_count = 0\n    for proc in psutil.process_iter([\"pid\", \"name\", \"cmdline\"]):\n        try:\n            cmdline = \" \".join(proc.info[\"cmdline\"] or [])\n            name = proc.info[\"name\"].lower()\n            # Ищем Python веб-приложения\n            if \"python\" in name and any(\n                keyword in cmdline.lower()",
        "detail": "scripts.network.port_manager",
        "documentation": {}
    },
    {
        "label": "update_config_files",
        "kind": 2,
        "importPath": "scripts.network.port_manager",
        "description": "scripts.network.port_manager",
        "peekOfCode": "def update_config_files(new_port: int) -> List[str]:\n    \"\"\"Обновляет конфигурационные файлы с новым портом\"\"\"\n    files_to_update = {\n        \"tests/conftest.py\": [\n            (\n                r'TEST_CONFIG = {\"base_url\": \"http://localhost:\\d+\"}',\n                f'TEST_CONFIG = {{\"base_url\": \"http://localhost:{new_port}\"}}',\n            ),\n        ],\n        \"app.py\": [",
        "detail": "scripts.network.port_manager",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.network.port_manager",
        "description": "scripts.network.port_manager",
        "peekOfCode": "def main():\n    \"\"\"CLI интерфейс для менеджера портов\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Менеджер портов\")\n    parser.add_argument(\"--port\", type=int, help=\"Порт для проверки\")\n    parser.add_argument(\"--cleanup\", action=\"store_true\", help=\"Очистить порт\")\n    parser.add_argument(\"--force\", action=\"store_true\", help=\"Принудительная очистка\")\n    parser.add_argument(\"--check\", action=\"store_true\", help=\"Проверить статус порта\")\n    parser.add_argument(\"--find-free\", action=\"store_true\", help=\"Найти свободный порт\")\n    args = parser.parse_args()",
        "detail": "scripts.network.port_manager",
        "documentation": {}
    },
    {
        "label": "get_test_path_for_file",
        "kind": 2,
        "importPath": "scripts.testing.affected_tests",
        "description": "scripts.testing.affected_tests",
        "peekOfCode": "def get_test_path_for_file(changed_file: str) -> Optional[str]:\n    \"\"\"Определяет путь к тестам для измененного файла\"\"\"\n    if changed_file.startswith(\"core/\"):\n        return changed_file.replace(\"core/\", \"tests/unit/core/\")\n    elif changed_file.startswith(\"routes/\"):\n        return \"tests/integration/\"\n    elif changed_file.startswith(\"scripts/\"):\n        return \"tests/unit/\"\n    return None\ndef collect_affected_tests(changed_files: List[str]) -> Set[str]:",
        "detail": "scripts.testing.affected_tests",
        "documentation": {}
    },
    {
        "label": "collect_affected_tests",
        "kind": 2,
        "importPath": "scripts.testing.affected_tests",
        "description": "scripts.testing.affected_tests",
        "peekOfCode": "def collect_affected_tests(changed_files: List[str]) -> Set[str]:\n    \"\"\"Собирает пути тестов для измененных файлов\"\"\"\n    test_paths = set()\n    for file_path in changed_files:\n        if file_path.endswith(\".py\"):\n            test_path = get_test_path_for_file(file_path)\n            if test_path and Path(test_path).exists():\n                test_paths.add(test_path)\n    return test_paths\ndef run_affected_tests(changed_files: Optional[List[str]] = None) -> bool:",
        "detail": "scripts.testing.affected_tests",
        "documentation": {}
    },
    {
        "label": "run_affected_tests",
        "kind": 2,
        "importPath": "scripts.testing.affected_tests",
        "description": "scripts.testing.affected_tests",
        "peekOfCode": "def run_affected_tests(changed_files: Optional[List[str]] = None) -> bool:\n    \"\"\"Запускает тесты только для измененных файлов\"\"\"\n    if changed_files is None:\n        changed_files = sys.argv[1:] if len(sys.argv) > 1 else []\n    if not changed_files:\n        print(\"❌ Не указаны измененные файлы\")\n        return False\n    test_paths = collect_affected_tests(changed_files)\n    if not test_paths:\n        print(\"ℹ️ Нет тестов для измененных файлов\")",
        "detail": "scripts.testing.affected_tests",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.testing.affected_tests",
        "description": "scripts.testing.affected_tests",
        "peekOfCode": "def main():\n    \"\"\"CLI для affected tests\"\"\"\n    success = run_affected_tests()\n    sys.exit(0 if success else 1)\nif __name__ == \"__main__\":\n    main()",
        "detail": "scripts.testing.affected_tests",
        "documentation": {}
    },
    {
        "label": "BaseTestRunner",
        "kind": 6,
        "importPath": "scripts.testing.base_runner",
        "description": "scripts.testing.base_runner",
        "peekOfCode": "class BaseTestRunner(ABC):\n    \"\"\"Базовый класс для всех test runners\"\"\"\n    def __init__(self, test_type: str = \"generic\"):\n        self.test_type = test_type\n        self.session_id = f\"{test_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        self.logs_dir = Path(\"logs\")\n        self.logs_dir.mkdir(exist_ok=True)\n    @abstractmethod\n    def setup(self) -> bool:\n        \"\"\"Настройка перед запуском тестов\"\"\"",
        "detail": "scripts.testing.base_runner",
        "documentation": {}
    },
    {
        "label": "UITestMode",
        "kind": 6,
        "importPath": "scripts.testing.ui_runner",
        "description": "scripts.testing.ui_runner",
        "peekOfCode": "class UITestMode(Enum):\n    \"\"\"Режимы UI тестирования\"\"\"\n    HEADLESS = \"headless\"\n    PARALLEL = \"parallel\"\n    GENTLE = \"gentle\"\n    DIRECT = \"direct\"\n    NORMAL = \"normal\"\n@dataclass\nclass UITestConfig:\n    \"\"\"Конфигурация UI тестов\"\"\"",
        "detail": "scripts.testing.ui_runner",
        "documentation": {}
    },
    {
        "label": "UITestConfig",
        "kind": 6,
        "importPath": "scripts.testing.ui_runner",
        "description": "scripts.testing.ui_runner",
        "peekOfCode": "class UITestConfig:\n    \"\"\"Конфигурация UI тестов\"\"\"\n    mode: UITestMode = UITestMode.HEADLESS\n    parallel_workers: int = 2\n    timeout: int = 30\n    app_port: Optional[int] = None  # ← Изменили на None для автопоиска\n    headless: bool = True\n    test_path: str = \"tests/ui/e2e/\"\n    save_screenshots: bool = True\n    detailed_logging: bool = True",
        "detail": "scripts.testing.ui_runner",
        "documentation": {}
    },
    {
        "label": "UITestRunner",
        "kind": 6,
        "importPath": "scripts.testing.ui_runner",
        "description": "scripts.testing.ui_runner",
        "peekOfCode": "class UITestRunner(BaseTestRunner):\n    \"\"\"Универсальный UI Test Runner\"\"\"\n    def __init__(self, config: Optional[UITestConfig] = None):\n        super().__init__(\"ui_tests\")\n        self.config = config if config is not None else UITestConfig()\n        # Автоматический поиск свободного порта\n        if self.config.app_port is None:\n            try:\n                self.config.app_port = PortManager.find_any_free_port(\n                    5000",
        "detail": "scripts.testing.ui_runner",
        "documentation": {}
    },
    {
        "label": "create_headless_runner",
        "kind": 2,
        "importPath": "scripts.testing.ui_runner",
        "description": "scripts.testing.ui_runner",
        "peekOfCode": "def create_headless_runner(app_port: int = 5001) -> UITestRunner:\n    \"\"\"Создает headless runner\"\"\"\n    config = UITestConfig(mode=UITestMode.HEADLESS, app_port=app_port, headless=True)\n    return UITestRunner(config)\ndef create_parallel_runner(workers: int = 2, app_port: int = 5001) -> UITestRunner:\n    \"\"\"Создает параллельный runner\"\"\"\n    config = UITestConfig(\n        mode=UITestMode.PARALLEL,\n        parallel_workers=workers,\n        app_port=app_port,",
        "detail": "scripts.testing.ui_runner",
        "documentation": {}
    },
    {
        "label": "create_parallel_runner",
        "kind": 2,
        "importPath": "scripts.testing.ui_runner",
        "description": "scripts.testing.ui_runner",
        "peekOfCode": "def create_parallel_runner(workers: int = 2, app_port: int = 5001) -> UITestRunner:\n    \"\"\"Создает параллельный runner\"\"\"\n    config = UITestConfig(\n        mode=UITestMode.PARALLEL,\n        parallel_workers=workers,\n        app_port=app_port,\n        headless=True,\n        detailed_logging=True,\n    )\n    return UITestRunner(config)",
        "detail": "scripts.testing.ui_runner",
        "documentation": {}
    },
    {
        "label": "create_gentle_runner",
        "kind": 2,
        "importPath": "scripts.testing.ui_runner",
        "description": "scripts.testing.ui_runner",
        "peekOfCode": "def create_gentle_runner(app_port: int = 5001) -> UITestRunner:\n    \"\"\"Создает щадящий runner\"\"\"\n    config = UITestConfig(mode=UITestMode.GENTLE, app_port=app_port, headless=True, timeout=30)\n    return UITestRunner(config)\ndef create_direct_runner(app_port: int = 5001, headless: bool = True) -> UITestRunner:\n    \"\"\"Создает прямой runner\"\"\"\n    config = UITestConfig(\n        mode=UITestMode.DIRECT, app_port=app_port, headless=headless, use_external_app=True\n    )\n    return UITestRunner(config)",
        "detail": "scripts.testing.ui_runner",
        "documentation": {}
    },
    {
        "label": "create_direct_runner",
        "kind": 2,
        "importPath": "scripts.testing.ui_runner",
        "description": "scripts.testing.ui_runner",
        "peekOfCode": "def create_direct_runner(app_port: int = 5001, headless: bool = True) -> UITestRunner:\n    \"\"\"Создает прямой runner\"\"\"\n    config = UITestConfig(\n        mode=UITestMode.DIRECT, app_port=app_port, headless=headless, use_external_app=True\n    )\n    return UITestRunner(config)\n# === CLI ===\ndef main():\n    \"\"\"CLI для UI тестов\"\"\"\n    import argparse",
        "detail": "scripts.testing.ui_runner",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.testing.ui_runner",
        "description": "scripts.testing.ui_runner",
        "peekOfCode": "def main():\n    \"\"\"CLI для UI тестов\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"UI Test Runner\")\n    parser.add_argument(\"mode\", choices=[\"headless\", \"parallel\", \"gentle\", \"direct\", \"normal\"])\n    parser.add_argument(\"--port\", type=int, default=5001, help=\"Порт приложения\")\n    parser.add_argument(\"--workers\", type=int, default=2, help=\"Параллельные воркеры\")\n    parser.add_argument(\"--timeout\", type=int, default=30, help=\"Таймаут тестов\")\n    parser.add_argument(\n        \"--external-app\", action=\"store_true\", help=\"Использовать внешнее приложение\"",
        "detail": "scripts.testing.ui_runner",
        "documentation": {}
    },
    {
        "label": "find_python_files",
        "kind": 2,
        "importPath": "scripts.utils.analyze_dependencies",
        "description": "scripts.utils.analyze_dependencies",
        "peekOfCode": "def find_python_files(directory):\n    \"\"\"Найти все Python файлы в указанной директории рекурсивно\"\"\"\n    python_files = []\n    for root, dirs, files in os.walk(directory):\n        # Исключаем venv и __pycache__\n        if \"/venv/\" in root or \"\\\\venv\\\\\" in root or \"__pycache__\" in root:\n            continue\n        for file in files:\n            if file.endswith(\".py\"):\n                python_files.append(os.path.join(root, file))",
        "detail": "scripts.utils.analyze_dependencies",
        "documentation": {}
    },
    {
        "label": "parse_imports",
        "kind": 2,
        "importPath": "scripts.utils.analyze_dependencies",
        "description": "scripts.utils.analyze_dependencies",
        "peekOfCode": "def parse_imports(file_path):\n    \"\"\"Извлечь все импорты из Python файла\"\"\"\n    imports = []\n    with open(file_path, \"r\", encoding=\"utf-8\") as file:\n        try:\n            content = file.read()\n            # Регулярные выражения для поиска импортов\n            import_patterns = [\n                r\"^\\s*import\\s+([\\w\\.]+)(?:\\s+as\\s+\\w+)?\",\n                r\"^\\s*from\\s+([\\w\\.]+)\\s+import\\s+.+\",",
        "detail": "scripts.utils.analyze_dependencies",
        "documentation": {}
    },
    {
        "label": "analyze_dependencies",
        "kind": 2,
        "importPath": "scripts.utils.analyze_dependencies",
        "description": "scripts.utils.analyze_dependencies",
        "peekOfCode": "def analyze_dependencies(project_root):\n    \"\"\"Анализ зависимостей в проекте\"\"\"\n    python_files = find_python_files(project_root)\n    # Карта \"файл -> его импорты\"\n    file_imports = {}\n    # Карта \"модуль -> файлы, которые его импортируют\"\n    module_dependents = defaultdict(list)\n    for file_path in python_files:\n        rel_path = os.path.relpath(file_path, project_root)\n        imports = parse_imports(file_path)",
        "detail": "scripts.utils.analyze_dependencies",
        "documentation": {}
    },
    {
        "label": "find_unused_modules",
        "kind": 2,
        "importPath": "scripts.utils.analyze_dependencies",
        "description": "scripts.utils.analyze_dependencies",
        "peekOfCode": "def find_unused_modules(file_imports, module_dependents, project_root):\n    \"\"\"Найти неиспользуемые модули\"\"\"\n    python_files = find_python_files(project_root)\n    # Создаем множество всех модулей проекта\n    all_modules = set()\n    for file_path in python_files:\n        rel_path = os.path.relpath(file_path, project_root)\n        # Преобразуем путь к файлу в имя модуля\n        if rel_path.endswith(\"__init__.py\"):\n            module_name = os.path.dirname(rel_path).replace(\"/\", \".\").replace(\"\\\\\", \".\")",
        "detail": "scripts.utils.analyze_dependencies",
        "documentation": {}
    },
    {
        "label": "find_duplicated_functionality",
        "kind": 2,
        "importPath": "scripts.utils.analyze_dependencies",
        "description": "scripts.utils.analyze_dependencies",
        "peekOfCode": "def find_duplicated_functionality(project_root):\n    \"\"\"Поиск потенциально дублирующей функциональности по именам файлов\"\"\"\n    potential_duplicates = []\n    file_paths = find_python_files(project_root)\n    # Группируем файлы по их базовым именам\n    file_groups = defaultdict(list)\n    for file_path in file_paths:\n        base_name = os.path.basename(file_path).lower()\n        if base_name != \"__init__.py\":\n            file_groups[base_name].append(file_path)",
        "detail": "scripts.utils.analyze_dependencies",
        "documentation": {}
    },
    {
        "label": "run_command",
        "kind": 2,
        "importPath": "scripts.db",
        "description": "scripts.db",
        "peekOfCode": "def run_command(command, cwd=PROJECT_ROOT):\n    \"\"\"Запускает shell-команду и выводит результат\"\"\"\n    print(f\"Выполняем: {command}\")\n    process = subprocess.run(\n        command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd\n    )\n    print(process.stdout)\n    if process.returncode != 0:\n        print(f\"Ошибка: {process.stderr}\")\n        sys.exit(process.returncode)",
        "detail": "scripts.db",
        "documentation": {}
    },
    {
        "label": "run_migrations",
        "kind": 2,
        "importPath": "scripts.db",
        "description": "scripts.db",
        "peekOfCode": "def run_migrations():\n    \"\"\"Запускает миграции Alembic\"\"\"\n    run_command(\"alembic upgrade head\")\n    print(\"Миграции успешно применены!\")\ndef seed_database():\n    \"\"\"Заполняет базу данных начальными данными\"\"\"\n    # Этот скрипт должен быть создан в вашем проекте\n    run_command(\"python -m core.db.seed\")\n    print(\"База данных заполнена начальными данными!\")\nif __name__ == \"__main__\":",
        "detail": "scripts.db",
        "documentation": {}
    },
    {
        "label": "seed_database",
        "kind": 2,
        "importPath": "scripts.db",
        "description": "scripts.db",
        "peekOfCode": "def seed_database():\n    \"\"\"Заполняет базу данных начальными данными\"\"\"\n    # Этот скрипт должен быть создан в вашем проекте\n    run_command(\"python -m core.db.seed\")\n    print(\"База данных заполнена начальными данными!\")\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1:\n        command = sys.argv[1]\n        if command == \"migrate\":\n            run_migrations()",
        "detail": "scripts.db",
        "documentation": {}
    },
    {
        "label": "PROJECT_ROOT",
        "kind": 5,
        "importPath": "scripts.db",
        "description": "scripts.db",
        "peekOfCode": "PROJECT_ROOT = Path(__file__).parent.parent\ndef run_command(command, cwd=PROJECT_ROOT):\n    \"\"\"Запускает shell-команду и выводит результат\"\"\"\n    print(f\"Выполняем: {command}\")\n    process = subprocess.run(\n        command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd\n    )\n    print(process.stdout)\n    if process.returncode != 0:\n        print(f\"Ошибка: {process.stderr}\")",
        "detail": "scripts.db",
        "documentation": {}
    },
    {
        "label": "run_command",
        "kind": 2,
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "peekOfCode": "def run_command(command, cwd=PROJECT_ROOT):\n    \"\"\"Запускает shell-команду и выводит результат\"\"\"\n    print(f\"Выполняем: {command}\")\n    process = subprocess.Popen(\n        command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd\n    )\n    # Выводим вывод команды в реальном времени\n    if process.stdout:  # Проверяем, что stdout не None\n        for line in process.stdout:\n            print(line.strip())",
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "start_db",
        "kind": 2,
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "peekOfCode": "def start_db():\n    \"\"\"Запускает контейнеры базы данных\"\"\"\n    run_command(\"docker-compose up -d\")\n    print(\"База данных запущена!\")\n    print(\"pgAdmin доступен по адресу: http://localhost:5050\")\n    print(\"Данные для входа в pgAdmin: admin@example.com / admin_password\")\ndef stop_db():\n    \"\"\"Останавливает контейнеры базы данных\"\"\"\n    run_command(\"docker-compose down\")\n    print(\"База данных остановлена\")",
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "stop_db",
        "kind": 2,
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "peekOfCode": "def stop_db():\n    \"\"\"Останавливает контейнеры базы данных\"\"\"\n    run_command(\"docker-compose down\")\n    print(\"База данных остановлена\")\ndef restart_db():\n    \"\"\"Перезапускает контейнеры базы данных\"\"\"\n    stop_db()\n    start_db()\ndef show_db_logs():\n    \"\"\"Показывает логи базы данных\"\"\"",
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "restart_db",
        "kind": 2,
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "peekOfCode": "def restart_db():\n    \"\"\"Перезапускает контейнеры базы данных\"\"\"\n    stop_db()\n    start_db()\ndef show_db_logs():\n    \"\"\"Показывает логи базы данных\"\"\"\n    run_command(\"docker-compose logs -f\")\ndef main():\n    \"\"\"Главная функция для обработки аргументов командной строки.\"\"\"\n    if len(sys.argv) > 1:",
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "show_db_logs",
        "kind": 2,
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "peekOfCode": "def show_db_logs():\n    \"\"\"Показывает логи базы данных\"\"\"\n    run_command(\"docker-compose logs -f\")\ndef main():\n    \"\"\"Главная функция для обработки аргументов командной строки.\"\"\"\n    if len(sys.argv) > 1:\n        command = sys.argv[1]\n        if command == \"start\":\n            start_db()\n        elif command == \"stop\":",
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "peekOfCode": "def main():\n    \"\"\"Главная функция для обработки аргументов командной строки.\"\"\"\n    if len(sys.argv) > 1:\n        command = sys.argv[1]\n        if command == \"start\":\n            start_db()\n        elif command == \"stop\":\n            stop_db()\n        elif command == \"restart\":\n            restart_db()",
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "PROJECT_ROOT",
        "kind": 5,
        "importPath": "scripts.docker",
        "description": "scripts.docker",
        "peekOfCode": "PROJECT_ROOT = Path(__file__).parent.parent\ndef run_command(command, cwd=PROJECT_ROOT):\n    \"\"\"Запускает shell-команду и выводит результат\"\"\"\n    print(f\"Выполняем: {command}\")\n    process = subprocess.Popen(\n        command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd\n    )\n    # Выводим вывод команды в реальном времени\n    if process.stdout:  # Проверяем, что stdout не None\n        for line in process.stdout:",
        "detail": "scripts.docker",
        "documentation": {}
    },
    {
        "label": "get_ai_models",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def get_ai_models():\n    \"\"\"\n    Получает список доступных AI-моделей\n    Returns:\n        Словарь с информацией о моделях\n    \"\"\"\n    try:\n        # Проверяем существование файла с информацией о моделях\n        if not os.path.exists(MODELS_INFO_FILE):\n            # Если файла нет, создаем его с базовыми моделями",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "get_current_ai_model",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def get_current_ai_model():\n    \"\"\"\n    Получает информацию о текущей выбранной AI-модели\n    Returns:\n        Словарь с информацией о текущей модели или None\n    \"\"\"\n    try:\n        # Проверяем существование файла с информацией о моделях\n        if not os.path.exists(MODELS_INFO_FILE):\n            return None",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "check_ai_model_availability",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def check_ai_model_availability(model_id=None):\n    \"\"\"\n    Проверяет доступность нейросетей\n    Args:\n        model_id: ID конкретной модели для проверки (опционально)\n    Returns:\n        dict: Результат проверки\n    \"\"\"\n    try:\n        # Получаем список моделей",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "select_ai_model",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def select_ai_model(model_id):\n    \"\"\"\n    Выбирает AI-модель для использования\n    Args:\n        model_id: Идентификатор модели\n    Returns:\n        Словарь с результатом операции\n    \"\"\"\n    try:\n        # Получаем список моделей",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "update_model_status",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def update_model_status(model_id, status, error=None):\n    \"\"\"\n    Обновляет статус модели в файле конфигурации\n    Args:\n        model_id: Идентификатор модели\n        status: Новый статус (ready, busy, error, unavailable)\n        error: Сообщение об ошибке (если есть)\n    \"\"\"\n    try:\n        # Получаем список моделей",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "create_default_models_file",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def create_default_models_file():\n    \"\"\"\n    Создает файл с информацией о моделях по умолчанию\n    \"\"\"\n    try:\n        # Создаем директорию, если она не существует\n        os.makedirs(os.path.dirname(MODELS_INFO_FILE), exist_ok=True)\n        # Базовый список моделей\n        default_models = {\n            \"models\": [",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "generate_text",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def generate_text(prompt, max_length=100, model_id=None):\n    \"\"\"\n    Генерирует текст с использованием выбранной модели\n    Args:\n        prompt: Запрос для генерации\n        max_length: Максимальная длина генерируемого текста\n        model_id: Идентификатор модели (если None, используется текущая)\n    Returns:\n        Сгенерированный текст\n    \"\"\"",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "generate_chat_response",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def generate_chat_response(messages, max_length=1000, model_id=None):\n    \"\"\"\n    Генерирует ответ в формате чата с использованием выбранной модели\n    Args:\n        messages: Список сообщений в формате [{\"role\": \"user\", \"content\": \"...\"}, ...]\n        max_length: Максимальная длина генерируемого текста\n        model_id: Идентификатор модели (если None, используется текущая)\n    Returns:\n        Сгенерированный ответ\n    \"\"\"",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "search_models",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def search_models(query, limit=20):\n    \"\"\"\n    Поиск моделей на Hugging Face Hub\n    Args:\n        query: Поисковый запрос\n        limit: Максимальное количество результатов\n    Returns:\n        list: Список найденных моделей\n    \"\"\"\n    try:",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "add_model",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def add_model(model_data):\n    \"\"\"\n    Добавляет новую модель в список доступных\n    Args:\n        model_data: Данные о модели (id, name, description, huggingface_id, type)\n    Returns:\n        Словарь с результатом операции\n    \"\"\"\n    try:\n        # Проверяем обязательные поля",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "remove_model",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def remove_model(model_id):\n    \"\"\"\n    Удаляет модель из списка доступных\n    Args:\n        model_id: Идентификатор модели\n    Returns:\n        Словарь с результатом операции\n    \"\"\"\n    try:\n        # Получаем список моделей",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "get_ai_response",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def get_ai_response(prompt, system_message=None):\n    \"\"\"\n    Получает ответ от AI-модели\n    Args:\n        prompt: Запрос пользователя\n        system_message: Системное сообщение (опционально)\n    Returns:\n        Ответ от AI-модели\n    \"\"\"\n    try:",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "get_available_huggingface_models",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def get_available_huggingface_models(filter_criteria=None, limit=20):\n    \"\"\"\n    Получает список доступных моделей с Hugging Face Hub\n    Args:\n        filter_criteria: Критерии фильтрации моделей (опционально)\n        limit: Максимальное количество моделей для получения\n    Returns:\n        Список моделей\n    \"\"\"\n    try:",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "update_models_from_huggingface",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def update_models_from_huggingface():\n    \"\"\"\n    Обновляет список моделей, добавляя популярные модели с Hugging Face Hub\n    Returns:\n        dict: Результат операции\n    \"\"\"\n    try:\n        # Проверяем существование файла с моделями\n        if not os.path.exists(MODELS_INFO_FILE):\n            create_default_models_file()",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "save_ai_models",
        "kind": 2,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "def save_ai_models(models_data):\n    \"\"\"\n    Сохраняет информацию о моделях в файл\n    Args:\n        models_data: Данные о моделях для сохранения\n    Returns:\n        bool: Результат операции\n    \"\"\"\n    try:\n        with open(MODELS_INFO_FILE, \"w\", encoding=\"utf-8\") as f:",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n# Инициализируем сервис Hugging Face\nhf_service = HuggingFaceService()\n# Путь к файлу с информацией о моделях\nMODELS_INFO_FILE = os.path.join(Config.DATA_DIR, \"ai_models.json\")\ndef get_ai_models():\n    \"\"\"\n    Получает список доступных AI-моделей\n    Returns:\n        Словарь с информацией о моделях",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "hf_service",
        "kind": 5,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "hf_service = HuggingFaceService()\n# Путь к файлу с информацией о моделях\nMODELS_INFO_FILE = os.path.join(Config.DATA_DIR, \"ai_models.json\")\ndef get_ai_models():\n    \"\"\"\n    Получает список доступных AI-моделей\n    Returns:\n        Словарь с информацией о моделях\n    \"\"\"\n    try:",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "MODELS_INFO_FILE",
        "kind": 5,
        "importPath": "services.ai_service",
        "description": "services.ai_service",
        "peekOfCode": "MODELS_INFO_FILE = os.path.join(Config.DATA_DIR, \"ai_models.json\")\ndef get_ai_models():\n    \"\"\"\n    Получает список доступных AI-моделей\n    Returns:\n        Словарь с информацией о моделях\n    \"\"\"\n    try:\n        # Проверяем существование файла с информацией о моделях\n        if not os.path.exists(MODELS_INFO_FILE):",
        "detail": "services.ai_service",
        "documentation": {}
    },
    {
        "label": "use_browser_automation",
        "kind": 2,
        "importPath": "services.browser_service",
        "description": "services.browser_service",
        "peekOfCode": "def use_browser_automation(\n    url, prompt, css_selector_input, css_selector_response, browser_name=\"DeepSeek\"\n):\n    \"\"\"\n    Общая функция для автоматизации браузера\n    Args:\n        url: URL сервиса\n        prompt: Текст запроса\n        css_selector_input: CSS-селектор для поля ввода\n        css_selector_response: CSS-селектор для получения ответа",
        "detail": "services.browser_service",
        "documentation": {}
    },
    {
        "label": "fallback_browser_method",
        "kind": 2,
        "importPath": "services.browser_service",
        "description": "services.browser_service",
        "peekOfCode": "def fallback_browser_method(text):\n    \"\"\"Простой метод открытия браузера с запросом\"\"\"\n    prompt = f\"\"\"Напиши Python код для выполнения следующей команды на Windows: \"{text}\".\n    Используй доступные библиотеки: pyautogui, os, win32gui, win32con, pyttsx3.\"\"\"\n    # Копируем запрос в буфер обмена\n    pyperclip.copy(prompt)\n    # Сначала пробуем DeepSeek\n    webbrowser.open(\"https://chat.deepseek.com/\")\n    time.sleep(1)  # Даем время на открытие браузера\n    # Уведомляем пользователя",
        "detail": "services.browser_service",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "services.browser_service",
        "description": "services.browser_service",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\ndef use_browser_automation(\n    url, prompt, css_selector_input, css_selector_response, browser_name=\"DeepSeek\"\n):\n    \"\"\"\n    Общая функция для автоматизации браузера\n    Args:\n        url: URL сервиса\n        prompt: Текст запроса\n        css_selector_input: CSS-селектор для поля ввода",
        "detail": "services.browser_service",
        "documentation": {}
    },
    {
        "label": "is_command_feasible",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def is_command_feasible(command_text):\n    \"\"\"\n    Определяет, целесообразно ли выполнение команды\n    \"\"\"\n    # Список потенциально опасных или нецелесообразных команд\n    dangerous_keywords = [\n        \"удали\",\n        \"delete\",\n        \"format\",\n        \"форматир\",",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "process_command",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def process_command(text):\n    \"\"\"Анализ команды и генерация соответствующего кода\"\"\"\n    text = text.lower()\n    # Проверяем целесообразность выполнения команды\n    feasibility = is_command_feasible(text)\n    if not feasibility.get(\"feasible\", True):\n        return (\n            f\"Команда не может быть выполнена: {feasibility.get('reason', 'Неизвестная причина')}\",\n            None,\n        )",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "execute_python_code",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def execute_python_code(code):\n    \"\"\"Выполнить Python код и вернуть результат\"\"\"\n    # Не нужно объявлять command_interrupt_flag как global, если мы её только читаем\n    try:\n        # Импортируем все доступные команды\n        import os\n        import re\n        import time\n        # Создаем локальный словарь с разрешенными функциями\n        import pyautogui",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "execute_command_with_error_handling",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def execute_command_with_error_handling(command_text, code):\n    \"\"\"\n    Выполняет команду с обработкой ошибок, анализом и автоматическим восстановлением\n    \"\"\"\n    logger.info(f\"Начало выполнения команды: {command_text}\")\n    # Выполнение кода\n    execution_result = execute_python_code(code)\n    # Если есть функция проверки, используем её\n    if \"verify_command_execution\" in globals():\n        verification_result = verify_command_execution(code, command_text)",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "parse_compound_command",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def parse_compound_command(text):\n    \"\"\"\n    Разбирает составную команду на отдельные шаги\n    Возвращает список шагов и общее описание команды\n    \"\"\"\n    text = text.lower()\n    steps = []\n    # Ищем разделители составных команд\n    separators = [\" и \", \" затем \", \" после этого \", \" потом \", \", \"]\n    # Пытаемся разбить команду по разделителям",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "execute_command_with_steps",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def execute_command_with_steps(command_text, code=None):\n    \"\"\"\n    Выполняет команду по шагам, проверяя результат каждого шага\n    и информируя пользователя о ходе выполнения\n    \"\"\"\n    global command_interrupt_flag\n    # Сбрасываем флаг прерывания\n    command_interrupt_flag = False\n    # Разбираем команду на шаги\n    steps, full_command = parse_compound_command(command_text)",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "process_single_step",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def process_single_step(step_text):\n    \"\"\"\n    Обрабатывает отдельный шаг команды\n    Возвращает ответ и код для выполнения\n    \"\"\"\n    # Получаем функцию для выполнения шага\n    command_function = None\n    command_name = None\n    # Проверяем основные команды\n    for cmd_text in COMMANDS:",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "verify_step_execution",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def verify_step_execution(step_description, execution_result):\n    \"\"\"\n    Проверяет результат выполнения шага\n    Возвращает словарь с информацией о проверке\n    \"\"\"\n    # Не нужно объявлять command_interrupt_flag как global, если мы её только читаем\n    # Проверяем, было ли прерывание\n    if command_interrupt_flag or \"прервано пользователем\" in execution_result:\n        return {\"verified\": False, \"accuracy\": 0.0, \"message\": \"Выполнение прервано пользователем\"}\n    # Базовая проверка на наличие ошибок",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "update_execution_progress",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def update_execution_progress(execution):\n    \"\"\"\n    Обновляет общий прогресс выполнения команды\n    \"\"\"\n    # Вычисляем средний процент выполнения всех шагов\n    if execution.steps:\n        completion_sum = sum(step.completion_percentage for step in execution.steps)\n        execution.completion_percentage = completion_sum / len(execution.steps)\n        # Вычисляем среднюю точность выполнения для завершенных шагов\n        completed_steps = [step for step in execution.steps if step.status == \"completed\"]",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "try_fix_error",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def try_fix_error(step_description, error_message):\n    \"\"\"\n    Анализирует ошибку и пытается сгенерировать исправленный код\n    \"\"\"\n    detailed_logger.info(f\"Анализ ошибки: {error_message}\")\n    # Проверяем типичные ошибки и предлагаем исправления\n    if \"NameError: name\" in error_message and \"is not defined\" in error_message:\n        # Извлекаем имя неопределенной функции или переменной\n        match = re.search(r\"name '(.+)' is not defined\", error_message)\n        if match:",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "generate_calculator_code",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def generate_calculator_code(step_description):\n    \"\"\"\n    Генерирует код для работы с калькулятором на основе описания шага\n    \"\"\"\n    # Извлекаем математическое выражение из описания\n    expression = extract_math_expression(step_description)\n    if not expression:\n        return None\n    # Генерируем код для работы с калькулятором\n    code = f\"\"\"",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "calculate_with_calculator",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def calculate_with_calculator(expression):\n    # Открываем калькулятор\n    os.system(\"calc\")\n    time.sleep(1)  # Ждем открытия калькулятора\n    # Находим окно калькулятора и активируем его\n    calc_window = win32gui.FindWindow(None, \"Калькулятор\")\n    if calc_window == 0:  # Если не нашли по русскому названию\n        calc_window = win32gui.FindWindow(None, \"Calculator\")\n    if calc_window != 0:\n        # Активируем окно калькулятора",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "verify_command_execution",
        "kind": 2,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "def verify_command_execution(code, command_text):\n    \"\"\"\n    Проверяет результат выполнения команды\n    Args:\n        code: Выполненный код\n        command_text: Текст команды\n    Returns:\n        Словарь с информацией о проверке\n    \"\"\"\n    # Проверка для конкретных типов команд",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\ndetailed_logger = logging.getLogger(\"detailed_log\")\n# Глобальный флаг для прерывания выполнения команды\ncommand_interrupt_flag = False\ndef is_command_feasible(command_text):\n    \"\"\"\n    Определяет, целесообразно ли выполнение команды\n    \"\"\"\n    # Список потенциально опасных или нецелесообразных команд\n    dangerous_keywords = [",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "detailed_logger",
        "kind": 5,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "detailed_logger = logging.getLogger(\"detailed_log\")\n# Глобальный флаг для прерывания выполнения команды\ncommand_interrupt_flag = False\ndef is_command_feasible(command_text):\n    \"\"\"\n    Определяет, целесообразно ли выполнение команды\n    \"\"\"\n    # Список потенциально опасных или нецелесообразных команд\n    dangerous_keywords = [\n        \"удали\",",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "command_interrupt_flag",
        "kind": 5,
        "importPath": "services.command_service",
        "description": "services.command_service",
        "peekOfCode": "command_interrupt_flag = False\ndef is_command_feasible(command_text):\n    \"\"\"\n    Определяет, целесообразно ли выполнение команды\n    \"\"\"\n    # Список потенциально опасных или нецелесообразных команд\n    dangerous_keywords = [\n        \"удали\",\n        \"delete\",\n        \"format\",",
        "detail": "services.command_service",
        "documentation": {}
    },
    {
        "label": "HuggingFaceService",
        "kind": 6,
        "importPath": "services.huggingface_service",
        "description": "services.huggingface_service",
        "peekOfCode": "class HuggingFaceService:\n    def __init__(self):\n        self.api = HfApi()\n        self.token = os.environ.get(\"HUGGINGFACE_TOKEN\") or Config.HUGGINGFACE_TOKEN\n        self.models_cache = {}\n        self.tokenizers_cache = {}\n        # Установка токена для доступа к приватным моделям\n        if self.token:\n            HfFolder.save_token(self.token)\n            logger.info(\"Hugging Face токен установлен\")",
        "detail": "services.huggingface_service",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "services.huggingface_service",
        "description": "services.huggingface_service",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\nclass HuggingFaceService:\n    def __init__(self):\n        self.api = HfApi()\n        self.token = os.environ.get(\"HUGGINGFACE_TOKEN\") or Config.HUGGINGFACE_TOKEN\n        self.models_cache = {}\n        self.tokenizers_cache = {}\n        # Установка токена для доступа к приватным моделям\n        if self.token:\n            HfFolder.save_token(self.token)",
        "detail": "services.huggingface_service",
        "documentation": {}
    },
    {
        "label": "TestDockerScripts",
        "kind": 6,
        "importPath": "tests.infrastructure.docker.scripts.test_docker",
        "description": "tests.infrastructure.docker.scripts.test_docker",
        "peekOfCode": "class TestDockerScripts:\n    def test_run_command_success(self, mock_subprocess_popen):\n        \"\"\"Тест успешного выполнения команды\"\"\"\n        mock_popen, process_mock = mock_subprocess_popen\n        # Вызов функции\n        run_command(\"docker-compose up -d\")\n        # Проверка, что Popen был вызван с правильными аргументами\n        mock_popen.assert_called_once()\n        args, kwargs = mock_popen.call_args\n        assert \"docker-compose up -d\" in args[0]",
        "detail": "tests.infrastructure.docker.scripts.test_docker",
        "documentation": {}
    },
    {
        "label": "mock_subprocess_popen",
        "kind": 2,
        "importPath": "tests.infrastructure.docker.scripts.test_docker",
        "description": "tests.infrastructure.docker.scripts.test_docker",
        "peekOfCode": "def mock_subprocess_popen():\n    \"\"\"Фикстура для мокирования subprocess.Popen\"\"\"\n    with patch(\"subprocess.Popen\") as mock_popen:\n        # Настройка мок-объекта\n        process_mock = MagicMock()\n        process_mock.stdout = [\"Output line 1\\n\", \"Output line 2\\n\"]\n        process_mock.stderr = MagicMock()\n        process_mock.stderr.read.return_value = \"Error message\"\n        process_mock.wait.return_value = 0  # Успешное завершение по умолчанию\n        mock_popen.return_value = process_mock",
        "detail": "tests.infrastructure.docker.scripts.test_docker",
        "documentation": {}
    },
    {
        "label": "TestInputIntegration",
        "kind": 6,
        "importPath": "tests.integration.core.common.input.test_input_integration",
        "description": "tests.integration.core.common.input.test_input_integration",
        "peekOfCode": "class TestInputIntegration:\n    \"\"\"Интеграционные тесты для подсистемы ввода.\"\"\"\n    def test_keyboard_mouse_integration(self):\n        \"\"\"Тест интеграции клавиатуры и мыши.\"\"\"\n        # Импортируем необходимые компоненты\n        from core.common.input.factory import get_input_controller\n        # Патчим реальные вызовы клавиатуры и мыши для предотвращения\n        # фактического ввода во время тестирования\n        with patch(\n            \"core.platform.windows.input.keyboard.WindowsKeyboard.press_key\"",
        "detail": "tests.integration.core.common.input.test_input_integration",
        "documentation": {}
    },
    {
        "label": "TestCoreComponentsIntegration",
        "kind": 6,
        "importPath": "tests.integration.core.test_core_components_integration",
        "description": "tests.integration.core.test_core_components_integration",
        "peekOfCode": "class TestCoreComponentsIntegration:\n    \"\"\"Интеграционные тесты для проверки взаимодействия компонентов ядра системы.\"\"\"\n    def test_system_initialization_with_all_components(self, setup_core_components):\n        \"\"\"\n        Тест полной инициализации системы со всеми компонентами.\n        \"\"\"\n        components = setup_core_components\n        registry = components[\"registry\"]\n        system_initializer = components[\"system_initializer\"]\n        # Создаем и регистрируем тестовый компонент",
        "detail": "tests.integration.core.test_core_components_integration",
        "documentation": {}
    },
    {
        "label": "TestPlugin",
        "kind": 6,
        "importPath": "tests.integration.core.test_core_components_integration",
        "description": "tests.integration.core.test_core_components_integration",
        "peekOfCode": "class TestPlugin:\n    def __init__(self):\n        self.initialized = False\n    def setup(self):\n        self.initialized = True\n        return True\n\"\"\"\n            plugin_path = os.path.join(temp_dir, \"test_plugin.py\")\n            with open(plugin_path, \"w\") as f:\n                f.write(plugin_code)",
        "detail": "tests.integration.core.test_core_components_integration",
        "documentation": {}
    },
    {
        "label": "setup_core_components",
        "kind": 2,
        "importPath": "tests.integration.core.test_core_components_integration",
        "description": "tests.integration.core.test_core_components_integration",
        "peekOfCode": "def setup_core_components():\n    \"\"\"\n    Создает и настраивает основные компоненты ядра для тестирования.\n    \"\"\"\n    # Создаем компоненты\n    registry = ComponentRegistry()\n    error_handler = ErrorHandler()\n    # СНАЧАЛА регистрируем ErrorHandler\n    registry.register(\"error_handler\", error_handler)\n    # ПОТОМ создаем PluginManager (который ищет error_handler в конструкторе)",
        "detail": "tests.integration.core.test_core_components_integration",
        "documentation": {}
    },
    {
        "label": "TestPluginSystemIntegration",
        "kind": 6,
        "importPath": "tests.integration.core.test_plugin_system_integration",
        "description": "tests.integration.core.test_plugin_system_integration",
        "peekOfCode": "class TestPluginSystemIntegration:\n    \"\"\"Интеграционные тесты для проверки взаимодействия системы плагинов с другими компонентами.\"\"\"\n    @pytest.fixture\n    def setup_plugin_system(self):\n        \"\"\"\n        Создает и настраивает компоненты для тестирования системы плагинов.\n        \"\"\"\n        # Создаем компоненты\n        registry = ComponentRegistry()\n        error_handler = ErrorHandler()",
        "detail": "tests.integration.core.test_plugin_system_integration",
        "documentation": {}
    },
    {
        "label": "TestPlugin",
        "kind": 6,
        "importPath": "tests.integration.core.test_plugin_system_integration",
        "description": "tests.integration.core.test_plugin_system_integration",
        "peekOfCode": "class TestPlugin:\n    def __init__(self):\n        self.initialized = False\n        self.registry = None\n    def setup(self):\n        self.initialized = True\n        return True\n\"\"\"\n        self.create_test_plugin(temp_dir, \"test_plugin\", plugin_code)\n        # Загружаем плагин",
        "detail": "tests.integration.core.test_plugin_system_integration",
        "documentation": {}
    },
    {
        "label": "RegistryPlugin",
        "kind": 6,
        "importPath": "tests.integration.core.test_plugin_system_integration",
        "description": "tests.integration.core.test_plugin_system_integration",
        "peekOfCode": "class RegistryPlugin:\n    def __init__(self):\n        self.registry = None\n        self.error_handler = None\n    def setup(self):\n        # Ничего не делаем в setup\n        pass\n    def integrate(self, registry):\n        self.registry = registry\n        self.error_handler = registry.get(\"error_handler\")",
        "detail": "tests.integration.core.test_plugin_system_integration",
        "documentation": {}
    },
    {
        "label": "BrokenPlugin",
        "kind": 6,
        "importPath": "tests.integration.core.test_plugin_system_integration",
        "description": "tests.integration.core.test_plugin_system_integration",
        "peekOfCode": "class BrokenPlugin:\n    def __init__(self):\n        self.initialized = False\n    def setup(self):\n        raise Exception(\"Test error in plugin setup\")\n\"\"\"\n        self.create_test_plugin(temp_dir, \"broken_plugin\", plugin_code)\n        # Патчим метод handle_error для перехвата вызовов\n        with patch.object(error_handler, \"handle_error\") as mock_handle_error:\n            # Загружаем плагин с ошибкой",
        "detail": "tests.integration.core.test_plugin_system_integration",
        "documentation": {}
    },
    {
        "label": "Plugin1",
        "kind": 6,
        "importPath": "tests.integration.core.test_plugin_system_integration",
        "description": "tests.integration.core.test_plugin_system_integration",
        "peekOfCode": "class Plugin1:\n    def __init__(self):\n        self.name = \"Plugin1\"\n    def setup(self):\n        pass\n\"\"\"\n        plugin2_code = \"\"\"\nclass Plugin2:\n    def __init__(self):\n        self.name = \"Plugin2\"",
        "detail": "tests.integration.core.test_plugin_system_integration",
        "documentation": {}
    },
    {
        "label": "Plugin2",
        "kind": 6,
        "importPath": "tests.integration.core.test_plugin_system_integration",
        "description": "tests.integration.core.test_plugin_system_integration",
        "peekOfCode": "class Plugin2:\n    def __init__(self):\n        self.name = \"Plugin2\"\n    def setup(self):\n        pass\n\"\"\"\n        self.create_test_plugin(temp_dir, \"plugin1\", plugin1_code)\n        self.create_test_plugin(temp_dir, \"plugin2\", plugin2_code)\n        # Обнаруживаем плагины\n        discovered_plugins = plugin_manager.discover_plugins()",
        "detail": "tests.integration.core.test_plugin_system_integration",
        "documentation": {}
    },
    {
        "label": "UnloadablePlugin",
        "kind": 6,
        "importPath": "tests.integration.core.test_plugin_system_integration",
        "description": "tests.integration.core.test_plugin_system_integration",
        "peekOfCode": "class UnloadablePlugin:\n    def __init__(self):\n        self.torn_down = False\n    def setup(self):\n        pass\n    def teardown(self):\n        self.torn_down = True\n\"\"\"\n        self.create_test_plugin(temp_dir, \"unloadable_plugin\", plugin_code)\n        # Загружаем плагин",
        "detail": "tests.integration.core.test_plugin_system_integration",
        "documentation": {}
    },
    {
        "label": "LLMApiClient",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class LLMApiClient:\n    def __init__(self, api_key=None, base_url=None):\n        self.api_key = api_key or \"test_api_key\"\n        self.base_url = base_url or \"https://api.example.com/v1\"\n        self.session = requests.Session()\n    def connect(self):\n        return True\n    def send_request(self, prompt, options=None):\n        # Имитация ответа от API\n        return {",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "PromptProcessor",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class PromptProcessor:\n    def __init__(self):\n        self.templates = {}\n    def add_template(self, name, template):\n        self.templates[name] = template\n        return True\n    def process_prompt(self, template_name, variables=None):\n        if template_name not in self.templates:\n            raise ValueError(f\"Template {template_name} not found\")\n        template = self.templates[template_name]",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "ResponseParser",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class ResponseParser:\n    def parse_response(self, response):\n        if \"choices\" in response and len(response[\"choices\"]) > 0:\n            return response[\"choices\"][0][\"text\"]\n        return None\n    def extract_json(self, text):\n        try:\n            # Ищем JSON в тексте между фигурными скобками\n            start = text.find(\"{\")\n            end = text.rfind(\"}\") + 1",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "ActionPlanner",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class ActionPlanner:\n    def __init__(self, llm_client, prompt_processor, response_parser):\n        self.llm_client = llm_client\n        self.prompt_processor = prompt_processor\n        self.response_parser = response_parser\n    def plan_actions(self, user_request):\n        # Создаем промпт для планирования действий\n        prompt = self.prompt_processor.process_prompt(\n            \"action_planning\", {\"user_request\": user_request}\n        )",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "LLMErrorHandler",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class LLMErrorHandler:\n    def handle_api_error(self, error):\n        error_type = type(error).__name__\n        error_message = str(error)\n        if isinstance(error, requests.exceptions.ConnectionError):\n            return {\"error\": \"connection_error\", \"message\": error_message}\n        elif isinstance(error, requests.exceptions.Timeout):\n            return {\"error\": \"timeout_error\", \"message\": error_message}\n        elif isinstance(error, requests.exceptions.RequestException):\n            return {\"error\": \"request_error\", \"message\": error_message}",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "TestLLMApiConnection",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class TestLLMApiConnection:\n    \"\"\"Тесты подключения к LLM API\"\"\"\n    def test_successful_connection(self):\n        \"\"\"Тест успешного подключения к API\"\"\"\n        # Используем мок вместо реального объекта для ускорения теста\n        client = MagicMock()\n        client.connect.return_value = True\n        result = client.connect()\n        assert result is True\n    @patch(\"requests.Session.get\")",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "TestPromptProcessing",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class TestPromptProcessing:\n    \"\"\"Тесты обработки промптов\"\"\"\n    def test_add_template(self):\n        \"\"\"Тест добавления шаблона промпта\"\"\"\n        processor = PromptProcessor()\n        template = \"Hello, {name}! How can I help you today?\"\n        result = processor.add_template(\"greeting\", template)\n        assert result is True\n        assert \"greeting\" in processor.templates\n        assert processor.templates[\"greeting\"] == template",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "TestResponseParsing",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class TestResponseParsing:\n    \"\"\"Тесты парсинга ответов модели\"\"\"\n    def test_parse_simple_response(self):\n        \"\"\"Тест парсинга простого ответа\"\"\"\n        parser = ResponseParser()\n        response = {\n            \"id\": \"test-id\",\n            \"choices\": [{\"text\": \"This is a test response\", \"finish_reason\": \"stop\"}],\n        }\n        result = parser.parse_response(response)",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "TestActionPlanning",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class TestActionPlanning:\n    \"\"\"Тесты планирования действий на основе запросов\"\"\"\n    def test_plan_actions(self):\n        \"\"\"Тест планирования действий на основе запроса пользователя\"\"\"\n        # Создаем моки для зависимостей\n        llm_client = MagicMock()\n        llm_client.send_request.return_value = {\"choices\": [{\"text\": \"\"\"\n                    I'll help you install Python. Here's a plan:\n                    {\n                        \"actions\": [",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "TestLLMErrorHandling",
        "kind": 6,
        "importPath": "tests.integration.llm_integration.test_llm_unit",
        "description": "tests.integration.llm_integration.test_llm_unit",
        "peekOfCode": "class TestLLMErrorHandling:\n    \"\"\"Тесты обработки ошибок API\"\"\"\n    def test_handle_connection_error(self):\n        \"\"\"Тест обработки ошибки соединения\"\"\"\n        handler = LLMErrorHandler()\n        # Создаем объект исключения вместо вызова реального исключения\n        error = requests.exceptions.ConnectionError(\"Failed to establish connection\")\n        result = handler.handle_api_error(error)\n        assert result[\"error\"] == \"connection_error\"\n        assert \"Failed to establish connection\" in result[\"message\"]",
        "detail": "tests.integration.llm_integration.test_llm_unit",
        "documentation": {}
    },
    {
        "label": "TestUserService",
        "kind": 6,
        "importPath": "tests.integration.test_db_services",
        "description": "tests.integration.test_db_services",
        "peekOfCode": "class TestUserService:\n    def test_user_registration(self, db_session):\n        \"\"\"Тест интеграции сервиса регистрации пользователей с БД\"\"\"\n        user_service = UserService(db_session)\n        user_data = {\n            \"username\": \"integration_user\",\n            \"email\": \"integration@example.com\",\n            \"password\": \"secure_password123\",\n        }\n        # Регистрируем пользователя",
        "detail": "tests.integration.test_db_services",
        "documentation": {}
    },
    {
        "label": "TestTaskService",
        "kind": 6,
        "importPath": "tests.integration.test_db_services",
        "description": "tests.integration.test_db_services",
        "peekOfCode": "class TestTaskService:\n    @pytest.fixture\n    def test_user(self, db_session):\n        \"\"\"Создает тестового пользователя для сервиса задач\"\"\"\n        user_service = UserService(db_session)\n        return user_service.register_user(\n            username=\"task_service_user\", email=\"task_service@example.com\", password=\"password\"\n        )\n    def test_task_creation_and_retrieval(self, db_session, test_user):\n        \"\"\"Тест создания и получения задач через сервис\"\"\"",
        "detail": "tests.integration.test_db_services",
        "documentation": {}
    },
    {
        "label": "TestAIModelService",
        "kind": 6,
        "importPath": "tests.integration.test_db_services",
        "description": "tests.integration.test_db_services",
        "peekOfCode": "class TestAIModelService:\n    def test_model_registration_and_usage(self, db_session):\n        \"\"\"Тест регистрации и использования моделей ИИ\"\"\"\n        ai_service = AIModelService(db_session)\n        # Регистрируем модель\n        model = ai_service.register_model(\n            name=\"GPT-3.5-Turbo\",\n            provider=\"OpenAI\",\n            is_api=True,\n            base_url=\"https://api.openai.com/v1\",",
        "detail": "tests.integration.test_db_services",
        "documentation": {}
    },
    {
        "label": "test_auth_api_integration",
        "kind": 2,
        "importPath": "tests.integration.test_system_initializer_auth",
        "description": "tests.integration.test_system_initializer_auth",
        "peekOfCode": "def test_auth_api_integration(app_client):\n    \"\"\"Тест API авторизации через прямые HTTP запросы\"\"\"\n    # ✅ Генерируем уникальные данные для каждого теста\n    unique_id = str(uuid.uuid4())[:8]\n    # 1. Тест регистрации\n    register_data = {\n        \"username\": f\"test_user_{unique_id}\",\n        \"email\": f\"test_{unique_id}@example.com\",\n        \"password\": \"password123\",\n        \"display_name\": f\"Test User {unique_id}\",",
        "detail": "tests.integration.test_system_initializer_auth",
        "documentation": {}
    },
    {
        "label": "test_auth_validation_errors",
        "kind": 2,
        "importPath": "tests.integration.test_system_initializer_auth",
        "description": "tests.integration.test_system_initializer_auth",
        "peekOfCode": "def test_auth_validation_errors(app_client):\n    \"\"\"Тест валидации данных при регистрации/входе\"\"\"\n    # Тест регистрации с неполными данными\n    invalid_data = {\"username\": \"ab\"}  # слишком короткое имя\n    response = app_client.post(\n        \"/api/auth/register\", data=json.dumps(invalid_data), content_type=\"application/json\"\n    )\n    assert response.status_code == 400\n    result = response.get_json()\n    assert result[\"success\"] is False",
        "detail": "tests.integration.test_system_initializer_auth",
        "documentation": {}
    },
    {
        "label": "test_user_authentication",
        "kind": 2,
        "importPath": "tests.integration.test_system_initializer_auth",
        "description": "tests.integration.test_system_initializer_auth",
        "peekOfCode": "def test_user_authentication():\n    \"\"\"Проверяет инициализацию системы авторизации.\"\"\"\n    system_initializer = SystemInitializer()\n    system = system_initializer.initialize()\n    # Проверяем что система инициализирована\n    if not system:\n        pytest.skip(\"Система не инициализирована корректно\")\n    # Проверяем что компоненты авторизации доступны\n    assert hasattr(system, \"create_task\")\n    # Простая проверка что система работает",
        "detail": "tests.integration.test_system_initializer_auth",
        "documentation": {}
    },
    {
        "label": "TestApplicationWorkflow",
        "kind": 6,
        "importPath": "tests.system.test_application_workflow",
        "description": "tests.system.test_application_workflow",
        "peekOfCode": "class TestApplicationWorkflow:\n    def test_basic_application_flow(self):\n        \"\"\"\n        Проверяет базовый рабочий процесс приложения от запуска до выполнения простой задачи.\n        Этот тест будет изначально не проходить и поможет определить, что нужно реализовать.\n        \"\"\"\n        # Инициализация системы\n        system_initializer = SystemInitializer()\n        system = system_initializer.initialize()\n        # Проверяем, что система успешно инициализирована",
        "detail": "tests.system.test_application_workflow",
        "documentation": {}
    },
    {
        "label": "TestComputerVision",
        "kind": 6,
        "importPath": "tests.system.test_computer_vision",
        "description": "tests.system.test_computer_vision",
        "peekOfCode": "class TestComputerVision:\n    def test_screen_capture_and_analysis(self):\n        \"\"\"Проверяет функциональность компьютерного зрения: захват экрана и распознавание элементов.\"\"\"\n        system_initializer = SystemInitializer()\n        system = system_initializer.initialize()\n        assert system is not False, \"Не удалось инициализировать систему\"\n        # Создание задачи для захвата экрана\n        task = system.create_task(\"Сделать снимок экрана и найти иконку проводника\")\n        result = task.execute()\n        assert result.success",
        "detail": "tests.system.test_computer_vision",
        "documentation": {}
    },
    {
        "label": "TestFileOperations",
        "kind": 6,
        "importPath": "tests.system.test_file_operations",
        "description": "tests.system.test_file_operations",
        "peekOfCode": "class TestFileOperations:\n    def test_file_operations_workflow(self):\n        \"\"\"Проверяет работу с файловой системой: создание, чтение, запись, удаление файлов.\"\"\"\n        # Инициализация системы\n        system_initializer = SystemInitializer()\n        system = system_initializer.initialize()\n        assert system is not False, \"Не удалось инициализировать систему\"\n        # Создание задачи для работы с файлами\n        task = system.create_task(\"Создать файл test.txt с текстом 'Hello World'\")\n        result = task.execute()",
        "detail": "tests.system.test_file_operations",
        "documentation": {}
    },
    {
        "label": "TestLLMIntegration",
        "kind": 6,
        "importPath": "tests.system.test_llm_integration",
        "description": "tests.system.test_llm_integration",
        "peekOfCode": "class TestLLMIntegration:\n    def test_llm_basic_interaction(self):\n        \"\"\"Проверяет базовое взаимодействие с языковыми моделями.\"\"\"\n        system_initializer = SystemInitializer()\n        system = system_initializer.initialize()\n        assert system is not False, \"Не удалось инициализировать систему\"\n        # Создание задачи для LLM\n        task = system.create_task(\"Сгенерировать короткое стихотворение о программировании\")\n        result = task.execute()\n        assert result.success",
        "detail": "tests.system.test_llm_integration",
        "documentation": {}
    },
    {
        "label": "TestModelOrchestration",
        "kind": 6,
        "importPath": "tests.system.test_model_orchestration",
        "description": "tests.system.test_model_orchestration",
        "peekOfCode": "class TestModelOrchestration:\n    def test_multi_model_workflow(self):\n        \"\"\"Проверяет оркестрацию нескольких моделей для решения комплексной задачи.\"\"\"\n        system_initializer = SystemInitializer()\n        system = system_initializer.initialize()\n        assert system is not False, \"Не удалось инициализировать систему\"\n        # Задача, требующая координации нескольких моделей\n        task = system.create_task(\n            \"Найти на рабочем столе документ с текстом, проанализировать его содержимое с помощью\"\n            \" LLM и сохранить результат в новый файл\"",
        "detail": "tests.system.test_model_orchestration",
        "documentation": {}
    },
    {
        "label": "TestPluginSystem",
        "kind": 6,
        "importPath": "tests.system.test_plugin_system",
        "description": "tests.system.test_plugin_system",
        "peekOfCode": "class TestPluginSystem:\n    def test_plugin_loading_and_execution(self):\n        \"\"\"Проверяет загрузку и выполнение плагинов.\"\"\"\n        system_initializer = SystemInitializer()\n        system = system_initializer.initialize()\n        assert system is not False, \"Не удалось инициализировать систему\"\n        # Получение списка плагинов\n        plugins = system.get_plugin_manager().get_loaded_plugins()\n        if plugins:\n            # Если есть хотя бы один плагин, проверяем его",
        "detail": "tests.system.test_plugin_system",
        "documentation": {}
    },
    {
        "label": "TestTaskManagement",
        "kind": 6,
        "importPath": "tests.system.test_task_management",
        "description": "tests.system.test_task_management",
        "peekOfCode": "class TestTaskManagement:\n    def test_task_lifecycle(self):\n        \"\"\"Проверяет полный жизненный цикл задачи: создание, выполнение, сохранение в истории.\"\"\"\n        system_initializer = SystemInitializer()\n        system = system_initializer.initialize()\n        assert system is not False, \"Не удалось инициализировать систему\"\n        # Создание задачи\n        task = system.create_task(\"Тестовая задача для проверки жизненного цикла\")\n        # Сохранение и получение задачи из базы данных\n        task_id = system.task_manager.save_task(task)",
        "detail": "tests.system.test_task_management",
        "documentation": {}
    },
    {
        "label": "TestWebAutomation",
        "kind": 6,
        "importPath": "tests.system.test_web_automation",
        "description": "tests.system.test_web_automation",
        "peekOfCode": "class TestWebAutomation:\n    def test_web_search_automation(self):\n        \"\"\"Проверяет автоматизацию веб-поиска с обработкой защиты от ботов.\"\"\"\n        system_initializer = SystemInitializer()\n        system = system_initializer.initialize()\n        assert system is not False, \"Не удалось инициализировать систему\"\n        # Создание задачи для веб-поиска\n        task = system.create_task(\n            \"Открыть браузер, найти в поисковике 'Python TDD' и сохранить первые 3 результата\"\n        )",
        "detail": "tests.system.test_web_automation",
        "documentation": {}
    },
    {
        "label": "TestWindowsAutomation",
        "kind": 6,
        "importPath": "tests.system.test_windows_automation",
        "description": "tests.system.test_windows_automation",
        "peekOfCode": "class TestWindowsAutomation:\n    def test_windows_application_automation(self):\n        \"\"\"Проверяет автоматизацию работы с приложениями Windows.\"\"\"\n        system_initializer = SystemInitializer()\n        system = system_initializer.initialize()\n        assert system is not False, \"Не удалось инициализировать систему\"\n        # Создание задачи для работы с калькулятором\n        task = system.create_task(\"Открыть калькулятор, выполнить операцию 2+2 и вернуть результат\")\n        result = task.execute()\n        assert result.success",
        "detail": "tests.system.test_windows_automation",
        "documentation": {}
    },
    {
        "label": "TestAccessibility",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_accessibility",
        "description": "tests.ui.e2e.ui.test_accessibility",
        "peekOfCode": "class TestAccessibility:\n    # ❌ УДАЛИТЬ эту фикстуру - она конфликтует с conftest.py\n    # @pytest.fixture(scope=\"function\")\n    # def driver(self):\n    #     driver = webdriver.Chrome()\n    #     driver.maximize_window()\n    #     yield driver\n    #     driver.quit()\n    def test_keyboard_navigation(self, ui_client, base_url):\n        \"\"\"Тест навигации по интерфейсу с помощью клавиатуры\"\"\"",
        "detail": "tests.ui.e2e.ui.test_accessibility",
        "documentation": {}
    },
    {
        "label": "TestAIModels",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_ai_models",
        "description": "tests.ui.e2e.ui.test_ai_models",
        "peekOfCode": "class TestAIModels:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_ai_models_container_elements(self, driver, base_url):\n        \"\"\"Тест наличия всех элементов контейнера моделей ИИ\"\"\"\n        driver.get(base_url)",
        "detail": "tests.ui.e2e.ui.test_ai_models",
        "documentation": {}
    },
    {
        "label": "TestAnimations",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_animations",
        "description": "tests.ui.e2e.ui.test_animations",
        "peekOfCode": "class TestAnimations:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_modal_animations(self, driver, base_url):\n        \"\"\"Тест анимаций модальных окон\"\"\"\n        driver.get(base_url)",
        "detail": "tests.ui.e2e.ui.test_animations",
        "documentation": {}
    },
    {
        "label": "TestAPIIntegration",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_api_integration",
        "description": "tests.ui.e2e.ui.test_api_integration",
        "peekOfCode": "class TestAPIIntegration:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_command_submission_api_call(self, driver, base_url):\n        \"\"\"Тест отправки команды через API\"\"\"\n        driver.get(base_url)",
        "detail": "tests.ui.e2e.ui.test_api_integration",
        "documentation": {}
    },
    {
        "label": "TestBaseLayout",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_base_layout",
        "description": "tests.ui.e2e.ui.test_base_layout",
        "peekOfCode": "class TestBaseLayout:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        # Инициализация драйвера\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_header_elements(self, driver, base_url):\n        \"\"\"Тест наличия и корректности элементов заголовка\"\"\"",
        "detail": "tests.ui.e2e.ui.test_base_layout",
        "documentation": {}
    },
    {
        "label": "TestCommandForm",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_command_form",
        "description": "tests.ui.e2e.ui.test_command_form",
        "peekOfCode": "class TestCommandForm:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_command_form_elements(self, driver, base_url):\n        \"\"\"Тест наличия всех элементов формы команд\"\"\"\n        driver.get(base_url)",
        "detail": "tests.ui.e2e.ui.test_command_form",
        "documentation": {}
    },
    {
        "label": "TestCommandHistory",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_command_history",
        "description": "tests.ui.e2e.ui.test_command_history",
        "peekOfCode": "class TestCommandHistory:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_history_container_elements(self, driver, base_url):\n        \"\"\"Тест наличия всех элементов контейнера истории команд\"\"\"\n        driver.get(base_url)",
        "detail": "tests.ui.e2e.ui.test_command_history",
        "documentation": {}
    },
    {
        "label": "TestLogsDisplay",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_logs_display",
        "description": "tests.ui.e2e.ui.test_logs_display",
        "peekOfCode": "class TestLogsDisplay:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_logs_page_structure(self, driver, base_url):\n        \"\"\"Тест структуры страницы логов\"\"\"\n        # Переходим на страницу логов",
        "detail": "tests.ui.e2e.ui.test_logs_display",
        "documentation": {}
    },
    {
        "label": "TestMobileUI",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_mobile_ui",
        "description": "tests.ui.e2e.ui.test_mobile_ui",
        "peekOfCode": "class TestMobileUI:\n    @pytest.fixture(scope=\"function\")\n    def mobile_driver(self):\n        # Настройка мобильной эмуляции\n        mobile_emulation = {\"deviceName\": \"iPhone X\"}\n        chrome_options = webdriver.ChromeOptions()\n        chrome_options.add_experimental_option(\"mobileEmulation\", mobile_emulation)\n        driver = webdriver.Chrome(options=chrome_options)\n        yield driver\n        driver.quit()",
        "detail": "tests.ui.e2e.ui.test_mobile_ui",
        "documentation": {}
    },
    {
        "label": "TestModals",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_modals",
        "description": "tests.ui.e2e.ui.test_modals",
        "peekOfCode": "class TestModals:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_confirm_modal_structure(self, driver, base_url):\n        \"\"\"Тест структуры модального окна подтверждения\"\"\"\n        driver.get(base_url)",
        "detail": "tests.ui.e2e.ui.test_modals",
        "documentation": {}
    },
    {
        "label": "TestNavigation",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_navigation",
        "description": "tests.ui.e2e.ui.test_navigation",
        "peekOfCode": "class TestNavigation:\n    \"\"\"Тесты для навигационных элементов и переходов между страницами.\"\"\"\n    def test_main_navigation_links(self, ui_client, base_url):\n        \"\"\"Тест основных навигационных ссылок.\"\"\"\n        # Открываем главную страницу\n        ui_client.get(f\"{base_url}/\")\n        # Находим все основные навигационные ссылки\n        nav_links = ui_client.find_elements(By.CSS_SELECTOR, \"nav a\")\n        # Проверяем наличие ожидаемых ссылок\n        expected_links = [\"Модели\", \"История\", \"Настройки\", \"Помощь\"]",
        "detail": "tests.ui.e2e.ui.test_navigation",
        "documentation": {}
    },
    {
        "label": "TestResponsiveDesign",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_responsive",
        "description": "tests.ui.e2e.ui.test_responsive",
        "peekOfCode": "class TestResponsiveDesign:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        # Начинаем с большого размера окна\n        driver.set_window_size(1200, 800)\n        yield driver\n        driver.quit()\n    def test_desktop_layout(self, driver, base_url):\n        \"\"\"Тест макета для настольных компьютеров\"\"\"",
        "detail": "tests.ui.e2e.ui.test_responsive",
        "documentation": {}
    },
    {
        "label": "TestRouting",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_routing",
        "description": "tests.ui.e2e.ui.test_routing",
        "peekOfCode": "class TestRouting:\n    \"\"\"Тесты маршрутизации и взаимодействия с URL.\"\"\"\n    def test_model_selection_routing(self, ui_client, base_url):\n        \"\"\"Тест маршрутизации при выборе модели.\"\"\"\n        # ✅ Теперь URL корректный\n        ui_client.get(f\"{base_url}/models\")\n        # ✅ ИСПРАВЛЕНО: Правильный селектор\n        WebDriverWait(ui_client, 10).until(\n            EC.presence_of_element_located((By.CSS_SELECTOR, \".ai-model-item\"))\n        )",
        "detail": "tests.ui.e2e.ui.test_routing",
        "documentation": {}
    },
    {
        "label": "TestSettings",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_settings",
        "description": "tests.ui.e2e.ui.test_settings",
        "peekOfCode": "class TestSettings:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_models_settings(self, driver, base_url):\n        \"\"\"Тест настроек нейросетей\"\"\"\n        driver.get(f\"{base_url}/models\")",
        "detail": "tests.ui.e2e.ui.test_settings",
        "documentation": {}
    },
    {
        "label": "TestThemeSystem",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_theme_system",
        "description": "tests.ui.e2e.ui.test_theme_system",
        "peekOfCode": "class TestThemeSystem:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_theme_toggle_presence(self, driver, base_url):\n        \"\"\"Тест наличия переключателя темы\"\"\"\n        driver.get(base_url)",
        "detail": "tests.ui.e2e.ui.test_theme_system",
        "documentation": {}
    },
    {
        "label": "TestErrorHandling",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_ui_error_handling",
        "description": "tests.ui.e2e.ui.test_ui_error_handling",
        "peekOfCode": "class TestErrorHandling:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_empty_command_handling(self, driver, base_url):\n        \"\"\"Тест обработки пустой команды\"\"\"\n        driver.get(base_url)",
        "detail": "tests.ui.e2e.ui.test_ui_error_handling",
        "documentation": {}
    },
    {
        "label": "TestPerformance",
        "kind": 6,
        "importPath": "tests.ui.e2e.ui.test_ui_performance",
        "description": "tests.ui.e2e.ui.test_ui_performance",
        "peekOfCode": "class TestPerformance:\n    @pytest.fixture(scope=\"function\")\n    def driver(self):\n        driver = webdriver.Chrome()\n        driver.maximize_window()\n        yield driver\n        driver.quit()\n    def test_page_load_time(self, driver, base_url):\n        \"\"\"Тест времени загрузки страницы\"\"\"\n        # Измеряем время загрузки страницы",
        "detail": "tests.ui.e2e.ui.test_ui_performance",
        "documentation": {}
    },
    {
        "label": "TestSimpleUI",
        "kind": 6,
        "importPath": "tests.ui.e2e.simple_ui_test",
        "description": "tests.ui.e2e.simple_ui_test",
        "peekOfCode": "class TestSimpleUI:\n    def test_homepage_opens(self, ui_client, base_url):\n        \"\"\"Простейший тест - открытие главной страницы\"\"\"\n        print(\"🔍 Открываем главную страницу...\")\n        ui_client.get(base_url)\n        print(\"🔍 Получаем заголовок...\")\n        title = ui_client.driver.title\n        print(f\"📋 Заголовок: {title}\")\n        assert title is not None\n        assert len(title) > 0",
        "detail": "tests.ui.e2e.simple_ui_test",
        "documentation": {}
    },
    {
        "label": "IComponentRegistry",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class IComponentRegistry:\n    def register(self, name: str, component: Any) -> bool: ...  # noqa: E704\n    def get(self, name: str) -> Any: ...  # noqa: E704\nclass ISystemInitializer:\n    def initialize(self) -> bool: ...  # noqa: E704\n    def shutdown(self) -> bool: ...  # noqa: E704\n    def is_initialized(self) -> bool: ...  # noqa: E704\nclass IErrorHandler:\n    def handle_error(  # noqa: E704\n        self, error: Exception, context: Optional[Dict[str, Any]] = None  # noqa: E704",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "ISystemInitializer",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class ISystemInitializer:\n    def initialize(self) -> bool: ...  # noqa: E704\n    def shutdown(self) -> bool: ...  # noqa: E704\n    def is_initialized(self) -> bool: ...  # noqa: E704\nclass IErrorHandler:\n    def handle_error(  # noqa: E704\n        self, error: Exception, context: Optional[Dict[str, Any]] = None  # noqa: E704\n    ) -> bool: ...  # noqa: E704\n    def handle_warning(  # noqa: E704\n        self, message: str, context: Optional[Dict[str, Any]] = None  # noqa: E704",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "IErrorHandler",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class IErrorHandler:\n    def handle_error(  # noqa: E704\n        self, error: Exception, context: Optional[Dict[str, Any]] = None  # noqa: E704\n    ) -> bool: ...  # noqa: E704\n    def handle_warning(  # noqa: E704\n        self, message: str, context: Optional[Dict[str, Any]] = None  # noqa: E704\n    ) -> bool: ...  # noqa: E704\nclass IPluginManager:\n    def load_plugin(self, name: str) -> Any: ...  # noqa: E704\n    def get_plugin(self, name: str) -> Any: ...  # noqa: E704",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "IPluginManager",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class IPluginManager:\n    def load_plugin(self, name: str) -> Any: ...  # noqa: E704\n    def get_plugin(self, name: str) -> Any: ...  # noqa: E704\n    def discover_plugins(self) -> List[str]: ...  # noqa: E704\n    def load_plugins(self) -> int: ...  # noqa: E704\n    def unload_plugin(self, name: str) -> bool: ...  # noqa: E704\n# Пытаемся импортировать реальные классы\ntry:\n    from core.common.error_handler import ErrorHandler  # type: ignore\n    from core.component_registry import ComponentRegistry  # type: ignore",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "TestComponentRegistry",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class TestComponentRegistry:\n    \"\"\"Тесты для регистрации и получения компонентов\"\"\"\n    def test_register_component(self):\n        \"\"\"Тест регистрации компонента\"\"\"\n        registry = ComponentRegistry()\n        mock_component = MagicMock()\n        result = registry.register(\"test_component\", mock_component)\n        assert result is True\n        assert registry.get(\"test_component\") == mock_component\n    def test_get_nonexistent_component(self):",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "TestSystemInitialization",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class TestSystemInitialization:\n    \"\"\"Тесты инициализации системы\"\"\"\n    def test_system_initialization(self):\n        \"\"\"Тест успешной инициализации системы\"\"\"\n        registry = ComponentRegistry()\n        # Создаем обработчик ошибок\n        error_handler = ErrorHandler()\n        # Регистрируем его дважды - с разными именами\n        registry.register(\"error_handler\", error_handler)  # Для SystemInitializer\n        registry.register(\"ErrorHandler\", error_handler)  # Для PluginManager",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "TestErrorHandling",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class TestErrorHandling:\n    \"\"\"Тесты обработки ошибок и логирования\"\"\"\n    @patch(\"logging.Logger.error\")\n    def test_error_handling(self, mock_error):\n        \"\"\"Тест обработки ошибок\"\"\"\n        handler = ErrorHandler()\n        test_error = Exception(\"Test error\")\n        result = handler.handle_error(test_error)\n        assert result is True\n        mock_error.assert_called_once()",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "TestPluginSystem",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class TestPluginSystem:\n    \"\"\"Тесты расширяемости через плагины\"\"\"\n    def setup_method(self):\n        \"\"\"Подготовка к каждому тесту\"\"\"\n        # Создаем временную директорию для плагинов\n        self.temp_plugins_dir = tempfile.mkdtemp()\n        # Сохраняем оригинальный путь к плагинам\n        self.original_plugins_dir = None\n    def teardown_method(self):\n        \"\"\"Очистка после каждого теста\"\"\"",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "TestPlugin",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class TestPlugin:\n    def __init__(self):\n        self.initialized = True\n    def setup(self):\n        self.setup_called = True\n        return True\n\"\"\"\n        self.create_test_plugin(\"test_plugin\", plugin_code)\n        # Создаем реестр и регистрируем обработчик ошибок\n        registry = ComponentRegistry()",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "IntegrationPlugin",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class IntegrationPlugin:\n    def __init__(self):\n        self.registry = None\n    def setup(self):\n        pass\n    def integrate(self, registry):\n        self.registry = registry\n        return True\n\"\"\"\n        self.create_test_plugin(\"integration_plugin\", plugin_code)",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "TestArchitectureCompliance",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_architecture",
        "description": "tests.unit.core.architecture.test_architecture",
        "peekOfCode": "class TestArchitectureCompliance:\n    \"\"\"Тесты соответствия архитектуры проекта требованиям\"\"\"\n    def test_core_components_existence(self):\n        \"\"\"Проверка наличия всех основных компонентов ядра\"\"\"\n        # Проверяем наличие файлов ядра\n        core_files = [\n            \"core/component_registry.py\",\n            \"core/system_initializer.py\",\n            \"core/plugin_manager.py\",\n            \"core/common/error_handler.py\",",
        "detail": "tests.unit.core.architecture.test_architecture",
        "documentation": {}
    },
    {
        "label": "TestDirectoryStructure",
        "kind": 6,
        "importPath": "tests.unit.core.architecture.test_directory_structure",
        "description": "tests.unit.core.architecture.test_directory_structure",
        "peekOfCode": "class TestDirectoryStructure:\n    \"\"\"Тесты для проверки структуры каталогов.\"\"\"\n    def test_core_directory_exists(self):\n        \"\"\"Проверка существования базовой директории core.\"\"\"\n        assert os.path.isdir(\"core\"), \"Директория core не существует\"\n    def test_common_directory_exists(self):\n        \"\"\"Проверка существования директории core/common.\"\"\"\n        common_dir = os.path.join(\"core\", \"common\")\n        assert os.path.isdir(common_dir), \"Директория core/common не существует\"\n    def test_platform_directory_exists(self):",
        "detail": "tests.unit.core.architecture.test_directory_structure",
        "documentation": {}
    },
    {
        "label": "BaseFileSystemTest",
        "kind": 6,
        "importPath": "tests.unit.core.common.filesystem.test_base_filesystem",
        "description": "tests.unit.core.common.filesystem.test_base_filesystem",
        "peekOfCode": "class BaseFileSystemTest:\n    \"\"\"\n    Базовый класс для тестирования реализаций файловой системы.\n    Все тесты, общие для всех реализаций, должны быть определены здесь.\n    \"\"\"\n    # Должен быть переопределен в подклассах\n    file_system_class: Optional[Type[AbstractFileSystem]] = None\n    @pytest.fixture\n    def file_system(self):\n        \"\"\"Создает экземпляр файловой системы для тестирования\"\"\"",
        "detail": "tests.unit.core.common.filesystem.test_base_filesystem",
        "documentation": {}
    },
    {
        "label": "MockFileSystem",
        "kind": 6,
        "importPath": "tests.unit.core.common.filesystem.test_filesystem_factory",
        "description": "tests.unit.core.common.filesystem.test_filesystem_factory",
        "peekOfCode": "class MockFileSystem(AbstractFileSystem):\n    \"\"\"Мок-реализация файловой системы для тестирования\"\"\"\n    def __init__(self, **kwargs):\n        self.test_param = kwargs.get(\"test_param\", None)\n    # Реализация абстрактных методов\n    def create_file(self, path, content=\"\", encoding=\"utf-8\"):\n        return True\n    def read_file(self, path, encoding=\"utf-8\"):\n        return \"Mock content\"\n    def append_to_file(self, path, content, encoding=\"utf-8\"):",
        "detail": "tests.unit.core.common.filesystem.test_filesystem_factory",
        "documentation": {}
    },
    {
        "label": "TestFileSystemFactory",
        "kind": 6,
        "importPath": "tests.unit.core.common.filesystem.test_filesystem_factory",
        "description": "tests.unit.core.common.filesystem.test_filesystem_factory",
        "peekOfCode": "class TestFileSystemFactory:\n    \"\"\"Тесты для фабрики файловой системы\"\"\"\n    @pytest.fixture(autouse=True)\n    def cleanup(self):\n        \"\"\"Очистка после тестов\"\"\"\n        yield\n        # Удаляем тестовую реализацию из реестра\n        from core.common.filesystem.registry import _file_system_implementations\n        if \"mock\" in _file_system_implementations:\n            del _file_system_implementations[\"mock\"]",
        "detail": "tests.unit.core.common.filesystem.test_filesystem_factory",
        "documentation": {}
    },
    {
        "label": "TestMockFileSystem",
        "kind": 6,
        "importPath": "tests.unit.core.common.filesystem.test_filesystem_registry",
        "description": "tests.unit.core.common.filesystem.test_filesystem_registry",
        "peekOfCode": "class TestMockFileSystem(AbstractFileSystem):\n    \"\"\"Мок-реализация файловой системы для тестов реестра\"\"\"\n    # Минимальная заглушка для абстрактного класса\n    def create_file(self, path, content=\"\", encoding=\"utf-8\"):\n        return True\nclass TestMockFileSystem2(AbstractFileSystem):\n    \"\"\"Вторая мок-реализация файловой системы для тестов реестра\"\"\"\n    # Минимальная заглушка для абстрактного класса\n    def create_file(self, path, content=\"\", encoding=\"utf-8\"):\n        return True",
        "detail": "tests.unit.core.common.filesystem.test_filesystem_registry",
        "documentation": {}
    },
    {
        "label": "TestMockFileSystem2",
        "kind": 6,
        "importPath": "tests.unit.core.common.filesystem.test_filesystem_registry",
        "description": "tests.unit.core.common.filesystem.test_filesystem_registry",
        "peekOfCode": "class TestMockFileSystem2(AbstractFileSystem):\n    \"\"\"Вторая мок-реализация файловой системы для тестов реестра\"\"\"\n    # Минимальная заглушка для абстрактного класса\n    def create_file(self, path, content=\"\", encoding=\"utf-8\"):\n        return True\nclass TestFileSystemRegistry:\n    \"\"\"Тесты для реестра файловой системы\"\"\"\n    @pytest.fixture(autouse=True)\n    def cleanup(self):\n        \"\"\"Очистка после тестов\"\"\"",
        "detail": "tests.unit.core.common.filesystem.test_filesystem_registry",
        "documentation": {}
    },
    {
        "label": "TestFileSystemRegistry",
        "kind": 6,
        "importPath": "tests.unit.core.common.filesystem.test_filesystem_registry",
        "description": "tests.unit.core.common.filesystem.test_filesystem_registry",
        "peekOfCode": "class TestFileSystemRegistry:\n    \"\"\"Тесты для реестра файловой системы\"\"\"\n    @pytest.fixture(autouse=True)\n    def cleanup(self):\n        \"\"\"Очистка после тестов\"\"\"\n        original_registry = get_registered_file_systems()\n        yield\n        # Восстанавливаем оригинальное состояние реестра\n        from core.common.filesystem.registry import _file_system_implementations\n        _file_system_implementations.clear()",
        "detail": "tests.unit.core.common.filesystem.test_filesystem_registry",
        "documentation": {}
    },
    {
        "label": "TestKeyboardInterface",
        "kind": 6,
        "importPath": "tests.unit.core.common.input.test_base_classes",
        "description": "tests.unit.core.common.input.test_base_classes",
        "peekOfCode": "class TestKeyboardInterface:\n    \"\"\"Тесты для проверки интерфейса клавиатуры.\"\"\"\n    def test_abstract_keyboard_methods(self):\n        \"\"\"Проверка наличия всех необходимых абстрактных методов.\"\"\"\n        # Получаем все абстрактные методы\n        abstract_methods = {\n            name\n            for name, method in inspect.getmembers(AbstractKeyboard)\n            if getattr(method, \"__isabstractmethod__\", False)\n        }",
        "detail": "tests.unit.core.common.input.test_base_classes",
        "documentation": {}
    },
    {
        "label": "TestMouseInterface",
        "kind": 6,
        "importPath": "tests.unit.core.common.input.test_base_classes",
        "description": "tests.unit.core.common.input.test_base_classes",
        "peekOfCode": "class TestMouseInterface:\n    \"\"\"Тесты для проверки интерфейса мыши.\"\"\"\n    def test_abstract_mouse_methods(self):\n        \"\"\"Проверка наличия всех необходимых абстрактных методов.\"\"\"\n        # Получаем все абстрактные методы\n        abstract_methods = {\n            name\n            for name, method in inspect.getmembers(AbstractMouse)\n            if getattr(method, \"__isabstractmethod__\", False)\n        }",
        "detail": "tests.unit.core.common.input.test_base_classes",
        "documentation": {}
    },
    {
        "label": "TestInputController",
        "kind": 6,
        "importPath": "tests.unit.core.common.input.test_base_classes",
        "description": "tests.unit.core.common.input.test_base_classes",
        "peekOfCode": "class TestInputController:\n    \"\"\"Тесты для комбинированного контроллера ввода.\"\"\"\n    def test_input_controller_initialization(self):\n        \"\"\"Проверка правильной инициализации InputController.\"\"\"\n        # Создаем моки для клавиатуры и мыши\n        mock_keyboard = MagicMock(spec=AbstractKeyboard)\n        mock_mouse = MagicMock(spec=AbstractMouse)\n        # Создаем InputController\n        controller = InputController(mock_keyboard, mock_mouse)\n        # Проверяем, что контроллер правильно инициализирован",
        "detail": "tests.unit.core.common.input.test_base_classes",
        "documentation": {}
    },
    {
        "label": "TestInputFactory",
        "kind": 6,
        "importPath": "tests.unit.core.common.input.test_base_classes",
        "description": "tests.unit.core.common.input.test_base_classes",
        "peekOfCode": "class TestInputFactory:\n    \"\"\"Тесты для фабрики контроллеров ввода.\"\"\"\n    def test_get_keyboard(self):\n        \"\"\"Тест создания контроллера клавиатуры.\"\"\"\n        # Импортируем фабрику\n        from core.common.input.factory import get_keyboard\n        # Мокаем подходящий класс клавиатуры для текущей платформы\n        with patch(\"platform.system\", return_value=\"Windows\"), patch(\n            \"core.common.input.registry.InputRegistry._register_platform_controllers\"\n        ), patch(",
        "detail": "tests.unit.core.common.input.test_base_classes",
        "documentation": {}
    },
    {
        "label": "TestInputRegistry",
        "kind": 6,
        "importPath": "tests.unit.core.common.input.test_base_classes",
        "description": "tests.unit.core.common.input.test_base_classes",
        "peekOfCode": "class TestInputRegistry:\n    \"\"\"Тесты для реестра контроллеров ввода.\"\"\"\n    def test_register_keyboard(self):\n        \"\"\"Тест регистрации контроллера клавиатуры.\"\"\"\n        from core.common.input.registry import InputRegistry\n        # Создаем реестр\n        registry = InputRegistry()\n        # Создаем тестовый класс клавиатуры\n        class TestKeyboard(AbstractKeyboard):\n            def press_key(self, key: str) -> bool:",
        "detail": "tests.unit.core.common.input.test_base_classes",
        "documentation": {}
    },
    {
        "label": "TestInputBaseInterfaces",
        "kind": 6,
        "importPath": "tests.unit.core.common.input.test_base_interfaces",
        "description": "tests.unit.core.common.input.test_base_interfaces",
        "peekOfCode": "class TestInputBaseInterfaces:\n    \"\"\"Тесты для проверки базовых интерфейсов подсистемы ввода.\"\"\"\n    def test_keyboard_controller_base_exists(self):\n        \"\"\"Проверка существования и структуры базового класса для контроллера клавиатуры.\"\"\"\n        # Импортируем базовый класс\n        from core.common.input.base import AbstractKeyboard\n        # Проверяем, что это абстрактный класс\n        assert issubclass(AbstractKeyboard, ABC)\n        # Проверяем наличие необходимых абстрактных методов\n        abstract_methods = {",
        "detail": "tests.unit.core.common.input.test_base_interfaces",
        "documentation": {}
    },
    {
        "label": "TestInputFactory",
        "kind": 6,
        "importPath": "tests.unit.core.common.input.test_factory_and_registry",
        "description": "tests.unit.core.common.input.test_factory_and_registry",
        "peekOfCode": "class TestInputFactory:\n    \"\"\"Тесты для фабрики контроллеров ввода.\"\"\"\n    def test_get_keyboard_caching(self):\n        \"\"\"Тест кэширования экземпляров клавиатуры.\"\"\"\n        # Патчим реестр контроллеров ввода\n        with patch(\"core.common.input.factory.registry\") as mock_registry, patch(\n            \"platform.system\", return_value=\"Windows\"\n        ):\n            # Очищаем кэш для теста\n            from core.common.input.factory import _keyboard_instances",
        "detail": "tests.unit.core.common.input.test_factory_and_registry",
        "documentation": {}
    },
    {
        "label": "TestInputRegistry",
        "kind": 6,
        "importPath": "tests.unit.core.common.input.test_factory_and_registry",
        "description": "tests.unit.core.common.input.test_factory_and_registry",
        "peekOfCode": "class TestInputRegistry:\n    \"\"\"Тесты для реестра контроллеров ввода.\"\"\"\n    @pytest.fixture(autouse=True)\n    def reset_registry(self, request):\n        \"\"\"Сбрасывает синглтон реестра перед каждым тестом.\"\"\"\n        # Пропускаем сброс для теста синглтона\n        if \"test_singleton_property\" not in request.node.name:\n            from core.common.input.registry import InputRegistry\n            InputRegistry.reset_instance()\n        yield",
        "detail": "tests.unit.core.common.input.test_factory_and_registry",
        "documentation": {}
    },
    {
        "label": "TestActionPlanner",
        "kind": 6,
        "importPath": "tests.unit.core.llm.test_action_planner",
        "description": "tests.unit.core.llm.test_action_planner",
        "peekOfCode": "class TestActionPlanner:\n    \"\"\"Тесты для планировщика действий\"\"\"\n    @pytest.fixture\n    def action_planner(self):\n        \"\"\"Фикстура для создания экземпляра ActionPlanner\"\"\"\n        # Создаем мок для обработчика ошибок\n        error_handler = MagicMock()\n        # Создаем мок для API-коннектора\n        api_connector = MagicMock()\n        # Создаем планировщик действий",
        "detail": "tests.unit.core.llm.test_action_planner",
        "documentation": {}
    },
    {
        "label": "pytestmark",
        "kind": 5,
        "importPath": "tests.unit.core.llm.test_action_planner",
        "description": "tests.unit.core.llm.test_action_planner",
        "peekOfCode": "pytestmark = pytest.mark.skipif(not HAS_ACTION_PLANNER, reason=\"ActionPlanner not implemented yet\")\nclass TestActionPlanner:\n    \"\"\"Тесты для планировщика действий\"\"\"\n    @pytest.fixture\n    def action_planner(self):\n        \"\"\"Фикстура для создания экземпляра ActionPlanner\"\"\"\n        # Создаем мок для обработчика ошибок\n        error_handler = MagicMock()\n        # Создаем мок для API-коннектора\n        api_connector = MagicMock()",
        "detail": "tests.unit.core.llm.test_action_planner",
        "documentation": {}
    },
    {
        "label": "TestAPIConnector",
        "kind": 6,
        "importPath": "tests.unit.core.llm.test_api_connector",
        "description": "tests.unit.core.llm.test_api_connector",
        "peekOfCode": "class TestAPIConnector:\n    \"\"\"Тесты для коннектора API нейросетей\"\"\"\n    @pytest.fixture\n    def api_connector(self):\n        \"\"\"Фикстура для создания экземпляра APIConnector\"\"\"\n        # Создаем мок для обработчика ошибок\n        error_handler = MagicMock()\n        # Создаем коннектор с тестовыми настройками\n        connector = APIConnector(\n            api_key=\"test_key\", base_url=\"https://api.example.com\", error_handler=error_handler",
        "detail": "tests.unit.core.llm.test_api_connector",
        "documentation": {}
    },
    {
        "label": "pytestmark",
        "kind": 5,
        "importPath": "tests.unit.core.llm.test_api_connector",
        "description": "tests.unit.core.llm.test_api_connector",
        "peekOfCode": "pytestmark = pytest.mark.skipif(not HAS_API_CONNECTOR, reason=\"APIConnector not implemented yet\")\nclass TestAPIConnector:\n    \"\"\"Тесты для коннектора API нейросетей\"\"\"\n    @pytest.fixture\n    def api_connector(self):\n        \"\"\"Фикстура для создания экземпляра APIConnector\"\"\"\n        # Создаем мок для обработчика ошибок\n        error_handler = MagicMock()\n        # Создаем коннектор с тестовыми настройками\n        connector = APIConnector(",
        "detail": "tests.unit.core.llm.test_api_connector",
        "documentation": {}
    },
    {
        "label": "TestErrorHandling",
        "kind": 6,
        "importPath": "tests.unit.core.llm.test_llm_error_handling",
        "description": "tests.unit.core.llm.test_llm_error_handling",
        "peekOfCode": "class TestErrorHandling:\n    \"\"\"Тесты для обработки ошибок LLM API\"\"\"\n    @pytest.fixture\n    def error_handler(self):\n        \"\"\"Фикстура для создания мока обработчика ошибок\"\"\"\n        return MagicMock()\n    def test_handle_api_error(self, error_handler):\n        \"\"\"Тест обработки ошибки API\"\"\"\n        # Создаем тестовое исключение\n        response = MagicMock()",
        "detail": "tests.unit.core.llm.test_llm_error_handling",
        "documentation": {}
    },
    {
        "label": "pytestmark",
        "kind": 5,
        "importPath": "tests.unit.core.llm.test_llm_error_handling",
        "description": "tests.unit.core.llm.test_llm_error_handling",
        "peekOfCode": "pytestmark = pytest.mark.skipif(\n    not HAS_ERROR_HANDLING, reason=\"LLM error handling not implemented yet\"\n)\nclass TestErrorHandling:\n    \"\"\"Тесты для обработки ошибок LLM API\"\"\"\n    @pytest.fixture\n    def error_handler(self):\n        \"\"\"Фикстура для создания мока обработчика ошибок\"\"\"\n        return MagicMock()\n    def test_handle_api_error(self, error_handler):",
        "detail": "tests.unit.core.llm.test_llm_error_handling",
        "documentation": {}
    },
    {
        "label": "TestPromptProcessor",
        "kind": 6,
        "importPath": "tests.unit.core.llm.test_prompt_processor",
        "description": "tests.unit.core.llm.test_prompt_processor",
        "peekOfCode": "class TestPromptProcessor:\n    \"\"\"Тесты для процессора промптов\"\"\"\n    @pytest.fixture\n    def prompt_processor(self):\n        \"\"\"Фикстура для создания экземпляра PromptProcessor\"\"\"\n        # Создаем мок для обработчика ошибок\n        error_handler = MagicMock()\n        # Создаем процессор промптов\n        processor = PromptProcessor(error_handler=error_handler)\n        return processor",
        "detail": "tests.unit.core.llm.test_prompt_processor",
        "documentation": {}
    },
    {
        "label": "pytestmark",
        "kind": 5,
        "importPath": "tests.unit.core.llm.test_prompt_processor",
        "description": "tests.unit.core.llm.test_prompt_processor",
        "peekOfCode": "pytestmark = pytest.mark.skipif(\n    not HAS_PROMPT_PROCESSOR, reason=\"PromptProcessor not implemented yet\"\n)\nclass TestPromptProcessor:\n    \"\"\"Тесты для процессора промптов\"\"\"\n    @pytest.fixture\n    def prompt_processor(self):\n        \"\"\"Фикстура для создания экземпляра PromptProcessor\"\"\"\n        # Создаем мок для обработчика ошибок\n        error_handler = MagicMock()",
        "detail": "tests.unit.core.llm.test_prompt_processor",
        "documentation": {}
    },
    {
        "label": "TestResponseParser",
        "kind": 6,
        "importPath": "tests.unit.core.llm.test_response_parser",
        "description": "tests.unit.core.llm.test_response_parser",
        "peekOfCode": "class TestResponseParser:\n    \"\"\"Тесты для парсера ответов нейросети\"\"\"\n    @pytest.fixture\n    def response_parser(self):\n        \"\"\"Фикстура для создания экземпляра ResponseParser\"\"\"\n        # Создаем мок для обработчика ошибок\n        error_handler = MagicMock()\n        # Создаем парсер ответов\n        parser = ResponseParser(error_handler=error_handler)\n        return parser",
        "detail": "tests.unit.core.llm.test_response_parser",
        "documentation": {}
    },
    {
        "label": "TestWin32FileSystem",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.filesystem.test_win32_filesystem",
        "description": "tests.unit.core.platform.windows.filesystem.test_win32_filesystem",
        "peekOfCode": "class TestWin32FileSystem(BaseFileSystemTest):\n    \"\"\"\n    Тесты для Windows-реализации файловой системы.\n    Наследует общие тесты из BaseFileSystemTest и добавляет специфичные для Windows.\n    \"\"\"\n    file_system_class = Win32FileSystem\n    @pytest.fixture(autouse=True)\n    def check_platform(self):\n        \"\"\"Пропускаем тесты, если не Windows\"\"\"\n        if platform.system().lower() != \"windows\":",
        "detail": "tests.unit.core.platform.windows.filesystem.test_win32_filesystem",
        "documentation": {}
    },
    {
        "label": "TestWindowsKeyboard",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.input.test_windows_controllers",
        "description": "tests.unit.core.platform.windows.input.test_windows_controllers",
        "peekOfCode": "class TestWindowsKeyboard:\n    \"\"\"Тесты для Windows-реализации контроллера клавиатуры.\"\"\"\n    @pytest.fixture\n    def keyboard(self):\n        \"\"\"Создает экземпляр WindowsKeyboard для тестов.\"\"\"\n        with patch(\"win32api.keybd_event\") as mock_keybd_event:\n            keyboard = WindowsKeyboard(human_like=False)\n            yield keyboard, mock_keybd_event\n    def test_inheritance(self):\n        \"\"\"Проверка, что WindowsKeyboard наследуется от AbstractKeyboard.\"\"\"",
        "detail": "tests.unit.core.platform.windows.input.test_windows_controllers",
        "documentation": {}
    },
    {
        "label": "TestWindowsMouse",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.input.test_windows_controllers",
        "description": "tests.unit.core.platform.windows.input.test_windows_controllers",
        "peekOfCode": "class TestWindowsMouse:\n    \"\"\"Тесты для Windows-реализации контроллера мыши.\"\"\"\n    @pytest.fixture\n    def mouse(self):\n        \"\"\"Создает экземпляр WindowsMouse для тестов.\"\"\"\n        with patch(\"win32api.SetCursorPos\") as mock_set_cursor, patch(\n            \"win32api.mouse_event\"\n        ) as mock_mouse_event, patch(\n            \"win32gui.GetCursorPos\", return_value=(100, 100)\n        ) as mock_get_cursor:",
        "detail": "tests.unit.core.platform.windows.input.test_windows_controllers",
        "documentation": {}
    },
    {
        "label": "TestWindowsInputIntegration",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.input.test_windows_controllers",
        "description": "tests.unit.core.platform.windows.input.test_windows_controllers",
        "peekOfCode": "class TestWindowsInputIntegration:\n    \"\"\"Интеграционные тесты для WindowsKeyboard и WindowsMouse.\"\"\"\n    @pytest.fixture\n    def input_controller(self):\n        \"\"\"Создает InputController с моками клавиатуры и мыши Windows.\"\"\"\n        with patch(\"win32api.keybd_event\"), patch(\"win32api.SetCursorPos\"), patch(\n            \"win32api.mouse_event\"\n        ):\n            keyboard = WindowsKeyboard(human_like=False)\n            mouse = WindowsMouse(human_like=False)",
        "detail": "tests.unit.core.platform.windows.input.test_windows_controllers",
        "documentation": {}
    },
    {
        "label": "TestProcessManager",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.test_process_manager",
        "description": "tests.unit.core.platform.windows.test_process_manager",
        "peekOfCode": "class TestProcessManager:\n    \"\"\"Тесты класса управления процессами Windows\"\"\"\n    @pytest.fixture\n    def process_manager(self):\n        \"\"\"Создает экземпляр ProcessManager\"\"\"\n        from core.process import get_process_manager\n        return get_process_manager()\n    @pytest.fixture\n    def mock_popen(self):\n        \"\"\"Мок для subprocess.Popen\"\"\"",
        "detail": "tests.unit.core.platform.windows.test_process_manager",
        "documentation": {}
    },
    {
        "label": "TestRegistryManager",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.test_registry_manager",
        "description": "tests.unit.core.platform.windows.test_registry_manager",
        "peekOfCode": "class TestRegistryManager(unittest.TestCase):\n    \"\"\"Тесты для менеджера реестра Windows\"\"\"\n    def setUp(self):\n        \"\"\"Настройка перед каждым тестом\"\"\"\n        self.registry_manager = Win32RegistryManager()\n    @patch(\"winreg.OpenKey\")\n    @patch(\"winreg.QueryValueEx\")\n    @patch(\"winreg.CloseKey\")  # Добавляем патч для CloseKey\n    def test_read_value(self, mock_close_key, mock_query_value, mock_open_key):\n        \"\"\"Тест чтения значения из реестра\"\"\"",
        "detail": "tests.unit.core.platform.windows.test_registry_manager",
        "documentation": {}
    },
    {
        "label": "TestSystemInfo",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.test_system_info",
        "description": "tests.unit.core.platform.windows.test_system_info",
        "peekOfCode": "class TestSystemInfo:\n    \"\"\"Тесты класса системной информации Windows\"\"\"\n    @pytest.fixture\n    def system_info(self):\n        \"\"\"Создает экземпляр Win32SystemInfo с мок-зависимостями\"\"\"\n        with patch(\"wmi.WMI\"):\n            from core.platform.windows.system.win32_system_info import Win32SystemInfo\n            return Win32SystemInfo()\n    @patch(\"platform.system\", return_value=\"Windows\")\n    @patch(\"platform.version\", return_value=\"10.0.19042\")",
        "detail": "tests.unit.core.platform.windows.test_system_info",
        "documentation": {}
    },
    {
        "label": "TestWindowManagement",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.test_windows_interaction",
        "description": "tests.unit.core.platform.windows.test_windows_interaction",
        "peekOfCode": "class TestWindowManagement:\n    \"\"\"Тесты управления окнами Windows\"\"\"\n    @pytest.fixture(autouse=True)\n    def setup_and_teardown(self):\n        \"\"\"Запускаем и закрываем Блокнот для каждого теста\"\"\"\n        # Запускаем Блокнот\n        self.notepad_process = subprocess.Popen([\"notepad.exe\"])\n        # Даем время на запуск\n        time.sleep(2)\n        yield  # Выполняем тест",
        "detail": "tests.unit.core.platform.windows.test_windows_interaction",
        "documentation": {}
    },
    {
        "label": "TestFileSystem",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.test_windows_interaction",
        "description": "tests.unit.core.platform.windows.test_windows_interaction",
        "peekOfCode": "class TestFileSystem:\n    \"\"\"Тесты работы с файловой системой Windows\"\"\"\n    def setup_method(self):\n        \"\"\"Подготовка перед каждым тестом\"\"\"\n        self.test_dir = \"test_files\"\n        self.test_file = f\"{self.test_dir}/test.txt\"\n        # Создаем тестовую директорию, если она не существует\n        import os\n        if not os.path.exists(self.test_dir):\n            os.makedirs(self.test_dir)",
        "detail": "tests.unit.core.platform.windows.test_windows_interaction",
        "documentation": {}
    },
    {
        "label": "TestProcessManagement",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.test_windows_interaction",
        "description": "tests.unit.core.platform.windows.test_windows_interaction",
        "peekOfCode": "class TestProcessManagement:\n    \"\"\"Тесты управления процессами Windows\"\"\"\n    def teardown_method(self):\n        \"\"\"Очистка после каждого теста\"\"\"\n        # Закрываем Блокнот, если он был запущен\n        import os\n        os.system(\"taskkill /f /im notepad.exe 2>nul\")\n    def test_start_process(self):\n        \"\"\"Тест запуска процесса\"\"\"\n        from core.common.process import get_process_manager",
        "detail": "tests.unit.core.platform.windows.test_windows_interaction",
        "documentation": {}
    },
    {
        "label": "TestSystemInformation",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.test_windows_interaction",
        "description": "tests.unit.core.platform.windows.test_windows_interaction",
        "peekOfCode": "class TestSystemInformation:\n    \"\"\"Тесты получения системной информации Windows\"\"\"\n    def test_get_os_info(self):\n        \"\"\"Тест получения информации об ОС\"\"\"\n        from core.platform.windows.system.win32_system_info import Win32SystemInfo\n        system_info = Win32SystemInfo()\n        os_info = system_info.get_os_info()\n        assert os_info is not None\n        assert \"name\" in os_info\n        assert os_info[\"name\"] == \"Windows\"",
        "detail": "tests.unit.core.platform.windows.test_windows_interaction",
        "documentation": {}
    },
    {
        "label": "TestRegistryManagement",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.test_windows_interaction",
        "description": "tests.unit.core.platform.windows.test_windows_interaction",
        "peekOfCode": "class TestRegistryManagement:\n    \"\"\"Тесты работы с реестром Windows\"\"\"\n    def setup_method(self):\n        \"\"\"Подготовка перед каждым тестом\"\"\"\n        from core.platform.windows.registry.win32_registry_manager import Win32RegistryManager\n        self.registry_manager = Win32RegistryManager()\n        # Используем временный ключ для тестов\n        self.root_key = self.registry_manager.HKEY_CURRENT_USER\n        self.test_key_path = \"Software\\\\NLATest\"\n        self.test_value_name = \"TestValue\"",
        "detail": "tests.unit.core.platform.windows.test_windows_interaction",
        "documentation": {}
    },
    {
        "label": "TestWindowManager",
        "kind": 6,
        "importPath": "tests.unit.core.platform.windows.test_window_manager",
        "description": "tests.unit.core.platform.windows.test_window_manager",
        "peekOfCode": "class TestWindowManager:\n    \"\"\"Тесты менеджера окон Windows\"\"\"\n    @pytest.fixture\n    def window_manager(self):\n        \"\"\"Создает экземпляр WindowManager\"\"\"\n        return WindowManager()\n    @patch(\"win32gui.EnumWindows\")\n    def test_find_window_by_title(self, mock_enum_windows, window_manager):\n        \"\"\"Тест поиска окна по заголовку\"\"\"\n        # Создаем функцию для имитации обратного вызова EnumWindows",
        "detail": "tests.unit.core.platform.windows.test_window_manager",
        "documentation": {}
    },
    {
        "label": "TestElementLocalization",
        "kind": 6,
        "importPath": "tests.unit.core.vision.test_element_localization",
        "description": "tests.unit.core.vision.test_element_localization",
        "peekOfCode": "class TestElementLocalization(unittest.TestCase):\n    \"\"\"Тесты для модуля локализации элементов на экране\"\"\"\n    def setUp(self):\n        \"\"\"Настройка перед каждым тестом\"\"\"\n        self.element_localization = ElementLocalization()\n    @patch(\"core.vision.screen_capture.ScreenCapture.capture_screen\")\n    @patch(\"core.vision.element_recognition.ElementRecognition.find_template\")\n    def test_locate_element_by_template(self, mock_find_template, mock_capture_screen):\n        \"\"\"Тест локализации элемента по шаблону\"\"\"\n        # Создаем тестовые изображения",
        "detail": "tests.unit.core.vision.test_element_localization",
        "documentation": {}
    },
    {
        "label": "TestElementRecognition",
        "kind": 6,
        "importPath": "tests.unit.core.vision.test_element_recognition",
        "description": "tests.unit.core.vision.test_element_recognition",
        "peekOfCode": "class TestElementRecognition(unittest.TestCase):\n    \"\"\"Тесты для модуля распознавания элементов интерфейса\"\"\"\n    def setUp(self):\n        \"\"\"Настройка перед каждым тестом\"\"\"\n        self.element_recognition = ElementRecognition()\n    @patch(\"cv2.matchTemplate\")\n    @patch(\"cv2.minMaxLoc\")\n    def test_find_template(self, mock_min_max_loc, mock_match_template):\n        \"\"\"Тест поиска шаблона на изображении\"\"\"\n        # Создаем тестовые изображения",
        "detail": "tests.unit.core.vision.test_element_recognition",
        "documentation": {}
    },
    {
        "label": "TestImageComparison",
        "kind": 6,
        "importPath": "tests.unit.core.vision.test_image_comparison",
        "description": "tests.unit.core.vision.test_image_comparison",
        "peekOfCode": "class TestImageComparison(unittest.TestCase):\n    \"\"\"Тесты для модуля сравнения изображений\"\"\"\n    def setUp(self):\n        \"\"\"Настройка перед каждым тестом\"\"\"\n        self.image_comparison = ImageComparison()\n    def test_compare_images_identical(self):\n        \"\"\"Тест сравнения идентичных изображений\"\"\"\n        # Создаем два идентичных изображения\n        img1 = np.zeros((100, 100, 3), dtype=np.uint8)\n        img2 = np.zeros((100, 100, 3), dtype=np.uint8)",
        "detail": "tests.unit.core.vision.test_image_comparison",
        "documentation": {}
    },
    {
        "label": "TestScreenCapture",
        "kind": 6,
        "importPath": "tests.unit.core.vision.test_screen_capture",
        "description": "tests.unit.core.vision.test_screen_capture",
        "peekOfCode": "class TestScreenCapture(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Подготовка перед каждым тестом\"\"\"\n        from core.vision.screen_capture import ScreenCapture\n        self.screen_capture = ScreenCapture()\n        # Создаем директорию для тестовых скриншотов\n        self.test_dir = \"test_screenshots\"\n        if not os.path.exists(self.test_dir):\n            os.makedirs(self.test_dir)\n    def tearDown(self):",
        "detail": "tests.unit.core.vision.test_screen_capture",
        "documentation": {}
    },
    {
        "label": "TestScreenChanges",
        "kind": 6,
        "importPath": "tests.unit.core.vision.test_screen_changes",
        "description": "tests.unit.core.vision.test_screen_changes",
        "peekOfCode": "class TestScreenChanges(unittest.TestCase):\n    \"\"\"Тесты для модуля обработки изменений на экране\"\"\"\n    def setUp(self):\n        \"\"\"Настройка перед каждым тестом\"\"\"\n        self.screen_changes = ScreenChanges()\n    @patch(\"core.vision.screen_capture.ScreenCapture.capture_screen\")\n    @patch(\"core.vision.image_comparison.ImageComparison.compare_images\")\n    def test_detect_changes(self, mock_compare_images, mock_capture_screen):\n        \"\"\"Тест обнаружения изменений на экране\"\"\"\n        # Создаем тестовые изображения",
        "detail": "tests.unit.core.vision.test_screen_changes",
        "documentation": {}
    },
    {
        "label": "TestScreenCapture",
        "kind": 6,
        "importPath": "tests.unit.core.vision.test_vision",
        "description": "tests.unit.core.vision.test_vision",
        "peekOfCode": "class TestScreenCapture:\n    \"\"\"Тесты захвата скриншотов\"\"\"\n    def setup_method(self):\n        \"\"\"Подготовка перед каждым тестом\"\"\"\n        from core.vision.screen_capture import ScreenCapture\n        self.screen_capture = ScreenCapture()\n        # Создаем директорию для тестовых скриншотов\n        self.test_dir = \"test_screenshots\"\n        if not os.path.exists(self.test_dir):\n            os.makedirs(self.test_dir)",
        "detail": "tests.unit.core.vision.test_vision",
        "documentation": {}
    },
    {
        "label": "TestElementRecognition",
        "kind": 6,
        "importPath": "tests.unit.core.vision.test_vision",
        "description": "tests.unit.core.vision.test_vision",
        "peekOfCode": "class TestElementRecognition:\n    \"\"\"Тесты распознавания элементов интерфейса\"\"\"\n    def setup_method(self):\n        \"\"\"Подготовка перед каждым тестом\"\"\"\n        from core.vision.element_recognition import ElementRecognition\n        self.element_recognition = ElementRecognition()\n        # Создаем директорию для тестовых изображений\n        self.test_dir = \"test_images\"\n        if not os.path.exists(self.test_dir):\n            os.makedirs(self.test_dir)",
        "detail": "tests.unit.core.vision.test_vision",
        "documentation": {}
    },
    {
        "label": "TestBrowserInitialization",
        "kind": 6,
        "importPath": "tests.unit.core.web.test_browser_init",
        "description": "tests.unit.core.web.test_browser_init",
        "peekOfCode": "class TestBrowserInitialization:\n    \"\"\"Тесты инициализации различных браузеров\"\"\"\n    @patch(\"core.web.browser_controller.webdriver.Chrome\")\n    @patch(\"core.web.browser_controller.ChromeService\")\n    @patch(\"core.web.browser_controller.ChromeDriverManager\")\n    def test_initialize_chrome(self, mock_chrome_driver_manager, mock_service, mock_webdriver):\n        \"\"\"Тест инициализации Chrome браузера\"\"\"\n        from core.web.browser_controller import BrowserController\n        # Настраиваем моки\n        mock_instance = MagicMock()",
        "detail": "tests.unit.core.web.test_browser_init",
        "documentation": {}
    },
    {
        "label": "element_finder",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_data_extraction",
        "description": "tests.unit.core.web.test_data_extraction",
        "peekOfCode": "def element_finder():\n    mock_driver = MagicMock()\n    mock_browser_controller = MagicMock()\n    mock_browser_controller.driver = mock_driver\n    from core.web.element_finder import ElementFinder\n    return ElementFinder(mock_browser_controller)\ndef test_extract_text_from_element(element_finder):\n    mock_element = MagicMock()\n    mock_element.text = \"Привет, мир!\"\n    text = element_finder.get_element_text(mock_element)",
        "detail": "tests.unit.core.web.test_data_extraction",
        "documentation": {}
    },
    {
        "label": "test_extract_text_from_element",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_data_extraction",
        "description": "tests.unit.core.web.test_data_extraction",
        "peekOfCode": "def test_extract_text_from_element(element_finder):\n    mock_element = MagicMock()\n    mock_element.text = \"Привет, мир!\"\n    text = element_finder.get_element_text(mock_element)\n    assert text == \"Привет, мир!\"\ndef test_extract_attribute_from_element(element_finder):\n    mock_element = MagicMock()\n    mock_element.get_attribute.return_value = \"https://example.com\"\n    value = element_finder.get_element_attribute(mock_element, \"href\")\n    mock_element.get_attribute.assert_called_once_with(\"href\")",
        "detail": "tests.unit.core.web.test_data_extraction",
        "documentation": {}
    },
    {
        "label": "test_extract_attribute_from_element",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_data_extraction",
        "description": "tests.unit.core.web.test_data_extraction",
        "peekOfCode": "def test_extract_attribute_from_element(element_finder):\n    mock_element = MagicMock()\n    mock_element.get_attribute.return_value = \"https://example.com\"\n    value = element_finder.get_element_attribute(mock_element, \"href\")\n    mock_element.get_attribute.assert_called_once_with(\"href\")\n    assert value == \"https://example.com\"\ndef test_extract_multiple_elements_text(element_finder):\n    mock_elements = [MagicMock(text=\"A\"), MagicMock(text=\"B\"), MagicMock(text=\"C\")]\n    # Допустим, у тебя есть метод для получения текста всех элементов\n    texts = [element_finder.get_element_text(e) for e in mock_elements]",
        "detail": "tests.unit.core.web.test_data_extraction",
        "documentation": {}
    },
    {
        "label": "test_extract_multiple_elements_text",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_data_extraction",
        "description": "tests.unit.core.web.test_data_extraction",
        "peekOfCode": "def test_extract_multiple_elements_text(element_finder):\n    mock_elements = [MagicMock(text=\"A\"), MagicMock(text=\"B\"), MagicMock(text=\"C\")]\n    # Допустим, у тебя есть метод для получения текста всех элементов\n    texts = [element_finder.get_element_text(e) for e in mock_elements]\n    assert texts == [\"A\", \"B\", \"C\"]\ndef test_extract_table_data(element_finder):\n    # Пример: извлечь все ячейки таблицы (упрощённо)\n    mock_row1 = MagicMock()\n    mock_row1.text = \"row1\"\n    mock_row2 = MagicMock()",
        "detail": "tests.unit.core.web.test_data_extraction",
        "documentation": {}
    },
    {
        "label": "test_extract_table_data",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_data_extraction",
        "description": "tests.unit.core.web.test_data_extraction",
        "peekOfCode": "def test_extract_table_data(element_finder):\n    # Пример: извлечь все ячейки таблицы (упрощённо)\n    mock_row1 = MagicMock()\n    mock_row1.text = \"row1\"\n    mock_row2 = MagicMock()\n    mock_row2.text = \"row2\"\n    table_elements = [mock_row1, mock_row2]\n    texts = [element_finder.get_element_text(e) for e in table_elements]\n    assert texts == [\"row1\", \"row2\"]",
        "detail": "tests.unit.core.web.test_data_extraction",
        "documentation": {}
    },
    {
        "label": "TestDOMSearch",
        "kind": 6,
        "importPath": "tests.unit.core.web.test_dom_search",
        "description": "tests.unit.core.web.test_dom_search",
        "peekOfCode": "class TestDOMSearch:\n    \"\"\"Тесты поиска элементов DOM\"\"\"\n    def setup_method(self):\n        self.mock_driver = MagicMock()\n        mock_browser_controller = MagicMock()\n        mock_browser_controller.driver = self.mock_driver\n        from core.web.element_finder import ElementFinder\n        self.element_finder = ElementFinder(mock_browser_controller)\n    def test_find_element_by_id(self):\n        \"\"\"Тест поиска элемента по ID\"\"\"",
        "detail": "tests.unit.core.web.test_dom_search",
        "documentation": {}
    },
    {
        "label": "element_finder",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def element_finder():\n    # Мокаем browser_controller с .driver\n    mock_driver = MagicMock()\n    mock_browser_controller = MagicMock()\n    mock_browser_controller.driver = mock_driver\n    from core.web.element_finder import ElementFinder\n    return ElementFinder(mock_browser_controller)\ndef test_send_keys_to_input(element_finder):\n    mock_element = MagicMock()\n    # Проверяем, что send_keys возвращает True при успешном вводе",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_send_keys_to_input",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_send_keys_to_input(element_finder):\n    mock_element = MagicMock()\n    # Проверяем, что send_keys возвращает True при успешном вводе\n    result = element_finder.send_keys(mock_element, \"тестовый текст\")\n    mock_element.clear.assert_called_once()\n    mock_element.send_keys.assert_called_once_with(\"тестовый текст\")\n    assert result is True\ndef test_send_keys_to_input_none(element_finder):\n    # Если элемент None, метод должен вернуть False\n    result = element_finder.send_keys(None, \"текст\")",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_send_keys_to_input_none",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_send_keys_to_input_none(element_finder):\n    # Если элемент None, метод должен вернуть False\n    result = element_finder.send_keys(None, \"текст\")\n    assert result is False\ndef test_click_element_success(element_finder):\n    mock_element = MagicMock()\n    result = element_finder.click_element(mock_element)\n    mock_element.click.assert_called_once()\n    assert result is True\ndef test_click_element_none(element_finder):",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_click_element_success",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_click_element_success(element_finder):\n    mock_element = MagicMock()\n    result = element_finder.click_element(mock_element)\n    mock_element.click.assert_called_once()\n    assert result is True\ndef test_click_element_none(element_finder):\n    result = element_finder.click_element(None)\n    assert result is False\ndef test_get_element_text_success(element_finder):\n    mock_element = MagicMock()",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_click_element_none",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_click_element_none(element_finder):\n    result = element_finder.click_element(None)\n    assert result is False\ndef test_get_element_text_success(element_finder):\n    mock_element = MagicMock()\n    mock_element.text = \"Текст элемента\"\n    text = element_finder.get_element_text(mock_element)\n    assert text == \"Текст элемента\"\ndef test_get_element_text_none(element_finder):\n    text = element_finder.get_element_text(None)",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_get_element_text_success",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_get_element_text_success(element_finder):\n    mock_element = MagicMock()\n    mock_element.text = \"Текст элемента\"\n    text = element_finder.get_element_text(mock_element)\n    assert text == \"Текст элемента\"\ndef test_get_element_text_none(element_finder):\n    text = element_finder.get_element_text(None)\n    assert text is None\ndef test_get_element_attribute_success(element_finder):\n    mock_element = MagicMock()",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_get_element_text_none",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_get_element_text_none(element_finder):\n    text = element_finder.get_element_text(None)\n    assert text is None\ndef test_get_element_attribute_success(element_finder):\n    mock_element = MagicMock()\n    mock_element.get_attribute.return_value = \"значение\"\n    value = element_finder.get_element_attribute(mock_element, \"data-test\")\n    mock_element.get_attribute.assert_called_once_with(\"data-test\")\n    assert value == \"значение\"\ndef test_get_element_attribute_none(element_finder):",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_get_element_attribute_success",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_get_element_attribute_success(element_finder):\n    mock_element = MagicMock()\n    mock_element.get_attribute.return_value = \"значение\"\n    value = element_finder.get_element_attribute(mock_element, \"data-test\")\n    mock_element.get_attribute.assert_called_once_with(\"data-test\")\n    assert value == \"значение\"\ndef test_get_element_attribute_none(element_finder):\n    value = element_finder.get_element_attribute(None, \"data-test\")\n    assert value is None\ndef test_find_element_by_name(element_finder):",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_get_element_attribute_none",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_get_element_attribute_none(element_finder):\n    value = element_finder.get_element_attribute(None, \"data-test\")\n    assert value is None\ndef test_find_element_by_name(element_finder):\n    # Проверяем, что find_element_by_name вызывает find_element с правильными аргументами\n    with patch.object(element_finder, \"find_element\", return_value=\"mocked\") as mock_find:\n        result = element_finder.find_element_by_name(\"username\")\n        mock_find.assert_called_once_with(\"name\", \"username\", 10)\n        assert result == \"mocked\"\ndef test_is_element_present_true(element_finder):",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_find_element_by_name",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_find_element_by_name(element_finder):\n    # Проверяем, что find_element_by_name вызывает find_element с правильными аргументами\n    with patch.object(element_finder, \"find_element\", return_value=\"mocked\") as mock_find:\n        result = element_finder.find_element_by_name(\"username\")\n        mock_find.assert_called_once_with(\"name\", \"username\", 10)\n        assert result == \"mocked\"\ndef test_is_element_present_true(element_finder):\n    # Мокаем driver.find_element чтобы не выбрасывал исключение\n    element_finder.browser.driver.find_element.return_value = MagicMock()\n    result = element_finder.is_element_present(\"id\", \"test-id\")",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_is_element_present_true",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_is_element_present_true(element_finder):\n    # Мокаем driver.find_element чтобы не выбрасывал исключение\n    element_finder.browser.driver.find_element.return_value = MagicMock()\n    result = element_finder.is_element_present(\"id\", \"test-id\")\n    assert result is True\ndef test_is_element_present_false(element_finder):\n    from selenium.common.exceptions import NoSuchElementException\n    element_finder.browser.driver.find_element.side_effect = NoSuchElementException(\"not found\")\n    result = element_finder.is_element_present(\"id\", \"test-id\")\n    assert result is False",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "test_is_element_present_false",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_form_interaction",
        "description": "tests.unit.core.web.test_form_interaction",
        "peekOfCode": "def test_is_element_present_false(element_finder):\n    from selenium.common.exceptions import NoSuchElementException\n    element_finder.browser.driver.find_element.side_effect = NoSuchElementException(\"not found\")\n    result = element_finder.is_element_present(\"id\", \"test-id\")\n    assert result is False",
        "detail": "tests.unit.core.web.test_form_interaction",
        "documentation": {}
    },
    {
        "label": "mock_driver",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_js_events",
        "description": "tests.unit.core.web.test_js_events",
        "peekOfCode": "def mock_driver():\n    return MagicMock()\n@pytest.fixture\ndef js_event_handler(mock_driver):\n    # Пример класса для работы с JS-событиями\n    class JSEventHandler:\n        def __init__(self, driver):\n            self.driver = driver\n        def trigger_event(self, element, event_name):\n            js = (",
        "detail": "tests.unit.core.web.test_js_events",
        "documentation": {}
    },
    {
        "label": "js_event_handler",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_js_events",
        "description": "tests.unit.core.web.test_js_events",
        "peekOfCode": "def js_event_handler(mock_driver):\n    # Пример класса для работы с JS-событиями\n    class JSEventHandler:\n        def __init__(self, driver):\n            self.driver = driver\n        def trigger_event(self, element, event_name):\n            js = (\n                f\"var evt = new Event('{event_name}', {{bubbles:true}});\"\n                \" arguments[0].dispatchEvent(evt);\"\n            )",
        "detail": "tests.unit.core.web.test_js_events",
        "documentation": {}
    },
    {
        "label": "test_trigger_custom_event",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_js_events",
        "description": "tests.unit.core.web.test_js_events",
        "peekOfCode": "def test_trigger_custom_event(js_event_handler, mock_driver):\n    element = MagicMock()\n    js_event_handler.trigger_event(element, \"focus\")\n    mock_driver.execute_script.assert_called_once()\n    args, kwargs = mock_driver.execute_script.call_args\n    assert \"dispatchEvent\" in args[0]\n    assert element in args\ndef test_trigger_click(js_event_handler, mock_driver):\n    element = MagicMock()\n    js_event_handler.trigger_click(element)",
        "detail": "tests.unit.core.web.test_js_events",
        "documentation": {}
    },
    {
        "label": "test_trigger_click",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_js_events",
        "description": "tests.unit.core.web.test_js_events",
        "peekOfCode": "def test_trigger_click(js_event_handler, mock_driver):\n    element = MagicMock()\n    js_event_handler.trigger_click(element)\n    mock_driver.execute_script.assert_called_once_with(\"arguments[0].click();\", element)\ndef test_set_value_via_js(js_event_handler, mock_driver):\n    element = MagicMock()\n    js_event_handler.set_value_via_js(element, \"hello\")\n    mock_driver.execute_script.assert_called_once_with(\n        \"arguments[0].value = arguments[1];\", element, \"hello\"\n    )",
        "detail": "tests.unit.core.web.test_js_events",
        "documentation": {}
    },
    {
        "label": "test_set_value_via_js",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_js_events",
        "description": "tests.unit.core.web.test_js_events",
        "peekOfCode": "def test_set_value_via_js(js_event_handler, mock_driver):\n    element = MagicMock()\n    js_event_handler.set_value_via_js(element, \"hello\")\n    mock_driver.execute_script.assert_called_once_with(\n        \"arguments[0].value = arguments[1];\", element, \"hello\"\n    )\ndef test_get_inner_text_via_js(js_event_handler, mock_driver):\n    element = MagicMock()\n    mock_driver.execute_script.return_value = \"текст\"\n    result = js_event_handler.get_inner_text_via_js(element)",
        "detail": "tests.unit.core.web.test_js_events",
        "documentation": {}
    },
    {
        "label": "test_get_inner_text_via_js",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_js_events",
        "description": "tests.unit.core.web.test_js_events",
        "peekOfCode": "def test_get_inner_text_via_js(js_event_handler, mock_driver):\n    element = MagicMock()\n    mock_driver.execute_script.return_value = \"текст\"\n    result = js_event_handler.get_inner_text_via_js(element)\n    mock_driver.execute_script.assert_called_once_with(\"return arguments[0].innerText;\", element)\n    assert result == \"текст\"\ndef test_trigger_event_js_error(js_event_handler, mock_driver):\n    element = MagicMock()\n    mock_driver.execute_script.side_effect = Exception(\"JS error\")\n    with pytest.raises(Exception) as excinfo:",
        "detail": "tests.unit.core.web.test_js_events",
        "documentation": {}
    },
    {
        "label": "test_trigger_event_js_error",
        "kind": 2,
        "importPath": "tests.unit.core.web.test_js_events",
        "description": "tests.unit.core.web.test_js_events",
        "peekOfCode": "def test_trigger_event_js_error(js_event_handler, mock_driver):\n    element = MagicMock()\n    mock_driver.execute_script.side_effect = Exception(\"JS error\")\n    with pytest.raises(Exception) as excinfo:\n        js_event_handler.trigger_event(element, \"focus\")\n    assert \"JS error\" in str(excinfo.value)",
        "detail": "tests.unit.core.web.test_js_events",
        "documentation": {}
    },
    {
        "label": "TestNavigation",
        "kind": 6,
        "importPath": "tests.unit.core.web.test_navigation",
        "description": "tests.unit.core.web.test_navigation",
        "peekOfCode": "class TestNavigation:\n    \"\"\"Тесты навигации по веб-страницам\"\"\"\n    def setup_method(self):\n        \"\"\"Настройка перед каждым тестом\"\"\"\n        # Создаем мок-объект для драйвера\n        self.mock_driver = MagicMock()\n        # Импортируем класс BrowserController\n        from core.web.browser_controller import BrowserController\n        # Создаем экземпляр BrowserController\n        self.browser = BrowserController(browser_type=\"chrome\", headless=True)",
        "detail": "tests.unit.core.web.test_navigation",
        "documentation": {}
    },
    {
        "label": "TestBrowserController",
        "kind": 6,
        "importPath": "tests.unit.core.web.test_web",
        "description": "tests.unit.core.web.test_web",
        "peekOfCode": "class TestBrowserController:\n    \"\"\"Тесты контроллера браузера\"\"\"\n    @pytest.fixture\n    def mock_webdriver(self):\n        \"\"\"Мок для Selenium WebDriver\"\"\"\n        with patch(\"core.web.browser_controller.webdriver\") as mock_webdriver:\n            # Настраиваем мок драйвера\n            mock_driver = MagicMock()\n            mock_webdriver.Chrome.return_value = mock_driver\n            yield mock_webdriver",
        "detail": "tests.unit.core.web.test_web",
        "documentation": {}
    },
    {
        "label": "TestElementFinder",
        "kind": 6,
        "importPath": "tests.unit.core.web.test_web",
        "description": "tests.unit.core.web.test_web",
        "peekOfCode": "class TestElementFinder:\n    \"\"\"Тесты искателя элементов\"\"\"\n    @pytest.fixture\n    def mock_browser_controller(self):\n        \"\"\"Мок для BrowserController\"\"\"\n        mock_browser = MagicMock()\n        mock_browser.driver = MagicMock()\n        return mock_browser\n    @pytest.fixture\n    def element_finder(self, mock_browser_controller):",
        "detail": "tests.unit.core.web.test_web",
        "documentation": {}
    },
    {
        "label": "TestComponentRegistry",
        "kind": 6,
        "importPath": "tests.unit.core.test_component_registry",
        "description": "tests.unit.core.test_component_registry",
        "peekOfCode": "class TestComponentRegistry:\n    \"\"\"Тесты реестра компонентов\"\"\"\n    @pytest.fixture\n    def registry(self):\n        \"\"\"Создает экземпляр ComponentRegistry\"\"\"\n        from core.component_registry import ComponentRegistry\n        return ComponentRegistry()\n    def test_register_component(self, registry):\n        \"\"\"Тест регистрации компонента\"\"\"\n        # Создаем тестовый компонент",
        "detail": "tests.unit.core.test_component_registry",
        "documentation": {}
    },
    {
        "label": "TestErrorHandler",
        "kind": 6,
        "importPath": "tests.unit.core.test_error_handler",
        "description": "tests.unit.core.test_error_handler",
        "peekOfCode": "class TestErrorHandler:\n    \"\"\"Тесты для обработчика ошибок\"\"\"\n    @pytest.fixture\n    def error_handler(self):\n        \"\"\"Фикстура для создания экземпляра ErrorHandler\"\"\"\n        handler = ErrorHandler()\n        # Заменяем логгер на мок\n        handler.logger = MagicMock()\n        return handler\n    def test_handle_error(self, error_handler):",
        "detail": "tests.unit.core.test_error_handler",
        "documentation": {}
    },
    {
        "label": "TestPluginManager",
        "kind": 6,
        "importPath": "tests.unit.core.test_plugin_manager",
        "description": "tests.unit.core.test_plugin_manager",
        "peekOfCode": "class TestPluginManager:\n    \"\"\"Тесты для менеджера плагинов\"\"\"\n    @pytest.fixture\n    def plugin_manager(self):\n        \"\"\"Фикстура для создания экземпляра PluginManager\"\"\"\n        # Создаем мок для реестра компонентов\n        registry = MagicMock()\n        # Создаем мок для обработчика ошибок\n        error_handler = MagicMock()\n        # Настраиваем реестр для возврата обработчика ошибок",
        "detail": "tests.unit.core.test_plugin_manager",
        "documentation": {}
    },
    {
        "label": "TestSystemInitializer",
        "kind": 6,
        "importPath": "tests.unit.core.test_system_initializer",
        "description": "tests.unit.core.test_system_initializer",
        "peekOfCode": "class TestSystemInitializer:\n    \"\"\"Тесты инициализатора системы\"\"\"\n    @pytest.fixture\n    def registry(self):\n        \"\"\"Создает мок реестра компонентов\"\"\"\n        registry = MagicMock()\n        registry.get.return_value = MagicMock()\n        registry.has.return_value = True\n        return registry\n    @pytest.fixture",
        "detail": "tests.unit.core.test_system_initializer",
        "documentation": {}
    },
    {
        "label": "db_engine",
        "kind": 2,
        "importPath": "tests.unit.db.conftest",
        "description": "tests.unit.db.conftest",
        "peekOfCode": "def db_engine():\n    \"\"\"\n    Создает тестовый движок БД с изолированной тестовой базой данных.\n    Эта фикстура:\n    1. Подключается к PostgreSQL\n    2. Создает отдельную тестовую БД, если она не существует\n    3. Настраивает схему таблиц\n    4. Очищает таблицы после всех тестов\n    \"\"\"\n    # Настройки подключения",
        "detail": "tests.unit.db.conftest",
        "documentation": {}
    },
    {
        "label": "db_session",
        "kind": 2,
        "importPath": "tests.unit.db.conftest",
        "description": "tests.unit.db.conftest",
        "peekOfCode": "def db_session(db_engine):\n    \"\"\"\n    Создает изолированную сессию БД для каждого теста.\n    Каждый тест получает \"чистую\" транзакцию, которая откатывается после\n    завершения теста, обеспечивая изоляцию между тестами.\n    \"\"\"\n    connection = db_engine.connect()\n    transaction = connection.begin()\n    session = Session(bind=connection)\n    yield session",
        "detail": "tests.unit.db.conftest",
        "documentation": {}
    },
    {
        "label": "test_user",
        "kind": 2,
        "importPath": "tests.unit.db.conftest",
        "description": "tests.unit.db.conftest",
        "peekOfCode": "def test_user(db_session):\n    \"\"\"\n    Создает тестового пользователя для использования в тестах.\n    Внимание: если тесту нужно видеть этого пользователя в БД,\n    необходимо сделать commit в фикстуре.\n    \"\"\"\n    user_data = {\n        \"username\": \"test_user\",\n        \"email\": \"test@example.com\",\n        \"password_hash\": \"hashed_password\",",
        "detail": "tests.unit.db.conftest",
        "documentation": {}
    },
    {
        "label": "TestDatabaseConnection",
        "kind": 6,
        "importPath": "tests.unit.db.test_connection",
        "description": "tests.unit.db.test_connection",
        "peekOfCode": "class TestDatabaseConnection:\n    def test_connection(self, db_engine):\n        \"\"\"Проверяем подключение к БД\"\"\"\n        connection = db_engine.connect()\n        assert connection is not None\n        connection.close()\n    def test_tables_exist(self, db_engine):\n        \"\"\"Проверяем, что все необходимые таблицы созданы\"\"\"\n        inspector = inspect(db_engine)\n        tables = inspector.get_table_names()",
        "detail": "tests.unit.db.test_connection",
        "documentation": {}
    },
    {
        "label": "db_engine",
        "kind": 2,
        "importPath": "tests.unit.db.test_connection",
        "description": "tests.unit.db.test_connection",
        "peekOfCode": "def db_engine():\n    \"\"\"Создает тестовый движок БД\"\"\"\n    # Формируем строку подключения с правильными учетными данными\n    # но сохраняем логику использования отдельной тестовой БД\n    db_user = \"neurolink\"\n    db_password = \"secure_password\"\n    db_host = \"localhost\"\n    db_port = \"5432\"\n    # Используем тестовую БД с тем же именем, что и в исходном коде\n    test_db_name = \"neurolink_test_db\"",
        "detail": "tests.unit.db.test_connection",
        "documentation": {}
    },
    {
        "label": "db_session",
        "kind": 2,
        "importPath": "tests.unit.db.test_connection",
        "description": "tests.unit.db.test_connection",
        "peekOfCode": "def db_session(db_engine):\n    \"\"\"Создает сессию БД для тестов\"\"\"\n    connection = db_engine.connect()\n    # Запускаем транзакцию\n    transaction = connection.begin()\n    session = Session(bind=connection)\n    yield session\n    # Откатываем изменения после теста\n    session.close()\n    transaction.rollback()",
        "detail": "tests.unit.db.test_connection",
        "documentation": {}
    },
    {
        "label": "TestUserCRUD",
        "kind": 6,
        "importPath": "tests.unit.db.test_crud",
        "description": "tests.unit.db.test_crud",
        "peekOfCode": "class TestUserCRUD:\n    def test_create_user(self, db_session):\n        \"\"\"Тест создания пользователя\"\"\"\n        user_data = {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password_hash\": \"hashed_password\",\n        }\n        user = create_user(db_session, **user_data)\n        assert user.id is not None",
        "detail": "tests.unit.db.test_crud",
        "documentation": {}
    },
    {
        "label": "TestAIModelCRUD",
        "kind": 6,
        "importPath": "tests.unit.db.test_crud",
        "description": "tests.unit.db.test_crud",
        "peekOfCode": "class TestAIModelCRUD:\n    def test_create_ai_model(self, db_session):\n        \"\"\"Тест создания модели ИИ\"\"\"\n        model_data = {\n            \"name\": \"Test GPT\",\n            \"provider\": \"OpenAI\",\n            \"is_api\": True,\n            \"base_url\": \"https://api.example.com\",\n            \"configuration\": {\"model\": \"test-model\"},\n        }",
        "detail": "tests.unit.db.test_crud",
        "documentation": {}
    },
    {
        "label": "TestTaskCRUD",
        "kind": 6,
        "importPath": "tests.unit.db.test_crud",
        "description": "tests.unit.db.test_crud",
        "peekOfCode": "class TestTaskCRUD:\n    @pytest.fixture\n    def test_user(self, db_session):\n        \"\"\"Создает тестового пользователя\"\"\"\n        user = create_user(\n            db_session, username=\"taskuser\", email=\"task@example.com\", password_hash=\"hash\"\n        )\n        return user\n    def test_create_task(self, db_session, test_user):\n        \"\"\"Тест создания задачи\"\"\"",
        "detail": "tests.unit.db.test_crud",
        "documentation": {}
    },
    {
        "label": "TestMigrations",
        "kind": 6,
        "importPath": "tests.unit.db.test_migrations",
        "description": "tests.unit.db.test_migrations",
        "peekOfCode": "class TestMigrations:\n    @pytest.fixture\n    def alembic_config(self):\n        \"\"\"Создает конфигурацию Alembic\"\"\"\n        config = Config(\"alembic.ini\")\n        return config\n    def _create_test_db_url(self, test_db_name):\n        \"\"\"Создает URL для тестовой базы данных с правильным пользователем.\"\"\"\n        parsed = urlparse(DATABASE_URL)\n        # Заменяем только имя базы данных, оставляя пользователя neurolink",
        "detail": "tests.unit.db.test_migrations",
        "documentation": {}
    },
    {
        "label": "TestPaginationAndFiltering",
        "kind": 6,
        "importPath": "tests.unit.db.test_pagination",
        "description": "tests.unit.db.test_pagination",
        "peekOfCode": "class TestPaginationAndFiltering:\n    def test_basic_pagination(self, db_session, user_with_many_tasks):\n        \"\"\"Тест базовой пагинации\"\"\"\n        user = user_with_many_tasks\n        # Первая страница (10 элементов)\n        page1 = get_tasks_with_pagination(db_session, user_id=user.id, page=1, per_page=10)\n        assert len(page1.items) == 10\n        assert page1.total == 50\n        assert page1.pages == 5\n        assert page1.has_next is True  # Исправлено: == True -> is True",
        "detail": "tests.unit.db.test_pagination",
        "documentation": {}
    },
    {
        "label": "user_with_many_tasks",
        "kind": 2,
        "importPath": "tests.unit.db.test_pagination",
        "description": "tests.unit.db.test_pagination",
        "peekOfCode": "def user_with_many_tasks(db_session):\n    \"\"\"Создает пользователя с большим количеством задач для тестов пагинации\"\"\"\n    user = create_user(\n        db_session, username=\"pageuser\", email=\"page@example.com\", password_hash=\"hash\"\n    )\n    # Создаем 50 задач разных типов\n    for i in range(50):\n        status = \"completed\" if i % 5 == 0 else \"in_progress\" if i % 3 == 0 else \"created\"\n        priority = (i % 3) + 1  # приоритеты 1, 2, 3\n        create_task(",
        "detail": "tests.unit.db.test_pagination",
        "documentation": {}
    },
    {
        "label": "TestDatabasePerformance",
        "kind": 6,
        "importPath": "tests.unit.db.test_performance",
        "description": "tests.unit.db.test_performance",
        "peekOfCode": "class TestDatabasePerformance:\n    @pytest.fixture\n    def populated_db(self, db_session):\n        \"\"\"Создает набор тестовых данных\"\"\"\n        # Создаем пользователя\n        user = create_user(\n            db_session, username=\"perftest\", email=\"perf@example.com\", password_hash=\"hash\"\n        )\n        # Создаем моделb ИИ\n        model = create_ai_model(db_session, name=\"Perf Model\", provider=\"Test\", is_api=True)",
        "detail": "tests.unit.db.test_performance",
        "documentation": {}
    },
    {
        "label": "TestUserRepository",
        "kind": 6,
        "importPath": "tests.unit.db.test_repository",
        "description": "tests.unit.db.test_repository",
        "peekOfCode": "class TestUserRepository:\n    def test_user_repository_operations(self, db_session):\n        \"\"\"Тест операций репозитория пользователей\"\"\"\n        user_repo = UserRepository(db_session)\n        # Создаем пользователя\n        user = user_repo.create(\n            username=\"repo_user\",\n            email=\"repo@example.com\",\n            password_hash=\"hashed_password\",\n            display_name=\"Repository Test User\",",
        "detail": "tests.unit.db.test_repository",
        "documentation": {}
    },
    {
        "label": "TestTaskRepository",
        "kind": 6,
        "importPath": "tests.unit.db.test_repository",
        "description": "tests.unit.db.test_repository",
        "peekOfCode": "class TestTaskRepository:\n    @pytest.fixture\n    def test_user(self, db_session):\n        \"\"\"Создает тестового пользователя для задач\"\"\"\n        user_repo = UserRepository(db_session)\n        return user_repo.create(\n            username=\"task_repo_user\", email=\"taskrepo@example.com\", password_hash=\"hash\"\n        )\n    def test_task_repository_basic_operations(self, db_session, test_user):\n        \"\"\"Тест основных операций репозитория задач\"\"\"",
        "detail": "tests.unit.db.test_repository",
        "documentation": {}
    },
    {
        "label": "TestWorkflowRepository",
        "kind": 6,
        "importPath": "tests.unit.db.test_repository",
        "description": "tests.unit.db.test_repository",
        "peekOfCode": "class TestWorkflowRepository:\n    @pytest.fixture\n    def test_user(self, db_session):\n        \"\"\"Создает тестового пользователя для рабочих процессов\"\"\"\n        user_repo = UserRepository(db_session)\n        return user_repo.create(\n            username=\"workflow_repo_user\", email=\"workflowrepo@example.com\", password_hash=\"hash\"\n        )\n    def test_workflow_repository_operations(self, db_session, test_user):\n        \"\"\"Тест операций репозитория рабочих процессов\"\"\"",
        "detail": "tests.unit.db.test_repository",
        "documentation": {}
    },
    {
        "label": "TestPasswordSecurity",
        "kind": 6,
        "importPath": "tests.unit.db.test_security",
        "description": "tests.unit.db.test_security",
        "peekOfCode": "class TestPasswordSecurity:\n    \"\"\"Тесты безопасности паролей.\"\"\"\n    def test_password_hashing(self):\n        \"\"\"Тест хеширования пароля.\"\"\"\n        password = \"test_password_123\"\n        password_hash, salt = hash_password(password)\n        assert password_hash != password\n        assert len(salt) > 0\n        assert verify_password(password, password_hash, salt)\n    def test_password_verification_fail(self):",
        "detail": "tests.unit.db.test_security",
        "documentation": {}
    },
    {
        "label": "TestJWTSecurity",
        "kind": 6,
        "importPath": "tests.unit.db.test_security",
        "description": "tests.unit.db.test_security",
        "peekOfCode": "class TestJWTSecurity:\n    \"\"\"Тесты безопасности JWT.\"\"\"\n    def test_token_creation_and_verification(self):\n        \"\"\"Тест создания и проверки токена.\"\"\"\n        data = {\"user_id\": 1, \"username\": \"test_user\"}\n        token = create_access_token(data)\n        assert token is not None\n        assert len(token) > 0\n        decoded_data = verify_token(token)\n        assert decoded_data[\"user_id\"] == 1",
        "detail": "tests.unit.db.test_security",
        "documentation": {}
    },
    {
        "label": "TestAuthService",
        "kind": 6,
        "importPath": "tests.unit.db.test_security",
        "description": "tests.unit.db.test_security",
        "peekOfCode": "class TestAuthService:\n    \"\"\"Тесты сервиса аутентификации.\"\"\"\n    def test_register_user(self, auth_service):\n        \"\"\"Тест регистрации пользователя.\"\"\"\n        user = auth_service.register_user(\n            username=\"new_user\",\n            email=\"new@example.com\",\n            password=\"secure_password\",\n            display_name=\"New User\",\n        )",
        "detail": "tests.unit.db.test_security",
        "documentation": {}
    },
    {
        "label": "TestPermissionService",
        "kind": 6,
        "importPath": "tests.unit.db.test_security",
        "description": "tests.unit.db.test_security",
        "peekOfCode": "class TestPermissionService:\n    \"\"\"Тесты сервиса прав доступа.\"\"\"\n    def test_check_admin_permissions(self, permission_service, auth_service):\n        \"\"\"Тест прав администратора.\"\"\"\n        # Создаем администратора\n        admin = auth_service.register_user(  # ✅ ИСПРАВЛЕНО: получаем User объект\n            username=\"admin\", email=\"admin@example.com\", password=\"admin_password\", role=\"admin\"\n        )\n        assert admin is not None\n        # Проверяем права администратора",
        "detail": "tests.unit.db.test_security",
        "documentation": {}
    },
    {
        "label": "TestSecurityIntegration",
        "kind": 6,
        "importPath": "tests.unit.db.test_security",
        "description": "tests.unit.db.test_security",
        "peekOfCode": "class TestSecurityIntegration:\n    \"\"\"Интеграционные тесты безопасности.\"\"\"\n    def test_full_auth_workflow(self, auth_service, permission_service):\n        \"\"\"Тест полного цикла аутентификации и авторизации.\"\"\"\n        # Регистрация\n        user = auth_service.register_user(  # ✅ ИСПРАВЛЕНО: получаем User объект\n            username=\"integration_user\",\n            email=\"integration@example.com\",\n            password=\"secure_password\",\n            role=\"user\",",
        "detail": "tests.unit.db.test_security",
        "documentation": {}
    },
    {
        "label": "db_session",
        "kind": 2,
        "importPath": "tests.unit.db.test_security",
        "description": "tests.unit.db.test_security",
        "peekOfCode": "def db_session():\n    \"\"\"Создает тестовую сессию базы данных.\"\"\"\n    engine = create_engine(\"sqlite:///:memory:\")\n    Base.metadata.create_all(engine)\n    SessionLocal = sessionmaker(bind=engine)\n    session = SessionLocal()\n    yield session\n    session.close()\n@pytest.fixture\ndef user_repository(db_session):",
        "detail": "tests.unit.db.test_security",
        "documentation": {}
    },
    {
        "label": "user_repository",
        "kind": 2,
        "importPath": "tests.unit.db.test_security",
        "description": "tests.unit.db.test_security",
        "peekOfCode": "def user_repository(db_session):\n    \"\"\"Создает репозиторий пользователей для тестов.\"\"\"\n    return UserRepository(db_session)\n@pytest.fixture\ndef auth_service(db_session):\n    \"\"\"Создает сервис аутентификации для тестов.\"\"\"\n    return AuthService(db_session)\n@pytest.fixture\ndef permission_service(db_session):\n    \"\"\"Создает сервис прав доступа для тестов.\"\"\"",
        "detail": "tests.unit.db.test_security",
        "documentation": {}
    },
    {
        "label": "auth_service",
        "kind": 2,
        "importPath": "tests.unit.db.test_security",
        "description": "tests.unit.db.test_security",
        "peekOfCode": "def auth_service(db_session):\n    \"\"\"Создает сервис аутентификации для тестов.\"\"\"\n    return AuthService(db_session)\n@pytest.fixture\ndef permission_service(db_session):\n    \"\"\"Создает сервис прав доступа для тестов.\"\"\"\n    return PermissionService(db_session)\nclass TestPasswordSecurity:\n    \"\"\"Тесты безопасности паролей.\"\"\"\n    def test_password_hashing(self):",
        "detail": "tests.unit.db.test_security",
        "documentation": {}
    },
    {
        "label": "permission_service",
        "kind": 2,
        "importPath": "tests.unit.db.test_security",
        "description": "tests.unit.db.test_security",
        "peekOfCode": "def permission_service(db_session):\n    \"\"\"Создает сервис прав доступа для тестов.\"\"\"\n    return PermissionService(db_session)\nclass TestPasswordSecurity:\n    \"\"\"Тесты безопасности паролей.\"\"\"\n    def test_password_hashing(self):\n        \"\"\"Тест хеширования пароля.\"\"\"\n        password = \"test_password_123\"\n        password_hash, salt = hash_password(password)\n        assert password_hash != password",
        "detail": "tests.unit.db.test_security",
        "documentation": {}
    },
    {
        "label": "TestTransactions",
        "kind": 6,
        "importPath": "tests.unit.db.test_transactions",
        "description": "tests.unit.db.test_transactions",
        "peekOfCode": "class TestTransactions:\n    @pytest.fixture\n    def repositories(self, db_session):\n        \"\"\"Создает репозитории для тестирования\"\"\"\n        return {\n            \"user_repo\": UserRepository(db_session),\n            \"task_repo\": TaskRepository(db_session),\n            \"transaction\": TransactionManager(db_session),\n        }\n    def test_successful_transaction(self, db_session, repositories):",
        "detail": "tests.unit.db.test_transactions",
        "documentation": {}
    },
    {
        "label": "TestDataValidation",
        "kind": 6,
        "importPath": "tests.unit.db.test_validation",
        "description": "tests.unit.db.test_validation",
        "peekOfCode": "class TestDataValidation:\n    def test_required_fields(self, db_session):\n        \"\"\"Тест обязательных полей\"\"\"\n        # Проверка пользователя без обязательного поля\n        with pytest.raises(IntegrityError):\n            db_session.add(User(email=\"missing_username@example.com\", password_hash=\"hash\"))\n            db_session.flush()\n        db_session.rollback()\n        # Проверка задачи без обязательного поля\n        with pytest.raises(IntegrityError):",
        "detail": "tests.unit.db.test_validation",
        "documentation": {}
    },
    {
        "label": "finder",
        "kind": 5,
        "importPath": "tests.utils.check_element_finder",
        "description": "tests.utils.check_element_finder",
        "peekOfCode": "finder = ElementFinder(None)\nprint(\"Методы класса:\", [m for m in dir(finder) if not m.startswith(\"_\")])\nprint(\"Есть ли find_elements_by_tag:\", hasattr(finder, \"find_elements_by_tag\"))",
        "detail": "tests.utils.check_element_finder",
        "documentation": {}
    },
    {
        "label": "create_chrome_driver",
        "kind": 2,
        "importPath": "tests.utils.chrome_fixed_function",
        "description": "tests.utils.chrome_fixed_function",
        "peekOfCode": "def create_chrome_driver(base_url: str) -> webdriver.Chrome:\n    \"\"\"Создание Chrome WebDriver с максимальной совместимостью для очень старых GPU\"\"\"\n    chrome_options = Options()\n    # ИСПРАВЛЕНО: Максимальная совместимость для GTX 550 Ti\n    chrome_options.add_argument(\"--headless=new\")\n    chrome_options.add_argument(\"--no-sandbox\")\n    chrome_options.add_argument(\"--disable-dev-shm-usage\")\n    chrome_options.add_argument(\"--disable-gpu\")\n    chrome_options.add_argument(\"--disable-gpu-sandbox\")\n    chrome_options.add_argument(\"--use-gl=disabled\")",
        "detail": "tests.utils.chrome_fixed_function",
        "documentation": {}
    },
    {
        "label": "test_port",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def test_port():\n    \"\"\"Унифицированный тестовый порт для всех тестов.\"\"\"\n    return TEST_PORT\n@pytest.fixture(scope=\"session\")\ndef base_url(test_port):\n    \"\"\"Базовый URL для тестов.\"\"\"\n    return f\"http://localhost:{test_port}\"\n# ===== ФИКСТУРЫ БАЗЫ ДАННЫХ =====\n@pytest.fixture(scope=\"session\")\ndef test_db_engine():",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "base_url",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def base_url(test_port):\n    \"\"\"Базовый URL для тестов.\"\"\"\n    return f\"http://localhost:{test_port}\"\n# ===== ФИКСТУРЫ БАЗЫ ДАННЫХ =====\n@pytest.fixture(scope=\"session\")\ndef test_db_engine():\n    \"\"\"Создает тестовый движок базы данных.\"\"\"\n    # Создаем временный файл для SQLite\n    db_fd, db_path = tempfile.mkstemp(suffix=\".db\")\n    test_db_url = f\"sqlite:///{db_path}\"",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "test_db_engine",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def test_db_engine():\n    \"\"\"Создает тестовый движок базы данных.\"\"\"\n    # Создаем временный файл для SQLite\n    db_fd, db_path = tempfile.mkstemp(suffix=\".db\")\n    test_db_url = f\"sqlite:///{db_path}\"\n    print(f\"🔍 [DB] Создаем тестовую БД: {test_db_url}\")\n    # Патчим DATABASE_URL перед импортом\n    with patch.dict(os.environ, {\"DATABASE_URL\": test_db_url}):\n        try:\n            # ✅ ИСПРАВЛЕНО: Импортируем после патчинга переменной окружения",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "db_session",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def db_session(test_db_engine):\n    \"\"\"Создает изолированную сессию БД для каждого теста.\"\"\"\n    from sqlalchemy.orm import sessionmaker\n    SessionLocal = sessionmaker(bind=test_db_engine)\n    session = SessionLocal()\n    try:\n        yield session\n    finally:\n        session.rollback()\n        session.close()",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "test_app",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def test_app(test_db_engine):\n    \"\"\"Создает тестовое Flask приложение.\"\"\"\n    # Патчим DATABASE_URL для приложения\n    test_db_url = str(test_db_engine.url)\n    print(f\"🔍 [APP] Инициализируем тестовое приложение с БД: {test_db_url}\")\n    with patch.dict(os.environ, {\"DATABASE_URL\": test_db_url}):\n        try:\n            from app import init_app\n            app = init_app()\n            app.config.update(",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "app_client",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def app_client(test_app, db_session):\n    \"\"\"Создает тестовый клиент Flask для API тестирования.\"\"\"\n    # Патчим get_db для использования тестовой сессии\n    def get_test_db():\n        yield db_session\n    import core.db.connection\n    original_get_db = core.db.connection.get_db\n    # ✅ ИСПРАВЛЕНО: Более надежное патчинг\n    core.db.connection.get_db = get_test_db\n    try:",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "ui_client",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def ui_client(base_url):\n    \"\"\"Создает WebDriver для UI тестирования.\"\"\"\n    print(\"🔍 Настройка Chrome WebDriver...\")\n    chrome_options = Options()\n    # Режим отладки через переменную окружения\n    debug_mode = os.environ.get(\"UI_DEBUG\", \"false\").lower() == \"true\"\n    if not debug_mode:\n        chrome_options.add_argument(\"--headless\")\n    # Стабильные опции для Windows\n    chrome_options.add_argument(\"--no-sandbox\")",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "sample_user",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def sample_user(db_session):\n    \"\"\"Создает тестового пользователя.\"\"\"\n    import secrets\n    from core.db.models import User\n    from core.security.password import hash_password\n    # Генерируем уникальные данные для каждого теста\n    user_id = str(uuid.uuid4())[:8]\n    salt = secrets.token_hex(16)\n    password_hash, _ = hash_password(\"testpassword123\", salt)\n    user = User(",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "authenticated_client",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def authenticated_client(app_client, sample_user):\n    \"\"\"Клиент с аутентифицированным пользователем.\"\"\"\n    import json\n    # Выполняем вход\n    login_data = {\"username\": sample_user.username, \"password\": \"testpassword123\"}\n    response = app_client.post(\n        \"/api/auth/login\", data=json.dumps(login_data), content_type=\"application/json\"\n    )\n    assert response.status_code == 200\n    result = response.get_json()",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "unique_test_id",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def unique_test_id():\n    \"\"\"Генерирует уникальный ID для каждого теста.\"\"\"\n    return str(uuid.uuid4())[:8]\n# ===== НАСТРОЙКИ PYTEST =====\ndef pytest_configure(config):\n    \"\"\"Конфигурация pytest.\"\"\"\n    # Добавляем маркеры\n    config.addinivalue_line(\"markers\", \"ui: marks tests as UI tests\")\n    config.addinivalue_line(\"markers\", \"integration: marks tests as integration tests\")\n    config.addinivalue_line(\"markers\", \"auth: marks tests as authentication tests\")",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def pytest_configure(config):\n    \"\"\"Конфигурация pytest.\"\"\"\n    # Добавляем маркеры\n    config.addinivalue_line(\"markers\", \"ui: marks tests as UI tests\")\n    config.addinivalue_line(\"markers\", \"integration: marks tests as integration tests\")\n    config.addinivalue_line(\"markers\", \"auth: marks tests as authentication tests\")\n    config.addinivalue_line(\"markers\", \"slow: marks tests as slow running\")\ndef pytest_collection_modifyitems(config, items):\n    \"\"\"Автоматически помечает тесты маркерами.\"\"\"\n    for item in items:",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_collection_modifyitems",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def pytest_collection_modifyitems(config, items):\n    \"\"\"Автоматически помечает тесты маркерами.\"\"\"\n    for item in items:\n        # UI тесты\n        if \"ui\" in item.nodeid.lower():\n            item.add_marker(pytest.mark.ui)\n        # Интеграционные тесты\n        if \"integration\" in item.nodeid:\n            item.add_marker(pytest.mark.integration)\n        # Тесты аутентификации",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "cleanup_test_environment",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def cleanup_test_environment():\n    \"\"\"Автоматически очищает тестовую среду.\"\"\"\n    print(\"🔍 Подготовка тестовой среды...\")\n    # Очистка перед тестами\n    yield\n    print(\"✅ Завершение тестовой сессии\")\n    # Финальная очистка\n# ===== ОТЛАДОЧНЫЕ ФИКСТУРЫ =====\n@pytest.fixture(autouse=True)\ndef test_debug_info(request):",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "test_debug_info",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def test_debug_info(request):\n    \"\"\"Автоматически выводит отладочную информацию для тестов.\"\"\"\n    test_name = request.node.name\n    test_file = request.fspath.basename\n    print(f\"\\n🧪 [TEST] Запуск: {test_file}::{test_name}\")\n    yield\n    print(f\"✅ [TEST] Завершен: {test_file}::{test_name}\")\n# ===== ДОПОЛНИТЕЛЬНЫЕ УТИЛИТЫ =====\n@pytest.fixture\ndef temp_file():",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "temp_file",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def temp_file():\n    \"\"\"Создает временный файл для тестов.\"\"\"\n    import tempfile\n    fd, path = tempfile.mkstemp()\n    yield path\n    try:\n        os.close(fd)\n        os.unlink(path)\n    except OSError:\n        pass",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "temp_dir",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def temp_dir():\n    \"\"\"Создает временную директорию для тестов.\"\"\"\n    import shutil\n    import tempfile\n    temp_dir = tempfile.mkdtemp()\n    yield temp_dir\n    try:\n        shutil.rmtree(temp_dir)\n    except OSError:\n        pass",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "mock_huggingface_api",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def mock_huggingface_api():\n    \"\"\"Мокает API HuggingFace для тестов.\"\"\"\n    with patch(\"services.huggingface_service.requests.post\") as mock_post:\n        mock_post.return_value.json.return_value = {\n            \"generated_text\": \"Mock response from HuggingFace\"\n        }\n        mock_post.return_value.status_code = 200\n        yield mock_post\n@pytest.fixture\ndef mock_openai_api():",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "mock_openai_api",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def mock_openai_api():\n    \"\"\"Мокает API OpenAI для тестов.\"\"\"\n    with patch(\"services.ai_service.openai\") as mock_openai:\n        mock_openai.Completion.create.return_value = {\n            \"choices\": [{\"text\": \"Mock response from OpenAI\"}]\n        }\n        yield mock_openai\n# ===== ТЕСТОВЫЕ ДАННЫЕ =====\n@pytest.fixture\ndef sample_ai_model():",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "sample_ai_model",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def sample_ai_model():\n    \"\"\"Создает пример AI модели для тестов.\"\"\"\n    return {\n        \"id\": \"test-model-1\",\n        \"name\": \"Test Model\",\n        \"provider\": \"test\",\n        \"is_api\": True,\n        \"base_url\": \"https://api.test.com\",\n        \"api_key_name\": \"TEST_API_KEY\",\n        \"is_active\": True,",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "sample_task",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def sample_task():\n    \"\"\"Создает пример задачи для тестов.\"\"\"\n    return {\n        \"id\": \"test-task-1\",\n        \"title\": \"Test Task\",\n        \"description\": \"Test task description\",\n        \"status\": \"created\",\n        \"priority\": 1,\n    }\n@pytest.fixture",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "sample_workflow",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def sample_workflow():\n    \"\"\"Создает пример workflow для тестов.\"\"\"\n    return {\n        \"id\": \"test-workflow-1\",\n        \"name\": \"Test Workflow\",\n        \"description\": \"Test workflow description\",\n        \"is_active\": True,\n        \"steps\": [\n            {\"name\": \"Step 1\", \"description\": \"First step\", \"order\": 1, \"configuration\": {}},\n            {\"name\": \"Step 2\", \"description\": \"Second step\", \"order\": 2, \"configuration\": {}},",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "windows_environment",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def windows_environment():\n    \"\"\"Проверяет, что тесты запускаются на Windows.\"\"\"\n    if os.name != \"nt\":\n        pytest.skip(\"Тест предназначен только для Windows\")\n    return {\"platform\": \"windows\", \"powershell_available\": True, \"cmd_available\": True}\n# ===== ПРОИЗВОДИТЕЛЬНОСТЬ =====\n@pytest.fixture\ndef performance_monitor():\n    \"\"\"Монитор производительности для тестов.\"\"\"\n    import time",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "performance_monitor",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def performance_monitor():\n    \"\"\"Монитор производительности для тестов.\"\"\"\n    import time\n    import psutil\n    start_time = time.time()\n    start_memory = psutil.Process().memory_info().rss\n    yield\n    end_time = time.time()\n    end_memory = psutil.Process().memory_info().rss\n    duration = end_time - start_time",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "mock_requests",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def mock_requests():\n    \"\"\"Мокает HTTP запросы для тестов.\"\"\"\n    with patch(\"requests.get\") as mock_get, patch(\"requests.post\") as mock_post:\n        # Настройка стандартных ответов\n        mock_get.return_value.status_code = 200\n        mock_get.return_value.json.return_value = {\"status\": \"ok\"}\n        mock_post.return_value.status_code = 200\n        mock_post.return_value.json.return_value = {\"success\": True}\n        yield {\"get\": mock_get, \"post\": mock_post}\n# ===== ЛОГИРОВАНИЕ В ТЕСТАХ =====",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "capture_logs",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def capture_logs():\n    \"\"\"Захватывает логи для анализа в тестах.\"\"\"\n    import logging\n    from io import StringIO\n    log_capture = StringIO()\n    handler = logging.StreamHandler(log_capture)\n    # Добавляем обработчик к корневому логгеру\n    root_logger = logging.getLogger()\n    root_logger.addHandler(handler)\n    yield log_capture",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_setup",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def pytest_runtest_setup(item):\n    \"\"\"Настройки, применяемые перед каждым тестом.\"\"\"\n    # Устанавливаем тестовую среду\n    os.environ[\"TESTING\"] = \"true\"\n    # Отключаем внешние API в тестах по умолчанию\n    os.environ[\"DISABLE_EXTERNAL_APIS\"] = \"true\"\ndef pytest_runtest_teardown(item):\n    \"\"\"Очистка после каждого теста.\"\"\"\n    # Очищаем временные переменные окружения\n    test_vars = [k for k in os.environ.keys() if k.startswith(\"TEST_\")]",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_teardown",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def pytest_runtest_teardown(item):\n    \"\"\"Очистка после каждого теста.\"\"\"\n    # Очищаем временные переменные окружения\n    test_vars = [k for k in os.environ.keys() if k.startswith(\"TEST_\")]\n    for var in test_vars:\n        if var not in [\"TEST_PORT\", \"TESTING\"]:  # Сохраняем основные переменные\n            os.environ.pop(var, None)",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "TEST_PORT",
        "kind": 5,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "TEST_PORT = 5100\nprint(f\"🧪 [TESTS] Используем унифицированный тестовый порт: {TEST_PORT}\")\n# Устанавливаем в переменные окружения для других компонентов\nos.environ[\"TEST_PORT\"] = str(TEST_PORT)\nos.environ[\"TESTING\"] = \"true\"\n# ===== БАЗОВЫЕ ФИКСТУРЫ =====\n@pytest.fixture(scope=\"session\")\ndef test_port():\n    \"\"\"Унифицированный тестовый порт для всех тестов.\"\"\"\n    return TEST_PORT",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "os.environ[\"TEST_PORT\"]",
        "kind": 5,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "os.environ[\"TEST_PORT\"] = str(TEST_PORT)\nos.environ[\"TESTING\"] = \"true\"\n# ===== БАЗОВЫЕ ФИКСТУРЫ =====\n@pytest.fixture(scope=\"session\")\ndef test_port():\n    \"\"\"Унифицированный тестовый порт для всех тестов.\"\"\"\n    return TEST_PORT\n@pytest.fixture(scope=\"session\")\ndef base_url(test_port):\n    \"\"\"Базовый URL для тестов.\"\"\"",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "os.environ[\"TESTING\"]",
        "kind": 5,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "os.environ[\"TESTING\"] = \"true\"\n# ===== БАЗОВЫЕ ФИКСТУРЫ =====\n@pytest.fixture(scope=\"session\")\ndef test_port():\n    \"\"\"Унифицированный тестовый порт для всех тестов.\"\"\"\n    return TEST_PORT\n@pytest.fixture(scope=\"session\")\ndef base_url(test_port):\n    \"\"\"Базовый URL для тестов.\"\"\"\n    return f\"http://localhost:{test_port}\"",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "extract_code_from_response",
        "kind": 2,
        "importPath": "utils.helpers",
        "description": "utils.helpers",
        "peekOfCode": "def extract_code_from_response(response):\n    \"\"\"Извлекает код Python из ответа нейросети\"\"\"\n    if not response:\n        return None\n    # Ищем код между тройными обратными кавычками\n    code_start = response.find(\"\")\n    if code_start != -1:\n        code_start += 9  # длина \"python\"\n        code_end = response.find(\"\", code_start)\n        if code_end != -1:",
        "detail": "utils.helpers",
        "documentation": {}
    },
    {
        "label": "extract_math_expression",
        "kind": 2,
        "importPath": "utils.helpers",
        "description": "utils.helpers",
        "peekOfCode": "def extract_math_expression(text):\n    \"\"\"Извлекает математическое выражение из текста\"\"\"\n    # Ищем числа и математические операторы\n    pattern = r\"(\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+)\"\n    matches = re.findall(pattern, text)\n    if matches:\n        return matches[0].replace(\" \", \"\")\n    return None\ndef add_interrupt_checks(code):\n    \"\"\"",
        "detail": "utils.helpers",
        "documentation": {}
    },
    {
        "label": "add_interrupt_checks",
        "kind": 2,
        "importPath": "utils.helpers",
        "description": "utils.helpers",
        "peekOfCode": "def add_interrupt_checks(code):\n    \"\"\"\n    Добавляет проверки прерывания в код\n    Вставляет проверки check_interrupt() после каждого вызова time.sleep()\n    и в начало каждого цикла for/while\n    \"\"\"\n    if not code:\n        return code\n    # Добавляем проверку после каждого time.sleep()\n    code = re.sub(",
        "detail": "utils.helpers",
        "documentation": {}
    },
    {
        "label": "check_interrupt_during_operation",
        "kind": 2,
        "importPath": "utils.helpers",
        "description": "utils.helpers",
        "peekOfCode": "def check_interrupt_during_operation(operation_name, interval=0.5, max_time=30):\n    \"\"\"\n    Выполняет проверку прерывания во время длительных операций\n    Args:\n        operation_name: Название операции для логирования\n        interval: Интервал проверки в секундах\n        max_time: Максимальное время выполнения в секундах\n    Returns:\n        True, если операция должна быть прервана, False в противном случае\n    \"\"\"",
        "detail": "utils.helpers",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "utils.helpers",
        "description": "utils.helpers",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\ndef extract_code_from_response(response):\n    \"\"\"Извлекает код Python из ответа нейросети\"\"\"\n    if not response:\n        return None\n    # Ищем код между тройными обратными кавычками\n    code_start = response.find(\"\")\n    if code_start != -1:\n        code_start += 9  # длина \"python\"\n        code_end = response.find(\"\", code_start)",
        "detail": "utils.helpers",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "peekOfCode": "def setup_logging(app):\n    \"\"\"Настройка системы логирования\"\"\"\n    # Создаем директорию для логов, если она не существует\n    os.makedirs(Config.LOGS_DIR, exist_ok=True)\n    # Форматтер для логов\n    formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n    # Настройка логгера для истории команд (для пользователя)\n    history_handler = RotatingFileHandler(\n        Config.SUMMARY_LOG_FILE,\n        maxBytes=Config.MAX_LOG_SIZE,",
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "ensure_log_files_exist",
        "kind": 2,
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "peekOfCode": "def ensure_log_files_exist():\n    \"\"\"Проверяет существование файлов журнала и создает их при необходимости\"\"\"\n    os.makedirs(Config.LOGS_DIR, exist_ok=True)\n    log_files = [Config.DETAILED_LOG_FILE, Config.SUMMARY_LOG_FILE, Config.SYSTEM_LOG_FILE]\n    for file in log_files:\n        if not os.path.exists(file):\n            # Добавляем encoding='utf-8'\n            with open(file, \"w\", encoding=\"utf-8\") as f:\n                f.write(f\"# Журнал команд создан {datetime.now().isoformat()}\\n\")\n# Получаем логгеры",
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "filter_sensitive_data",
        "kind": 2,
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "peekOfCode": "def filter_sensitive_data(text):\n    \"\"\"\n    Фильтрует конфиденциальные данные из текста\n    Args:\n        text: Исходный текст\n    Returns:\n        Текст с замаскированными конфиденциальными данными\n    \"\"\"\n    import re\n    # Список паттернов для фильтрации",
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "log_execution_summary",
        "kind": 2,
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "peekOfCode": "def log_execution_summary(execution, final=False):\n    \"\"\"\n    Логирует информацию о выполнении команды\n    Args:\n        execution: Объект CommandExecution с информацией о выполнении\n        final: Флаг, указывающий, является ли это финальным логированием команды\n    \"\"\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    # Фильтруем конфиденциальные данные\n    filtered_command = filter_sensitive_data(execution.command_text)",
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "init_logging_system",
        "kind": 2,
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "peekOfCode": "def init_logging_system():\n    \"\"\"\n    Инициализирует систему логирования при запуске приложения\n    \"\"\"\n    from utils.log_maintenance import clean_old_logs, ensure_log_files_exist\n    # Создаем необходимые файлы логов\n    ensure_log_files_exist()\n    # Очищаем старые логи (старше 30 дней)\n    clean_old_logs(30)\n    # Логируем информацию о запуске",
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "history_logger",
        "kind": 5,
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "peekOfCode": "history_logger = logging.getLogger(\"command_history\")\ndetailed_logger = logging.getLogger(\"detailed_log\")\nsystem_logger = logging.getLogger(\"neuro_assistant\")\ndef filter_sensitive_data(text):\n    \"\"\"\n    Фильтрует конфиденциальные данные из текста\n    Args:\n        text: Исходный текст\n    Returns:\n        Текст с замаскированными конфиденциальными данными",
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "detailed_logger",
        "kind": 5,
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "peekOfCode": "detailed_logger = logging.getLogger(\"detailed_log\")\nsystem_logger = logging.getLogger(\"neuro_assistant\")\ndef filter_sensitive_data(text):\n    \"\"\"\n    Фильтрует конфиденциальные данные из текста\n    Args:\n        text: Исходный текст\n    Returns:\n        Текст с замаскированными конфиденциальными данными\n    \"\"\"",
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "system_logger",
        "kind": 5,
        "importPath": "utils.logging_utils",
        "description": "utils.logging_utils",
        "peekOfCode": "system_logger = logging.getLogger(\"neuro_assistant\")\ndef filter_sensitive_data(text):\n    \"\"\"\n    Фильтрует конфиденциальные данные из текста\n    Args:\n        text: Исходный текст\n    Returns:\n        Текст с замаскированными конфиденциальными данными\n    \"\"\"\n    import re",
        "detail": "utils.logging_utils",
        "documentation": {}
    },
    {
        "label": "ensure_log_files_exist",
        "kind": 2,
        "importPath": "utils.log_maintenance",
        "description": "utils.log_maintenance",
        "peekOfCode": "def ensure_log_files_exist():\n    \"\"\"\n    Проверяет существование необходимых файлов логов и создает их при необходимости\n    \"\"\"\n    logger = logging.getLogger(\"neuro_assistant\")\n    # Создаем директорию для логов, если она не существует\n    if not os.path.exists(Config.LOGS_DIR):\n        os.makedirs(Config.LOGS_DIR)\n        logger.info(f\"Создана директория для логов: {Config.LOGS_DIR}\")\n    # Список файлов логов, которые должны существовать",
        "detail": "utils.log_maintenance",
        "documentation": {}
    },
    {
        "label": "clean_old_logs",
        "kind": 2,
        "importPath": "utils.log_maintenance",
        "description": "utils.log_maintenance",
        "peekOfCode": "def clean_old_logs(max_age_days=30):\n    \"\"\"\n    Удаляет старые файлы логов\n    Args:\n        max_age_days: Максимальный возраст файлов в днях\n    \"\"\"\n    from datetime import datetime, timedelta\n    logger = logging.getLogger(\"neuro_assistant\")\n    # Вычисляем пороговую дату\n    threshold_date = datetime.now() - timedelta(days=max_age_days)",
        "detail": "utils.log_maintenance",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "TestBasicConnections",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:\n            warnings.warn(\"Skipping test_remote_connection\")",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestThreadedConnection",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestThreadedConnection(unittest.TestCase):\n    def test_initialised_thread(self):\n        \"\"\"A WMI connection in a thread which has been initialised for COM\n        should succeed.\n        \"\"\"\n        def f(q):\n            pythoncom.CoInitialize()\n            try:\n                try:\n                    wmi.WMI()",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMoniker",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestMoniker(unittest.TestCase):\n    def test_moniker(self):\n        \"\"\"Look at all possible options for moniker construction and pass\n        them through to a WMI connector\n        \"\"\"\n        for computer in COMPUTERS:\n            if computer in (None, \".\"):\n                local_authorities = [None]\n            else:\n                local_authorities = AUTHORITIES",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestFunctions",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestFunctions(unittest.TestCase):\n    times = [\n       ((2000, 1, 1), \"20000101******.******+***\"),\n       ((2000, 1, 1, 10, 0, 0), \"20000101100000.******+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100), \"20000101100000.000100+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100, \"GMT\"), \"20000101100000.000100+GMT\")\n    ]\n    def test_signed_to_unsigned(self):\n        tests = [\n           (0, 0),",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWMI",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestWMI(unittest.TestCase):\n    def setUp(self):\n        self.connection = wmi.WMI(namespace=\"root/cimv2\", find_classes=False)\n        self.logical_disks = set(self.connection.Win32_LogicalDisk())\nclass TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestNamespace",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):\n        self.assert_(set([\"Win32_LogicalDisk\", \"Win32_MappedLogicalDisk\"]) <= set(self.connection.subclasses_of(\"CIM_LogicalDevice\", \"Win32_.*Disk\")))\n    def test_instances(self):\n        self.assertEquals(self.logical_disks, set(self.connection.instances(\"Win32_LogicalDisk\")))\n    def test_new(self):",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestClass",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestClass(TestWMI):\n    def test_class_from_namespace(self):\n        self.assert_(self.connection.Win32_ComputerSystem._namespace is self.connection)\n    def test_class_without_namespace(self):\n        wmi_class = wmi.GetObject(\"winmgmts:Win32_ComputerSystem\")\n        self.assert_(wmi._wmi_class(None, wmi_class)._namespace)\n    def test_query(self):\n        self.assertEquals(\n            set(self.connection.Win32_ComputerSystem.query()),\n            set(self.connection.query(\"SELECT * FROM Win32_ComputerSystem\"))",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWatcher",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestWatcher(TestWMI):\n    def new_letter(self):\n        return \\\n            set(\"%s:\" % chr(i) for i in range(ord('A'), 1 + ord('Z'))).\\\n            difference(d.DeviceID for d in self.connection.Win32_LogicalDisk()).\\\n            pop()\n    @staticmethod\n    def create(new_letter):\n        #~ print(\"about to create drive with letter\", new_letter)\n        here = os.path.dirname(os.path.abspath(__file__))",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMethods",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestMethods(TestWMI):\n    def test_exists(self):\n        \"Check that a well-known method is available by attribute\"\n        self.assert_(self.connection.Win32_Process.Create)\n    def test_params(self):\n        \"Check that the names and arrayness of params are picked up when not arrays\"\n        self.assertEquals(\n            [(n, False) for n in [\"CommandLine\", \"CurrentDirectory\", \"ProcessStartupInformation\"]],\n            self.connection.Win32_Process.Create.in_parameter_names\n        )",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestProperties",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestProperties(TestWMI):\n    def test_access(self):\n        \"Check that all properties are available as attributes\"\n        for d in self.logical_disks:\n            break\n        for p in d.ole_object.Properties_:\n            self.assertEqual(p.Value, getattr(d, p.Name))\n    def test_attribute_passthrough(self):\n        \"Check that unknown attributes are passed through to the underlying object\"\n        for d in self.logical_disks:",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstances",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestInstances(TestWMI):\n    def test_hashable(self):\n        \"Ensure instances are hashable so can be used in a set/dict\"\n        self.assert_(dict.fromkeys(self.logical_disks))\n    def test_equalable(self):\n        \"Ensure instances compare equal\"\n        self.assertEqual(self.logical_disks, self.logical_disks)\n    def test_not_equal_to_anything_else(self):\n        \"Ensure WMI instances are not equal to non-WMI instances\"\n        for d in self.logical_disks:",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstanceCreation",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestInstanceCreation(TestWMI):\n    def test_create_instance(self):\n        self.assert_(isinstance(self.connection.Win32_ProcessStartup.new(ShowWindow=2), wmi._wmi_object))\nclass TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestAssociations",
        "kind": 6,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "class TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #\n        for q in self.connection.Win32_DiskQuota():\n            for p in q.properties:\n                try:",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "ini",
        "kind": 5,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "ini = ConfigParser.SafeConfigParser()\nini.read([\"wmitest.master.ini\", \"wmitest.ini\"])\nsettings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "settings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "excludes",
        "kind": 5,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "excludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "COMPUTERS",
        "kind": 5,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "COMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "IMPERSONATION_LEVELS",
        "kind": 5,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "IMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHENTICATION_LEVELS",
        "kind": 5,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "AUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHORITIES",
        "kind": 5,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "AUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "PRIVILEGES",
        "kind": 5,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "PRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "NAMESPACES",
        "kind": 5,
        "importPath": "venv.Scripts.wmitest",
        "description": "venv.Scripts.wmitest",
        "peekOfCode": "NAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:",
        "detail": "venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "link",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "start_doc",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"\n    <html>\n    <head>\n    <title>%(title)s</title>\n    <style>\n    body {font-family : Verdana, sans-serif; font-size : 84%%; margin : 3em;}\n    table.items {padding-left : 30px;}\n    li, td {font-family : \"Courier New\", monospace;}",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "finish_doc",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def finish_doc():\n    doc.append(\"\"\"\n    </body>\n    </html>\n    \"\"\" % locals())\ndef doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_table",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")\n        for n_col in range(n_cols):\n            item = items[n_cols * n_col + n_row]\n            if callback:\n                item = callback(item)\n            doc.append(\"<td><li>%s</li></td>\" % item)",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_breadcrumbs",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def doc_breadcrumbs(computer, namespace, wmi_class=None):\n    doc.append('<p class=\"breadcrumbs\">')\n    doc.append('%s &rarr; %s' % (link(computer, computer), link(namespace, computer, namespace)))\n    if wmi_class:\n        doc.append(' &rarr; %s' % (link(wmi_class, computer, namespace, wmi_class)))\n    doc.append('</p>')\ndef doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_wmi_class",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())\n    klass = getattr(wmi_connection, wmi_class)\n    def property_callback(property_name):\n        property = klass.wmi_property(property_name)\n        mapping = property.qualifiers.get(\"MappingStrings\")\n        if mapping is None:\n            return property_name",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_namespace",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def doc_namespace(computer, namespace, wmi_connection):\n    start_doc(\"WMI: Namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace)\n    namespaces = namespace.split(\"\\\\\")\n    namespace_links = []\n    for i, n in enumerate(namespaces):\n        namespace_links.append(link(n, computer, \"\\\\\".join(namespaces[:i+1])))\n    doc.append(\"<h2>%s</h2>\" % \"\\\\\".join(namespace_links))\n    doc.append(\"<hr>\")\n    subnamespaces = sorted(wmi_connection.__NAMESPACE())",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_namespace",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def handle_namespace(environ, computer, namespace):\n    if not namespace:\n        wmi_connection = wmi.WMI(computer, namespace=\"root/cimv2\")\n        for setting in wmi_connection.Win32_WMISetting():\n            namespace=setting.ASPScriptDefaultNamespace\n            break\n    wmi_connection = wmi.WMI(computer, namespace=namespace, find_classes=True)\n    wmi_class = shift_path_info(environ)\n    if wmi_class:\n        doc_wmi_class(computer, namespace, wmi_class, wmi_connection)",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_computer",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def handle_computer(environ, computer):\n    handle_namespace(environ, computer, shift_path_info(environ))\ndef app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)\n        return(unicode(d).encode(\"utf8\") + unicode(\"\\n\").encode(\"utf8\") for d in doc)\n    else:",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "run_browser",
        "kind": 2,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "def run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:\n        print(\"Shutting down gracefully...\")",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc",
        "kind": 5,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "doc = []\ndef link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "venv.Scripts.wmiweb",
        "description": "venv.Scripts.wmiweb",
        "peekOfCode": "PORT = 8010\ndef run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:",
        "detail": "venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "ai_models_page",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def ai_models_page():\n    \"\"\"Страница управления нейросетями\"\"\"\n    return render_template(\"ai_models.html\")\n@app.route(\"/health\")\ndef health_check():\n    \"\"\"Health check для мониторинга и UI тестов\"\"\"\n    import time\n    print(f\"🔍 Health check called at {time.time()}\")\n    return {\"status\": \"ok\", \"timestamp\": time.time()}, 200\n@app.route(\"/\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "health_check",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def health_check():\n    \"\"\"Health check для мониторинга и UI тестов\"\"\"\n    import time\n    print(f\"🔍 Health check called at {time.time()}\")\n    return {\"status\": \"ok\", \"timestamp\": time.time()}, 200\n@app.route(\"/\")\ndef index():\n    \"\"\"Главная страница - тоже нужна для health check\"\"\"\n    print(f\"🔍 Index page called\")\n    return render_template(\"index.html\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def index():\n    \"\"\"Главная страница - тоже нужна для health check\"\"\"\n    print(f\"🔍 Index page called\")\n    return render_template(\"index.html\")\n# ✅ НОВОЕ: Обработчик ошибки 404\n@app.errorhandler(404)\ndef not_found_error(error):\n    \"\"\"Обработчик ошибки 404 - страница не найдена\"\"\"\n    print(f\"🔍 404 error for URL: {request.url}\")\n    return render_template(\"404.html\"), 404",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "not_found_error",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def not_found_error(error):\n    \"\"\"Обработчик ошибки 404 - страница не найдена\"\"\"\n    print(f\"🔍 404 error for URL: {request.url}\")\n    return render_template(\"404.html\"), 404\n# ✅ НОВОЕ: Обработчик ошибки 500 (на будущее)\n@app.errorhandler(500)\ndef internal_error(error):\n    \"\"\"Обработчик внутренней ошибки сервера\"\"\"\n    print(f\"🔍 500 error: {error}\")\n    return render_template(\"500.html\"), 500",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "internal_error",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def internal_error(error):\n    \"\"\"Обработчик внутренней ошибки сервера\"\"\"\n    print(f\"🔍 500 error: {error}\")\n    return render_template(\"500.html\"), 500\n# ✅ НОВОЕ: API endpoints для аутентификации (добавляем здесь для тестов)\n@app.route(\"/api/auth/register\", methods=[\"POST\"])\ndef auth_register():\n    \"\"\"Регистрирует нового пользователя.\"\"\"\n    try:\n        data = request.get_json()",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "auth_register",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def auth_register():\n    \"\"\"Регистрирует нового пользователя.\"\"\"\n    try:\n        data = request.get_json()\n        if not data:\n            return jsonify({\"success\": False, \"message\": \"Данные не предоставлены\"}), 400\n        username = data.get(\"username\")\n        email = data.get(\"email\")\n        password = data.get(\"password\")\n        display_name = data.get(\"display_name\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "auth_login",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def auth_login():\n    \"\"\"Аутентифицирует пользователя.\"\"\"\n    try:\n        data = request.get_json()\n        if not data:\n            return jsonify({\"success\": False, \"message\": \"Данные не предоставлены\"}), 400\n        username = data.get(\"username\")\n        password = data.get(\"password\")\n        if not all([username, password]):\n            return (",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "auth_me",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def auth_me():\n    \"\"\"Получает информацию о текущем пользователе по токену.\"\"\"\n    try:\n        # Получаем токен из заголовка Authorization\n        auth_header = request.headers.get(\"Authorization\")\n        if not auth_header or not auth_header.startswith(\"Bearer \"):\n            return jsonify({\"success\": False, \"message\": \"Токен не предоставлен\"}), 401\n        token = auth_header.split(\" \")[1]\n        # Проверяем токен и получаем пользователя\n        from core.db.connection import get_db",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "init_app",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def init_app():\n    \"\"\"Инициализация приложения\"\"\"\n    global command_interrupt_flag\n    print(\"🔍 Начало init_app()\")\n    try:\n        # Инициализация системы логирования\n        from utils.logging_utils import init_logging_system\n        print(\"🔍 Инициализация логирования...\")\n        init_logging_system()\n        print(\"✅ Логирование инициализировано\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "run_app",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def run_app():\n    \"\"\"Запуск приложения\"\"\"\n    try:\n        print(\"🚀 Запуск Нейро-Линк Ассистента...\")\n        # Инициализируем приложение\n        flask_app = init_app()\n        # Запускаем Flask сервер\n        from config import Config\n        flask_app.run(\n            host=Config.HOST,",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "command_interrupt_flag",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "command_interrupt_flag = False\n# Создание приложения Flask\napp = Flask(__name__)\n# Настройка логирования\nlogger = logging.getLogger(\"neuro_assistant\")\n@app.route(\"/ai_models\")\ndef ai_models_page():\n    \"\"\"Страница управления нейросетями\"\"\"\n    return render_template(\"ai_models.html\")\n@app.route(\"/health\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "app = Flask(__name__)\n# Настройка логирования\nlogger = logging.getLogger(\"neuro_assistant\")\n@app.route(\"/ai_models\")\ndef ai_models_page():\n    \"\"\"Страница управления нейросетями\"\"\"\n    return render_template(\"ai_models.html\")\n@app.route(\"/health\")\ndef health_check():\n    \"\"\"Health check для мониторинга и UI тестов\"\"\"",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "logger = logging.getLogger(\"neuro_assistant\")\n@app.route(\"/ai_models\")\ndef ai_models_page():\n    \"\"\"Страница управления нейросетями\"\"\"\n    return render_template(\"ai_models.html\")\n@app.route(\"/health\")\ndef health_check():\n    \"\"\"Health check для мониторинга и UI тестов\"\"\"\n    import time\n    print(f\"🔍 Health check called at {time.time()}\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "class Config:\n    \"\"\"Конфигурация приложения\"\"\"\n    # Основные настройки Flask\n    SECRET_KEY = os.getenv(\"SECRET_KEY\", \"default-secret-key\")\n    DEBUG = os.getenv(\"DEBUG\", \"True\").lower() == \"true\"\n    HOST = os.getenv(\"HOST\", \"127.0.0.1\")\n    PORT = int(os.getenv(\"PORT\", 5000))\n    # Настройки логирования\n    LOGS_DIR = \"logs\"  # Директория для хранения логов\n    SUMMARY_LOG_FILE = os.path.join(",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "conftest",
        "description": "conftest",
        "peekOfCode": "project_root = os.path.abspath(os.path.dirname(__file__))\nsys.path.insert(0, project_root)\n# Убеждаемся, что все основные модули доступны\nsys.path.insert(0, os.path.join(project_root, \"core\"))\nsys.path.insert(0, os.path.join(project_root, \"routes\"))\nsys.path.insert(0, os.path.join(project_root, \"services\"))\nsys.path.insert(0, os.path.join(project_root, \"utils\"))\n# Настройки для тестовой среды\nos.environ.setdefault(\"TESTING\", \"true\")\nos.environ.setdefault(\"FLASK_ENV\", \"testing\")",
        "detail": "conftest",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "fix_migration",
        "description": "fix_migration",
        "peekOfCode": "DATABASE_URL = os.environ.get(\n    \"DATABASE_URL\", \"postgresql://neurolink:secure_password@localhost:5432/neurolink\"\n)\nprint(f\"Подключаемся к: {DATABASE_URL}\")\ntry:\n    engine = create_engine(DATABASE_URL)\n    with engine.connect() as conn:\n        # Проверяем текущую версию\n        result = conn.execute(text(\"SELECT version_num FROM alembic_version;\"))\n        current_version = result.fetchone()",
        "detail": "fix_migration",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "reset_migrations",
        "description": "reset_migrations",
        "peekOfCode": "DATABASE_URL = os.environ.get(\n    \"DATABASE_URL\", \"postgresql://neurolink:secure_password@localhost:5432/neurolink\"\n)\nengine = create_engine(DATABASE_URL)\ntry:\n    with engine.connect() as conn:\n        # Удаляем таблицу версий\n        conn.execute(text(\"DROP TABLE IF EXISTS alembic_version;\"))\n        conn.commit()\n        print(\"✅ Таблица alembic_version удалена\")",
        "detail": "reset_migrations",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "reset_migrations",
        "description": "reset_migrations",
        "peekOfCode": "engine = create_engine(DATABASE_URL)\ntry:\n    with engine.connect() as conn:\n        # Удаляем таблицу версий\n        conn.execute(text(\"DROP TABLE IF EXISTS alembic_version;\"))\n        conn.commit()\n        print(\"✅ Таблица alembic_version удалена\")\nexcept Exception as e:\n    print(f\"Ошибка: {e}\")",
        "detail": "reset_migrations",
        "documentation": {}
    },
    {
        "label": "test_huggingface_connection",
        "kind": 2,
        "importPath": "test_huggingface",
        "description": "test_huggingface",
        "peekOfCode": "def test_huggingface_connection():\n    \"\"\"Тестируем подключение к HuggingFace\"\"\"\n    print(\"🤖 Тестирование HuggingFace подключения...\")\n    # Инициализируем сервис\n    hf_service = HuggingFaceService()\n    # Проверяем токен\n    if hf_service.token:\n        print(f\"✅ Токен HuggingFace найден: {hf_service.token[:10]}...\")\n    else:\n        print(\"❌ Токен HuggingFace не найден!\")",
        "detail": "test_huggingface",
        "documentation": {}
    },
    {
        "label": "test_ai_models_file",
        "kind": 2,
        "importPath": "test_huggingface",
        "description": "test_huggingface",
        "peekOfCode": "def test_ai_models_file():\n    \"\"\"Тестируем файл с AI моделями\"\"\"\n    print(\"\\n📋 Проверяем файл с AI моделями...\")\n    try:\n        models = get_ai_models()\n        if \"error\" in models:\n            print(f\"❌ Ошибка: {models['error']}\")\n            return False\n        models_list = models.get(\"models\", [])\n        print(f\"✅ Найдено {len(models_list)} моделей:\")",
        "detail": "test_huggingface",
        "documentation": {}
    },
    {
        "label": "test_simple_request",
        "kind": 2,
        "importPath": "test_huggingface",
        "description": "test_huggingface",
        "peekOfCode": "def test_simple_request():\n    \"\"\"Тестируем простой запрос к AI\"\"\"\n    print(\"\\n🧠 Тестируем простой AI запрос...\")\n    try:\n        # Используем текущую модель из файла\n        from services.ai_service import get_current_ai_model\n        current_model = get_current_ai_model()\n        if not current_model:\n            print(\"❌ Текущая модель не найдена\")\n            return False",
        "detail": "test_huggingface",
        "documentation": {}
    },
    {
        "label": "add_simple_test_model",
        "kind": 2,
        "importPath": "test_huggingface",
        "description": "test_huggingface",
        "peekOfCode": "def add_simple_test_model():\n    \"\"\"Добавляем простую тестовую модель\"\"\"\n    try:\n        from services.ai_service import add_model\n        # Добавляем DistilGPT-2 как простую тестовую модель\n        model_data = {\n            \"id\": \"distilgpt2-test\",\n            \"name\": \"DistilGPT-2 (Test)\",\n            \"description\": \"Легкая модель для тестирования\",\n            \"huggingface_id\": \"distilgpt2\",",
        "detail": "test_huggingface",
        "documentation": {}
    }
]