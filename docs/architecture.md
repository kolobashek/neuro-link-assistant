# Архитектурные принципы Neuro-Link Assistant

## 1. Общая архитектура

Система построена на принципах модульности, расширяемости и тестируемости. Основной подход - разделение по уровням абстракции и платформенным зависимостям.

### 1.1. Структура каталогов

```
core/
│
├── common/                       # Общие компоненты и базовые классы
│   ├── error_handler.py
│   ├── filesystem/
│   ├── input/                    # Подсистема ввода
│   ├── process/
│   ├── registry/
│   ├── system/
│   └── window/
│
├── component_registry.py         # Реестр компонентов системы
├── plugin_manager.py             # Менеджер плагинов
├── system_initializer.py         # Инициализатор системы
│
├── platform/                     # Платформенно-зависимый код
│   ├── windows/                  # Реализации для Windows
│   │   ├── filesystem/
│   │   ├── input/
│   │   ├── process/
│   │   ├── system/
│   │   └── window/
│   └── ...                       # Другие платформы в будущем
│
├── db/                           # Подсистема базы данных
├── utils/                        # Утилиты
├── vision/                       # Подсистема компьютерного зрения
└── web/                          # Подсистема работы с веб
```

### 1.2. Принципы SOLID

#### 1.2.1. Single Responsibility Principle (SRP)
Каждый класс имеет только одну причину для изменения. Например:
- `AbstractKeyboard` отвечает только за определение интерфейса клавиатуры
- `WindowsKeyboard` отвечает только за реализацию этого интерфейса для Windows
- `InputRegistry` отвечает только за регистрацию и поиск контроллеров ввода

#### 1.2.2. Open/Closed Principle (OCP)
Классы открыты для расширения, но закрыты для модификации:
- Новые контроллеры ввода могут быть добавлены путем реализации интерфейсов без изменения существующего кода
- Фабрики обеспечивают создание нужных реализаций без изменения пользовательского кода

#### 1.2.3. Liskov Substitution Principle (LSP)
Подклассы могут заменять базовые классы без изменения поведения системы:
- Любая реализация `AbstractKeyboard` должна работать везде, где ожидается `AbstractKeyboard`
- Все методы подклассов должны соответствовать контрактам, определенным в абстрактных классах

#### 1.2.4. Interface Segregation Principle (ISP)
Много специализированных интерфейсов лучше одного универсального:
- Отдельные интерфейсы для клавиатуры и мыши
- Интерфейсы разделены по функциональным областям

#### 1.2.5. Dependency Inversion Principle (DIP)
Зависимость от абстракций, а не от конкретных реализаций:
- Компоненты зависят от абстрактных интерфейсов, а не от конкретных классов
- Реализации внедряются через DI или фабрики

### 1.3. Используемые паттерны проектирования

#### 1.3.1. Factory (Фабрика)
Используется для создания объектов без привязки к конкретным классам:
- `get_keyboard()` и `get_mouse()` в `factory.py`
- Фабричные методы позволяют создавать нужные реализации в зависимости от платформы

#### 1.3.2. Singleton (Одиночка)
Используется для глобальных реестров и менеджеров:
- `InputRegistry` реализован как синглтон для доступа из любой части приложения
- Обеспечивает единую точку доступа к реестру контроллеров

#### 1.3.3. Strategy (Стратегия)
Позволяет выбирать алгоритм во время выполнения:
- Разные стратегии ввода текста (человекоподобная или программная)
- Взаимозаменяемые реализации для разных платформ

#### 1.3.4. Observer (Наблюдатель)
Механизм для оповещения компонентов о событиях:
- Планируется для отслеживания событий ввода
- Будет использоваться для реакции на действия пользователя

#### 1.3.5. Command (Команда)
Инкапсуляция действий в объекты:
- Планируется для последовательностей действий ввода
- Позволит сохранять, повторять и отменять действия

## 2. Конвенции кодирования

### 2.1. Именование

- **Классы**: CamelCase (например, `InputController`)
- **Методы и функции**: snake_case (например, `press_key()`)
- **Константы**: UPPER_SNAKE_CASE (например, `DEFAULT_TIMEOUT`)
- **Приватные члены**: Префикс с подчеркиванием (например, `_private_method()`)
- **Интерфейсы**: Префикс Abstract или суффикс Base/Interface (например, `AbstractKeyboard`)

### 2.2. Документирование

- Все публичные классы и методы должны иметь docstrings в формате Google
- Сложные алгоритмы должны быть снабжены комментариями
- Примеры использования должны быть включены в документацию

### 2.3. Обработка ошибок

- Использовать исключения для обработки нештатных ситуаций
- Создавать специализированные исключения для разных типов ошибок
- Логировать все исключения с контекстом через `error_handler`

## 3. Тестирование

### 3.1. Модульные тесты

- Каждый класс и метод должен быть покрыт модульными тестами
- Тесты должны быть независимыми и воспроизводимыми
- Используется mocking для изоляции компонентов

### 3.2. Интеграционные тесты

- Тестирование взаимодействия между компонентами
- Проверка сценариев использования компонентов вместе
- Изоляция от внешних систем (ОС, устройства) через моки

### 3.3. Автоматизированное тестирование

- CI/CD через GitHub Actions
- Автоматический запуск тестов при push и pull request
- Отслеживание покрытия кода тестами
```

## 5. Обновление README.md с информацией об архитектуре

```markdown:README.md
# Neuro-Link Assistant

## Архитектура проекта

Neuro-Link Assistant использует модульную архитектуру, основанную на принципах SOLID и паттернах проектирования. Система разделена на следующие ключевые компоненты:

- **Ядро системы (core)** - основные компоненты и интерфейсы
- **Подсистема ввода (input)** - работа с клавиатурой и мышью
- **Подсистема файловой системы** - работа с файлами и директориями
- **Подсистема компьютерного зрения** - анализ экрана и распознавание объектов
- **Подсистема работы с веб** - взаимодействие с браузерами и сайтами

Подробная документация по архитектуре доступна в [docs/architecture.md](docs/architecture.md).

## Разработка

### Тестирование

Проект следует принципам TDD (разработка через тестирование):

```bash
# Запуск модульных тестов
pytest tests/unit

# Запуск интеграционных тестов
pytest tests/integration

# Запуск с отчетом о покрытии
pytest tests/unit --cov=core
```
